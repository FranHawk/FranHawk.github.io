<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="张竞豪的小岛">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="张竞豪的小岛">
<meta property="og:locale">
<meta property="article:author" content="Fran Hawk">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'cn'
  };
</script>

  <title>张竞豪的小岛</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="تشغيل شريط التصفح">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">张竞豪的小岛</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>الأرشيفات</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/09/RT-Thread%20ART-PI%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9ATouchGFX%E4%BB%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fran Hawk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张竞豪的小岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/09/RT-Thread%20ART-PI%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9ATouchGFX%E4%BB%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87/" class="post-title-link" itemprop="url">RT-Thread ART-PI 学习笔记：TouchGFX通过文件系统读取图片</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2021-02-09 19:50:43" itemprop="dateCreated datePublished" datetime="2021-02-09T19:50:43+08:00">2021-02-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2021-08-16 22:21:18" itemprop="dateModified" datetime="2021-08-16T22:21:18+08:00">2021-08-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>TouchGFX界面中可能会存在占用空间比较大的图片资源，在默认情况下，图片资源会随着其他只读数据一起放入芯片的已经经过内存映射的闪存中，系统可以直接通过地址访问到图片</p>
<p>这个机制虽然对art-pi没什么影响，因为art-pi的只读段放在片外空间比较大的8M NOR FLASH里，空间还算大。而且这块FLASH因为是NOR FLASH，经过内存映射，也可以通过地址直接访问指令和数据，和片内ROM的访问方式一样了。这就是是常说的代码(.text段)在片外flash上运行</p>
<p>但是对于ROM空间比较小的单片机，还没有外挂flash，内部空间捉襟见肘，就需要考虑采用把图片放入sd卡等非内存映射的闪存中以节省空间</p>
<p>TouchGFX提供了一种位图缓存机制，允许把图片放入sd卡等非内存映射的缓存中，系统上电时将部分或全部图片放在位于RAM的位图缓存中</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_31039061/article/details/109763842">【STM32H750】玩转ART-Pi（七）——TouchGFX从文件系统中读取图片</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_31039061/article/details/108638097">【STM32H750】玩转ART-Pi（三）——如何在ART-PI上创建TouchGFX工程</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lzs940320/article/details/112437259">14.RT-thread项目实战–TouchGFx界面效果优化</a></p>
<p>上面两篇博客用的方法都是依据touchgfx官方文档的步骤，我觉得可以主要参考官方文档，上面两篇博客描述的步骤已经很详细了，但是还是有一点不足之处，这个我在后面会提到</p>
<p><a target="_blank" rel="noopener" href="https://support.touchgfx.com/4.16/docs/development/scenarios/using-non-memory-mapped-flash">使用非内存映射闪存存储图像</a></p>
<p><a target="_blank" rel="noopener" href="https://support.touchgfx.com/4.16/docs/development/ui-development/touchgfx-engine-features/caching-bitmaps">缓存位图</a></p>
<p>上面两篇是官方文档，教的过程已经比较详细了，实践时只用稍作改动，下面我的操作都是按照官方文档来的</p>
<h1 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h1><p>本文演示代码<a target="_blank" rel="noopener" href="https://download.csdn.net/download/weixin_42487906/21110777?spm=1001.2014.3001.5503">https://download.csdn.net/download/weixin_42487906/21110777?spm=1001.2014.3001.5503</a></p>
<p>一定要在sd卡或者16M nor flash里面有相应图片的二进制bin文件这个工程才可以正常运行，如何操作见我的这篇博客</p>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul>
<li>RT-Thread Studio 2.1.1：一站式的 RT-Thread 开发工具，通过简单易用的图形化配置系统以及丰富的软件包和组件资源，让物联网开发变得简单和高效。<a target="_blank" rel="noopener" href="https://www.rt-thread.org/page/studio.html">官网链接</a></li>
<li>touchgfx designer 4.16：touchgfx 界面设计工具，去官网上下载就可以了,版本不能低于4.15 <a target="_blank" rel="noopener" href="https://www.st.com/zh/development-tools/touchgfxdesigner.html">官网链接</a></li>
</ul>
<h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul>
<li>RT-Thread 推出的ART-PI STM32H750开发板</li>
<li>正点原子 800*480 4.3寸 RGBLCD屏，搭载GT9147触摸芯片</li>
</ul>
<p><strong>在进行本篇操作之前必须配置文件系统，wifi功能和ftp服务器，并且使能touchgfx库，这几个操作在我之前的学习笔记中都有讲</strong></p>
<p><strong>同时我使用1.10版本的BSP，最新的1.21版本在配置touchgfx后会报错不知道问题出在哪里</strong></p>
<h1 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h1><p>在配置完touchgfx图形库后，用touchgfx designer 打开art_pi.touchgfx</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815182832479.png" alt="image-20210815182832479" style="zoom: 67%;" />

<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815184154449.png" alt="image-20210815184154449"></p>
<p>可以看到默认工程中有几张png格式的位图资源，下面我们就把他们转移到sd卡或者flash里面去</p>
<p>首先根据官方文档修改连接器脚本</p>
<p>默认情况下，TouchGFX中的所有位图都放入ExtFlashSection中，标准的链接描述文件（此处为GCC）将其他只读数据一起放入闪存。</p>
<p>下面我们把数据放在0x9A000000的ExtFlashSection中</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815184100882.png" alt="image-20210815184100882" style="zoom: 67%;" />

<p>根据官方文档，打开link.lds连接脚本，添加一块名为USB的存储区域，可读可写可执行</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815184306491.png" alt="image-20210815184306491" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815184459354.png" alt="image-20210815184459354" style="zoom: 67%;" />

<p>不用担心这块存储区域会占用系统资源，因为虽然链接产生的elf文件中会多一个USB段，但是最后烧进板子里的是elf经过objcopy处理生成的bin文件，这个文件只会包含图中的ROM和RAM段</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815184427238.png" alt="image-20210815184427238" style="zoom:67%;" />

<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815195956496.png" alt="image-20210815195956496"></p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815200536137.png" alt="image-20210815200536137"></p>
<p>虽然图片文件根据lds文件链接到elf中，但是并不会被烧写到板子中，程序运行时并没有操作系统，不会像电脑那样将elf文件自动解析并将各个段放到ram和rom的指定位置。而是根据上图，elf会经过objcopy文件将RAM，ROM等可存储区域提取到rtthread.bin这个二进制文件中去，由烧写算法烧写到板子的制定位置。而USB区域并不会被烧写到板子中，这一步结束后需要用objcopy将 ExtFlashSection 段提取到一个二进制文件中，在rtthread里面是rtthread.bin,再把这个二进制文件放到SD卡或者flash里面，供程序读取。</p>
<p>编译时的命令，从上图可以看到使用了objcopy</p>
<p>上面的操作完成后，用记事本等文本编辑器打开link.lds</p>
<p>根据touchgfx官网的文档，将以下代码添加到link.lds的__bss_start = .; 和 _end = .;之间,最终效果如第三张图</p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815184751840.png" alt="image-20210815184751840"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExtFlashSection :</span><br><span class="line">&#123;</span><br><span class="line">	KEEP(*(ExtFlashSection.*))</span><br><span class="line">	. = ALIGN(4);</span><br><span class="line">&#125; &gt; USB</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815185528288.png" alt="image-20210815185528288" style="zoom: 50%;" />

<p>重新编译链接工程，打开rtthread.map看看ExtFlashSection被链接到哪个地址了</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815190141050.png" alt="image-20210815190141050" style="zoom: 67%;" />

<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815190204654.png" alt="image-20210815190204654" style="zoom: 67%;" />

<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815190502382.png" alt="image-20210815190502382"></p>
<p>在rtthread.map文件中搜索ExtFlashSection可以发现几个图片文件被连接到0x9a000000的位置，总大小为0x68230=426544字节</p>
<p><strong>在rtthread studio中配置如下命令将ExtFlashSection从elf文件中拷贝出来</strong></p>
<p>相当于将生成的图片二进制文件从elf里整出来，好放到sdcard等位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-none-eabi-objcopy -O binary -j ExtFlashSection &quot;$&#123;BuildArtifactFileBaseName&#125;.elf&quot; &quot;images.bin&quot;</span><br></pre></td></tr></table></figure>

<p>通过查阅objcopy指令可以得知上述指令是将ExtFlashSection这个段以二进制文件的方式复制出来</p>
<p>objcopy参考博客：</p>
<p><a target="_blank" rel="noopener" href="http://www.manongjc.com/detail/22-pohrelllskvguhd.html">http://www.manongjc.com/detail/22-pohrelllskvguhd.html</a></p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815194454891.png" alt="image-20210815194454891"></p>
<p>把这个命令添加到构建后步骤</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815200728843.png" alt="image-20210815200728843" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815200831266.png" alt="image-20210815200831266" style="zoom:67%;" />

<p>重新编译可以看到新添加的命令被执行</p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815203432962.png" alt="image-20210815203432962"></p>
<p>DEBUG目录下生成了images.bin二进制文件</p>
<p>在TouchGFXHAL.cpp中添加如下代码，改掉blockcopy函数</p>
<p><strong>新的blockCopy函数我参考了上面的两篇博客，这两篇博客中提到他们改过的blockCopy方法可以在检查完sd卡有没有相应文件后再去flash中检查，但是在实际用的时候，并不能读到flash里面的文件，看下了发现是代码逻辑问题，于是我改正了一下，下面的代码可以实现若sd卡未挂载或未存在相应文件时去flash查找</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dfs_posix.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TouchGFXHAL::blockCopy</span><span class="params">(<span class="keyword">void</span>* RESTRICT dest, <span class="keyword">const</span> <span class="keyword">void</span>* RESTRICT src, <span class="keyword">uint32_t</span> numBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> dataOffset = (<span class="keyword">uint32_t</span>) src;</span><br><span class="line">    <span class="keyword">if</span> (dataOffset &gt;= <span class="number">0x9A000000</span> &amp;&amp; dataOffset &lt; <span class="number">0xA0000000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">statfs</span> <span class="title">buffer</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (rt_device_find(<span class="string">&quot;sd0&quot;</span>) != RT_NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((dfs_statfs(<span class="string">&quot;/sdcard&quot;</span>, &amp;buffer) == RT_EOK) | (dfs_mount(<span class="string">&quot;sd0&quot;</span>, <span class="string">&quot;/sdcard&quot;</span>, <span class="string">&quot;elm&quot;</span>, <span class="number">0</span>, <span class="number">0</span>) == RT_EOK))</span><br><span class="line">            &#123;</span><br><span class="line">                fd = open(<span class="string">&quot;/sdcard/images.bin&quot;</span>, O_RDONLY, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//rt_kprintf(&quot;open file from sdcard failed,find from /flash\n&quot;);</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dataOffset = dataOffset - <span class="number">0x9A000000</span>;</span><br><span class="line">                    lseek(fd, dataOffset, SEEK_SET);</span><br><span class="line">                    <span class="comment">// for copying data from there.</span></span><br><span class="line">                    read(fd, (<span class="keyword">uint8_t</span> *) dest, numBytes);</span><br><span class="line">                    close(fd);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dfs_statfs(<span class="string">&quot;/flash&quot;</span>, &amp;buffer) == RT_EOK)</span><br><span class="line">        &#123;</span><br><span class="line">            fd = open(<span class="string">&quot;/flash/images.bin&quot;</span>, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                rt_kprintf(<span class="string">&quot;open file for read failed\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dataOffset = dataOffset - <span class="number">0x9A000000</span>;</span><br><span class="line">            lseek(fd, dataOffset, SEEK_SET);</span><br><span class="line">            <span class="comment">// for copying data from there.</span></span><br><span class="line">            read(fd, (<span class="keyword">uint8_t</span> *) dest, numBytes);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// For all other addresses, just use the default implementation.</span></span><br><span class="line">        <span class="comment">// This is important, as blockCopy is also used for other things in the core framework.</span></span><br><span class="line">        <span class="keyword">return</span> TouchGFXGeneratedHAL::blockCopy(dest, src, numBytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过我列出的第二个touchgfx官方文档，将TouchGFXHAL.cpp中的TouchGFXHAL::initialize()改为下面的，启用和配置位图缓存，并且分配一块新的缓存区域设置位图缓存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TouchGFXHAL::initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Calling parent implementation of initialize().</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// To overwrite the generated implementation, omit call to parent function</span></span><br><span class="line">    <span class="comment">// and implemented needed functionality here.</span></span><br><span class="line">    <span class="comment">// Please note, HAL::initialize() must be called to initialize the framework.</span></span><br><span class="line"> </span><br><span class="line">    TouchGFXGeneratedHAL::initialize();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">uint16_t</span>* cacheStartAddr =(<span class="keyword">uint16_t</span> *)rt_malloc(<span class="number">0x1400000</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> cacheSize = <span class="number">0x1400000</span>;</span><br><span class="line"> </span><br><span class="line">    Bitmap::removeCache();</span><br><span class="line">    Bitmap::setCache(cacheStartAddr,cacheSize,<span class="number">1024</span>);</span><br><span class="line">    Bitmap::cacheAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过读卡器将images.bin复制到SD卡中，也可以通过ftp复制到SD卡或flash中</p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815204415575.png" alt="image-20210815204415575"></p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815210431030.png" alt="image-20210815210431030"></p>
<p>编译烧写后,发现程序报错，touchgfx初始化有问题，查看代码后发现touchgfx采用INIT_APP_INIT自动初始化机制，这种机制不能准确定义个模块初始化的顺序，这个模块可能是初始化的太早了，于是注释掉INIT_APP_INIT，并且在mian函数中调用TouchGFXTask();</p>
<p><strong>在TouchGFXTask();前我还加了一段延时，为了解决wifi和touchgfx同时使用导致开机时屏幕短暂花屏的现象</strong></p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815220243651.png" alt="image-20210815220243651"><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815220652663.png"></p>
<p>记得在main函数开始处添加extern</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">TouchGFXTask</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>最后编译烧写进板子，发现一切正常<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815220055708.png" alt="image-20210815220055708"></p>
<p>编译烧写后一切正常，屏幕运行正常</p>
<p><strong>终端显示sdcard挂载失败是正常现象，因为在TouchGFXHAL::blockCopy已经挂载过sdcard了</strong></p>
<p>但是这个bug看的我很难受，通过查rtthread官方文档发现sd卡挂载函数应该用INIT_ENV_EXPORT来初始化，但是改了之后还是会报sd卡挂载失败，可能是sd卡挂载本身需要一定时间造成的，最终还是blockcopy挂载sdcard的操作起了作用</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210816144919426.png" alt="image-20210816144919426" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210816144957127.png" alt="image-20210816144957127" style="zoom:50%;" />
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/09/RT-Thread%20ART-PI%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fran Hawk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张竞豪的小岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/09/RT-Thread%20ART-PI%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">RT-Thread ART-PI 学习笔记：文件系统的使用和配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2021-02-09 19:50:43" itemprop="dateCreated datePublished" datetime="2021-02-09T19:50:43+08:00">2021-02-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2021-08-16 15:12:28" itemprop="dateModified" datetime="2021-08-16T15:12:28+08:00">2021-08-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>文件管理功能是操作系统的重要组成。现代嵌入式设备需要对越来越多，越来越复杂的存储数据进行管理，于是嵌入式操作系统中1引入了文件系统来进行管理。</p>
<p>文件系统是一套实现了数据的存储、分级组织、访问和获取等操作的抽象数据类型 (Abstract data type)，是一种用于向用户提供底层数据访问的机制。文件系统通常存储的基本单位是文件，即数据是按照一个个文件的方式进行组织。当文件比较多时，将导致文件繁多，不易分类、重名的问题。而文件夹作为一个容纳多个文件的容器而存在。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/programming-manual/filesystem/filesystem/">RT-Thread 官方虚拟文件系统文档</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_31039061/article/details/104145805">相关博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_31039061/article/details/109763830">相关博客</a></p>
<h2 id="DFS架构"><a href="#DFS架构" class="headerlink" title="DFS架构"></a>DFS架构</h2><p>DFS 是 RT-Thread 提供的虚拟文件系统组件，全称为 Device File System，即设备虚拟文件系统，该文件系统使用起来的特性非常类似LINUX/UNIX的文件系统。</p>
<p>RT-Thread DFS 组件的主要功能特点有：</p>
<ul>
<li><p>为应用程序提供统一的 POSIX 文件和目录操作接口：read、write、poll/select 等。</p>
</li>
<li><p>支持多种类型的文件系统，如 FatFS、RomFS、DevFS 等，并提供普通文件、设备文件、网络文件描述符的管理。</p>
</li>
<li><p>支持多种类型的存储设备，如 SD Card、SPI Flash、Nand Flash 等。</p>
</li>
</ul>
<p>DFS 的层次架构如下图所示，主要分为 POSIX 接口层、虚拟文件系统层和设备抽象层。<br><img src="https://img-blog.csdnimg.cn/20210209094459628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>根据存储设备的不同，我们需要在DFS虚拟文件系统的根目录下挂载不同的文件系统，下面对几种文件系统进行介绍：</p>
<ul>
<li>FatFS 是专为小型嵌入式设备开发的一个兼容微软 FAT 格式的文件系统，采用 ANSI C 编写，具有良好的硬件无关性以及可移植性，是 RT-Thread 中最常用的文件系统类型。在本文中主要用于挂载板子上的SD卡</li>
<li>LittleFs是ARM官方推出的，小巧灵活的文件系统。具有掉电恢复，擦写均衡和占用RAM/ROM较少的特点。。在本文中主要用于挂载板子上的W25Q128JV这个16M的SPI NOR FLASH</li>
</ul>
<p>关于虚拟文件系统更多内容见官方文档，下文中的配置也是根据官方文档来做的。</p>
<p>ART-Pi 除了配备一颗 W25Q64JV 用于存放程序外,同时配备了另一颗 W25Q128JV 用于存放 WIFI 固件,蓝牙固件,等其它数据.官方建议这颗 W25Q128JV 的空间划分如下:</p>
<table>
<thead>
<tr>
<th>分区名</th>
<th>起始地址</th>
<th>分区大小</th>
<th>用途说明</th>
</tr>
</thead>
<tbody><tr>
<td>wifi_image</td>
<td>0</td>
<td>512KB</td>
<td>保存 wifi 固件</td>
</tr>
<tr>
<td>bt_image</td>
<td>512 * 1024</td>
<td>512KB</td>
<td>保存 bt 固件</td>
</tr>
<tr>
<td>download</td>
<td>1 * 1024 * 1024</td>
<td>2048KB</td>
<td>固件下载分区</td>
</tr>
<tr>
<td>easyflash</td>
<td>3 * 1024 * 1024</td>
<td>1024KB</td>
<td>easyflash 参数保存区</td>
</tr>
<tr>
<td>filesystem</td>
<td>4 * 1024 * 1024</td>
<td>12MB</td>
<td>文件系统分区</td>
</tr>
</tbody></table>
<p>本文主要使用和配置FatFS和LittleFs两种文件系统，分别用来挂载SD卡和NOR FLASH两种设备。两种文件系统均挂载在DFS构成的根文件系统上。</p>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul>
<li>RT-Thread Studio：一站式的 RT-Thread 开发工具，通过简单易用的图形化配置系统以及丰富的软件包和组件资源，让物联网开发变得简单和高效。<a target="_blank" rel="noopener" href="https://www.rt-thread.org/page/studio.html">官网链接</a></li>
</ul>
<h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul>
<li>RT-Thread 推出的ART-PI STM32H750开发板</li>
<li>FATFS格式的任意大小SD卡一张，其他如NTFS格式的SD卡不适用于下文的配置，可通过SD卡格式化解决</li>
</ul>
<h1 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h1><h2 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h2><p>基于开发板建立模板工程<br><img src="https://img-blog.csdnimg.cn/20210209101359636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="打开SD-Card-和-NOR-FLASH-的fliesystem"><a href="#打开SD-Card-和-NOR-FLASH-的fliesystem" class="headerlink" title="打开SD Card 和 NOR FLASH 的fliesystem"></a>打开SD Card 和 NOR FLASH 的fliesystem</h2><p><img src="https://img-blog.csdnimg.cn/20210209101951185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="配置虚拟文件系统"><a href="#配置虚拟文件系统" class="headerlink" title="配置虚拟文件系统"></a>配置虚拟文件系统</h2><p>注意设置要处理的最大扇区大小，根据官方文档改成512.<br><img src="https://img-blog.csdnimg.cn/20210209103845483.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210209102423447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">看下面一张图可以发现，<strong>fal这个flash抽象层的软件包也被打开了，FAL实际上就是下图SPI FLASH的块设备抽象层，</strong>通过终端打印出来的信息可以知道，FAL有五个分区，其中最后一个分区filesystem通过littlefs挂载在文件系统里，而SD卡通过elm-FATFS挂载在文件系统里，他的块设备抽象层用的是FATFS里自带的抽象层，<strong>littlefs在图中没有，但其实littlefs是和FATFS同级的</strong><br><img src="https://img-blog.csdnimg.cn/20210209103606403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/825f5eb27eb041439fe4e714b8709c32.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="打开LittleFs软件包"><a href="#打开LittleFs软件包" class="headerlink" title="打开LittleFs软件包"></a>打开LittleFs软件包</h2><p><img src="https://img-blog.csdnimg.cn/20210209102532942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="打开MTD-NOR-FLASH设备驱动程序"><a href="#打开MTD-NOR-FLASH设备驱动程序" class="headerlink" title="打开MTD NOR FLASH设备驱动程序"></a>打开MTD NOR FLASH设备驱动程序</h2><p>该设备驱动程序默认会被打开<br><img src="https://img-blog.csdnimg.cn/20210209102641311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="查看文件系统初始化代码"><a href="#查看文件系统初始化代码" class="headerlink" title="查看文件系统初始化代码"></a>查看文件系统初始化代码</h2><p>在filesystem.c文件中，IDE已经帮我们编写好文件系统初始化和挂载代码，SD卡挂载到FATFS上，NOR FLASH挂载到LittleFS上，十分方便。<br><img src="https://img-blog.csdnimg.cn/2021020910324283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="编译下载"><a href="#编译下载" class="headerlink" title="编译下载"></a>编译下载</h2><p>通过终端查看，可以看到文件系统已经挂载成功。<br><img src="https://img-blog.csdnimg.cn/20210209103606403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/09/RT-Thread%20ART-PI%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8%E5%92%8Cwebsocket%E8%BD%AF%E4%BB%B6%E5%8C%85%E8%8E%B7%E5%8F%96%E5%BF%83%E7%9F%A5%E5%A4%A9%E6%B0%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fran Hawk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张竞豪的小岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/09/RT-Thread%20ART-PI%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8%E5%92%8Cwebsocket%E8%BD%AF%E4%BB%B6%E5%8C%85%E8%8E%B7%E5%8F%96%E5%BF%83%E7%9F%A5%E5%A4%A9%E6%B0%94/" class="post-title-link" itemprop="url">RT-Thread ART-PI 学习笔记：网络功能使用和websocket软件包获取心知天气</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2021-02-09 19:50:43" itemprop="dateCreated datePublished" datetime="2021-02-09T19:50:43+08:00">2021-02-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2021-08-13 10:01:01" itemprop="dateModified" datetime="2021-08-13T10:01:01+08:00">2021-08-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ART-PI自带的AP6212 WIFI模块，在RT-Thread Studio中来配置网络功能非常方便。本文主要配置ART-PI的网络功能，并且使能websocket软件包获取心知天气的数据。</p>
<p>ART-PI的网络功能是基于RT-Thread的WLAN设备框架，详细内容可参考以下链接：</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/programming-manual/device/wlan/wlan/">RT-Thread WLAN文档</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_31039061/article/details/109763903">参考博客1</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_31039061/article/details/104200110">参考博客2</a></li>
<li><a target="_blank" rel="noopener" href="https://club.rt-thread.org/ask/article/2429.html">参考博客3</a>（重要）</li>
</ul>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul>
<li>RT-Thread Studio：一站式的 RT-Thread 开发工具，通过简单易用的图形化配置系统以及丰富的软件包和组件资源，让物联网开发变得简单和高效。<a target="_blank" rel="noopener" href="https://www.rt-thread.org/page/studio.html">官网链接</a></li>
</ul>
<h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul>
<li>RT-Thread 推出的ART-PI STM32H750开发板</li>
</ul>
<h1 id="添加网络功能"><a href="#添加网络功能" class="headerlink" title="添加网络功能"></a>添加网络功能</h1><p>直接在自己的工程中使能AP6212库即可，编译下载后使用WLAN设备驱动的命令即可观察到现象。<br><img src="https://img-blog.csdnimg.cn/20210209110957714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210209111020980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<h2 id="通过官方提供的例程直接使能网络功能"><a href="#通过官方提供的例程直接使能网络功能" class="headerlink" title="通过官方提供的例程直接使能网络功能"></a>通过官方提供的例程直接使能网络功能</h2><p>官方的示例工程不仅完成了网络功能，还通过配置easyflash实现了wifi自动重连功能，值得借鉴，自动重连功能的实现流程见参考博客3.<br><img src="https://img-blog.csdnimg.cn/20210209111713621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<h2 id="编译下载观察现象"><a href="#编译下载观察现象" class="headerlink" title="编译下载观察现象"></a>编译下载观察现象</h2><p><img src="https://img-blog.csdnimg.cn/20210209112335109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>由于有自动重连功能，我烧写进板子后，自动搜索easyflash区域是否有相应数据，如果有，就用这个数据重连WiFi。</p>
<h1 id="配置RTC和NTP软件包"><a href="#配置RTC和NTP软件包" class="headerlink" title="配置RTC和NTP软件包"></a>配置RTC和NTP软件包</h1><p><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/programming-manual/device/rtc/rtc/">RTC设备驱动文档</a></p>
<p>因为webclient软件包中若开启支持HTTPS加密的网络协议，就必须使板子上的时间和网络时间同步，否则无法使用HTTPS获取网络上的数据。需要配置软件模拟RTC，并且使能netutils软件包中的ntp协议，使RTC自动同步网络时间。</p>
<p>使能软件模拟RTC<br><img src="https://img-blog.csdnimg.cn/20210209113546370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>使能netutils软件包，并且使能ntp协议<br><img src="https://img-blog.csdnimg.cn/20210209113652622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>这时候会发现RTC设备已经自动配置了自动同步网络时间的功能。<br><img src="https://img-blog.csdnimg.cn/20210209113738477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>编译下载观察现象，会发现网络时间同步成功<br><img src="https://img-blog.csdnimg.cn/20210209113931291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<h1 id="配置webclient软件包"><a href="#配置webclient软件包" class="headerlink" title="配置webclient软件包"></a>配置webclient软件包</h1><p>TLS模式中选择MbedTLS，并且使能获取发布示例<br><img src="https://img-blog.csdnimg.cn/202102091143247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<p><img src="https://img-blog.csdnimg.cn/20210209114225826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>保存配置并编译</p>
<h1 id="心知天气配置"><a href="#心知天气配置" class="headerlink" title="心知天气配置"></a>心知天气配置</h1><p><a target="_blank" rel="noopener" href="https://www.seniverse.com/">https://www.seniverse.com/</a> 心知天气网址<br>注册并购买一个免费版的就可以了，在控制台上可以看到这样的信息<br><img src="https://img-blog.csdnimg.cn/20210209114850280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<p>找到文档中逐日天气预报和昨日天气<br><img src="https://img-blog.csdnimg.cn/20210209115025778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>点击链接就可以看到效果。location改成ip，就可以看到当地的天气。<br><img src="https://img-blog.csdnimg.cn/2021020911553521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>复制这个链接，在开发板上实验即可观察到现象</p>
<h1 id="获取天气实验"><a href="#获取天气实验" class="headerlink" title="获取天气实验"></a>获取天气实验</h1><p>因为链接比较长，需要把finsh长度设置的长一点。串口助手的长度也要相应设长。<br><img src="https://img-blog.csdnimg.cn/20210209115647329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<p>编译烧写，并将刚才的网址输入终端，即可看到现象，https还有点问题，但是已经不影响使用了。<br><img src="https://img-blog.csdnimg.cn/20210209121156574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>改成http就没问题了<br><img src="https://img-blog.csdnimg.cn/20210209121433933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<p>返回的数据是json格式的，使用cjson软件包就可以解析数据了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/26/%E7%89%A9%E8%81%94%E7%BD%91%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%20%EF%BC%88%E4%B8%83%EF%BC%89%20%E5%9F%BA%E4%BA%8ERT-thread%E7%9A%84MQTT%E5%8D%8F%E8%AE%AE%E7%89%A9%E8%81%94%E7%BD%91%E8%BE%89%E5%85%89%E9%92%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fran Hawk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张竞豪的小岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/26/%E7%89%A9%E8%81%94%E7%BD%91%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%20%EF%BC%88%E4%B8%83%EF%BC%89%20%E5%9F%BA%E4%BA%8ERT-thread%E7%9A%84MQTT%E5%8D%8F%E8%AE%AE%E7%89%A9%E8%81%94%E7%BD%91%E8%BE%89%E5%85%89%E9%92%9F/" class="post-title-link" itemprop="url">物联网项目设计 （七） 基于RT-thread的MQTT协议物联网辉光钟</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2020-11-26 19:50:43" itemprop="dateCreated datePublished" datetime="2020-11-26T19:50:43+08:00">2020-11-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2021-08-13 10:01:01" itemprop="dateModified" datetime="2021-08-13T10:01:01+08:00">2021-08-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这是物联网项目设计的完结篇，本来想今年上半年完成的，但是中间因为一些事情比较忙，耽误了。后来整个项目设计推倒重来，采用了新的技术栈。但是前面的开发经历也为我提供了不少经验，后面我采用rtthread物联网操作系统，极大的加快了开发进度，同时采用在线电路设计软件立创EDA，让我一个从来没画过电路图的人很快掌握了原理图和PCB的绘制，强推一波。辉光钟的制作网上有很多资料，我也参考了网上的很多资料，但是把辉光钟和物联网结合到一起我觉得是个不错的创意，于是就去做了。<br>下面我先给出本项目的代码和电路图，希望大家喜欢的话给我的github仓库一些小星星~</p>
<p>####演示视频</p>
<p><a href="%5Bhttps://www.bilibili.com/video/BV1ir4y1c7zz%5D(https://www.bilibili.com/video/BV1ir4y1c7zz">视频</a></p>
<h4 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h4><p><a target="_blank" rel="noopener" href="https://github.com/FranHawk/nixie_clock_rt_thread.git">https://github.com/FranHawk/nixie_clock_rt_thread.git</a></p>
<h4 id="电路工程文件"><a href="#电路工程文件" class="headerlink" title="电路工程文件"></a>电路工程文件</h4><p>因为我用了两个板子拼到一起，所以有两个工程文件，打开网址就可以找到原理图和pcb<br><a target="_blank" rel="noopener" href="https://lceda.cn/FranHawk/nixie_testboard">https://lceda.cn/FranHawk/nixie_testboard</a><br><a target="_blank" rel="noopener" href="https://lceda.cn/FranHawk/nixie_mainboard">https://lceda.cn/FranHawk/nixie_mainboard</a></p>
<h1 id="一、项目创意"><a href="#一、项目创意" class="headerlink" title="一、项目创意"></a>一、项目创意</h1><p>辉光管属于电真空器件，也就是电子管，玻璃外壳，通常为圆柱形，金属电极从底部引出管身外，内部有一个阳极电极，若干个阴极电极。辉光管内部并不是真空，充满着由氖气、氩气以及水银蒸汽等组成的混合气体，主要成分是惰性气体氖气。</p>
<p>辉光管属于多年前的古老工艺，本是被时代淘汰的产物，但是由于辉光管发出的橙黄色光芒十分美观，且对驱动电路的要求非常高，所以受到广大爱好者的喜爱。而物联网技术的发展势头正劲，将古老的辉光管和新兴的物联网技术相结合，制作出的物联网辉光管时钟，将使辉光管焕发出新的活力。同时也体现出一定的技术性，创意性和装饰性。<br>     <img src="https://img-blog.csdnimg.cn/20201126221249441.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="二、项目需求"><a href="#二、项目需求" class="headerlink" title="二、项目需求"></a>二、项目需求</h1><p>1.完成辉光管显示功能，四个IN12辉光管显示小时分钟或者分钟秒<br>2.辉光管发光稳定，走时精确，掉电时时钟保持走时<br>3.自动连接wifi远程控制功能，完成网页访问物联网平台控制辉光钟显示<br>4.自动校时功能，联网自动校准辉光钟时间<br>5.系统可保持长时间运行，不发生崩溃</p>
<h1 id="三、框图及整机概述"><a href="#三、框图及整机概述" class="headerlink" title="三、框图及整机概述"></a>三、框图及整机概述</h1><p> <img src="https://img-blog.csdnimg.cn/20201126215207209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>本项目分为硬件设备端完成主要功能和云服务器端完成人机交互和控制功能。</p>
<h2 id="硬件设备端"><a href="#硬件设备端" class="headerlink" title="硬件设备端"></a>硬件设备端</h2><h3 id="1-STM32F103RCT6"><a href="#1-STM32F103RCT6" class="headerlink" title="1.STM32F103RCT6"></a>1.STM32F103RCT6</h3><p>使用stm32f103rct6作为主控芯片，48kB RAM，256kB ROM搭载RT-thread物联网实时操作系统.完成对各模块的通讯控制和多任务管理。</p>
<h3 id="2-ESP8266-WIFI模块"><a href="#2-ESP8266-WIFI模块" class="headerlink" title="2.ESP8266 WIFI模块"></a>2.ESP8266 WIFI模块</h3><p>使用ESP8266模块完成硬件设备的物联网功能，ESP8266在数据链路层使用WIFI协议，适用于家庭室内这种不需要经常移动的场合。ESP8266已完整封装TCP/IP协议，只需要通过AT指令连接WIFI网络，然后进入透传模式，主控MCU发送过来的MQTT消息包就会经ESP8266发送至互联网，完成设备之间的解耦。同时通过ESP8266访问NTP服务器完成时钟的校时功能，ESP8266模块通过串口与主控MCU完成通讯。</p>
<h3 id="3-DS3231-实时时钟芯片"><a href="#3-DS3231-实时时钟芯片" class="headerlink" title="3.DS3231 实时时钟芯片"></a>3.DS3231 实时时钟芯片</h3><p>使用DS3231高精度实时时钟芯片完成自动走时功能。DS3231是一款高精度I2C实时时钟器件，具有集成的温度补偿晶体振荡器。该器件包含电池输入端，断开主电源时仍可保持精确计时。集成的晶体振荡器可提高器件的长期精确度。DS3231的寄存器能保存秒、分、时、星期、日期、月、年和闹钟设置等信息。少于31天的月份，可自动调整月末日期，包括闰年补偿。时钟的工作格式为24小时或带AM／PM指示的12小时格式。DS3231提供两个可编程日历闹钟和一路可编程方波输出。DS3231与单片机通过I2C双向串行总线传输地址与数据。通过使用DS3231芯片完成自动走时功能，并通过电池提供备用电力的方式，实现调电保持计时功能。</p>
<h3 id="4-HV57708-高压驱动芯片"><a href="#4-HV57708-高压驱动芯片" class="headerlink" title="4.HV57708 高压驱动芯片"></a>4.HV57708 高压驱动芯片</h3><p> 使用HV57708高压驱动芯片为辉光钟提供驱动信号。HV57708是一款可以承受高电压的串行输入转并行输出的驱动芯片，可完成4路输入转64路输出的功能，适用于驱动辉光管，大大节省了单片机的IO口，同时芯片高度集成，节省了PCB的面积。</p>
<h3 id="5-MAX1771升压电路"><a href="#5-MAX1771升压电路" class="headerlink" title="5.MAX1771升压电路"></a>5.MAX1771升压电路</h3><p>使用以MAX1771为控制核心的BOOST升压电路，将直流12V输入高效率地转化为170V输出，将辉光管点亮。<br>    整个系统电路部分使用立创EDA完成PCB的绘制，为了使设备整体美观紧凑，将元器件布置在两块PCB上，一块PCB放置主要控制和电源电路，另一块PCB放置辉光管插座。</p>
<h2 id="云服务器端"><a href="#云服务器端" class="headerlink" title="云服务器端"></a>云服务器端</h2><p>云端服务全部使用阿里云平台的服务，阿里云的服务具有稳定性强，配置便捷的特点，方便部署物联网应用，云端总体应用架构如下<br> <img src="https://img-blog.csdnimg.cn/20201126215239514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="1．阿里云物联网平台"><a href="#1．阿里云物联网平台" class="headerlink" title="1．阿里云物联网平台"></a>1．阿里云物联网平台</h3><p>云端物联网平台使用阿里云物联网平台。阿里云物联网平台为设备提供安全可靠的连接通信能力，向下连接海量设备，支撑设备数据采集上云；向上提供云端API，服务端通过调用云端API将指令下发至设备端，实现远程控制。提供设备接入，设备管理，安全能力和规则引擎。其中规则引擎用来完成数据转发，负责沟通数据在设备间，设备与数据库间，设备与服务器间流转。</p>
<h3 id="2-阿里云-云端服务器"><a href="#2-阿里云-云端服务器" class="headerlink" title="2.阿里云 云端服务器"></a>2.阿里云 云端服务器</h3><p>Web服务器使用阿里云服务器ECS，云服务器（Elastic Compute Service，简称ECS）是阿里云提供的性能卓越、稳定可靠、弹性扩展的IaaS（Infrastructure as a Service）级别云计算服务。云服务器ECS免去了您采购IT硬件的前期准备，让您像使用水、电、天然气等公共资源一样便捷、高效地使用服务器，实现计算资源的即开即用和弹性伸缩。阿里云ECS持续提供创新型服务器，解决多种业务需求，助力业务发展。</p>
<h1 id="四、各模块电路设计及原理"><a href="#四、各模块电路设计及原理" class="headerlink" title="四、各模块电路设计及原理"></a>四、各模块电路设计及原理</h1><h2 id="4-1-主控模块"><a href="#4-1-主控模块" class="headerlink" title="4.1 主控模块"></a>4.1 主控模块</h2><p>意法半导体的STM32F1系列产品作为基于ARM Cortex M3的32位微控制器，满足了工业、医疗和消费类市场的各种应用需求。使用C语言为编程语言，配合RT-thread操作系统，可以很好的满足需求。STM32F103RCT6 有32K RAM 256K ROM，满足操作系统和响应外设的运行需求。将STM32F103RCT6最小系统直接设计在整体电路板上，提高了整体的紧凑性和集成度。具体电路如下：<br> <img src="https://img-blog.csdnimg.cn/20201126215307573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>其中使用UART1串行总线和电脑上位机连接完成和电脑的通讯，方便观察运行状况和调试。原本准备在电路板上使用USB转串口芯片，但是考虑到运行时并不使用该模块，且占用电路板面积，最后使用排针引出加到转串口模块的方式，大大减少了PCB面积和工作量。<br>使用外部8M晶振提高程序运行时的时间准确性。</p>
<p>设计完成的pcb板如下：<br> <img src="https://img-blog.csdnimg.cn/20201126215323484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>实物如下：<br> <img src="https://img-blog.csdnimg.cn/20201126215332134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="4-2-实时时钟模块"><a href="#4-2-实时时钟模块" class="headerlink" title="4.2 实时时钟模块"></a>4.2 实时时钟模块</h2><p>使用DS3231MZ 作为实时时钟模块的主要芯片。DS3231是一款高精度I2C实时时钟器件，具有集成的温度补偿晶体振荡器。该器件包含电池输入端，断开主电源时仍可保持精确计时。集成的晶体振荡器可提高器件的长期精确度。芯片封装使用SOP-8封装，且几乎不需要外部器件支持，使用IIC协议和主控STM32f103芯片沟通。<br>    为了达到主要电路调电依旧可以完成走时的功能，使用3.7V CR1220 纽扣电池和电池座为DS3231MZ芯片提供备用电源，使芯片在外部供电中断时依旧可以走时。<br>设计完成的原理图和pcb板如下：<br>   <img src="https://img-blog.csdnimg.cn/20201126215354289.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201126215402894.png#pic_center" alt="在这里插入图片描述"></p>
<p>实物图如下：<br> <img src="https://img-blog.csdnimg.cn/20201126215412351.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="4-3-ATK-ESP8266-WIFI模块"><a href="#4-3-ATK-ESP8266-WIFI模块" class="headerlink" title="4.3 ATK-ESP8266 WIFI模块"></a>4.3 ATK-ESP8266 WIFI模块</h2><p>ATK-ESP8266 是正点原子团队推出的一款高性能的 UART-WiFi（串口-无线）模块，ATK-ESP8266 板载了正点原子团队自主开发的 ATK-ESP-01 模块。<br>ATK-ESP8266 模块采用串口（LVTTL）与 MCU（或其他串口设备）通信，内置TCP/IP 协议栈，能够实现串口与 WIFI 之间的转换。通过 ATK-ESP8266 模块，传统的串口设备只是需要简单的串口配置，即可通过网络（WIFI）传输自己的数据。<br>主板将STM32的UART3总线引出到排母，使用排母和ESP8266模块连接，减少了电路设计工作量和成本。<br>实物如下：<br> <img src="https://img-blog.csdnimg.cn/20201126215424535.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="4-4-HV57708-辉光管串转并高压驱动芯片"><a href="#4-4-HV57708-辉光管串转并高压驱动芯片" class="headerlink" title="4.4 HV57708 辉光管串转并高压驱动芯片"></a>4.4 HV57708 辉光管串转并高压驱动芯片</h2><p>使用HV57708高压驱动芯片为辉光钟提供驱动信号。HV57708是一款可以承受高电压的串行输入转并行输出的驱动芯片，可完成4路输入转64路输出的功能，适用于驱动辉光管，大大节省了单片机的IO口，同时芯片高度集成，节省了PCB的面积。<br>    STM32使用7个GPIO和HV57708进行通讯。通过HV57708内部逻辑最终可以输出64路输出，足够为4位辉光管40个引脚提供驱动。HV57708的引脚接在辉光管的阴极,辉光管的阳极接170V。芯片必须工作在反向模式。信号为低电平时，引脚输出为高电平(68V)，此为VPP接入的电压值，这个电压值通过170V接电阻和稳压二极管得到68V电压，这样阴极阳极间无法产生170V压差而熄灭。当引脚输出低电平0V时，辉光管有压差170V，辉光管点亮。<br> <img src="https://img-blog.csdnimg.cn/20201126215445809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="4-5-辉光管"><a href="#4-5-辉光管" class="headerlink" title="4.5 辉光管"></a>4.5 辉光管</h2><p>辉光管时钟采用IN12侧显式辉光管，辉光管是发明于1950年代中期，人们期望发明一种非点阵而是线状化地显示数字的方式。辉光管随之诞生，辉光管属于电子管的一种, 发光原理和霓虹灯差不多。通常在一个真空管里，放置一个金属丝网制成的阳极和10个阴极，形状为数字0到9，某些还有一个或两个小数点。在管内充入惰性气体氖气和汞或氩，再通上高压后，每一个阴极可以发出红橙色光。<br>    IN12辉光管生产于上世纪80年代，使用170V高压即可点亮。设计小巧，亮度适中，造型美观，价格合适，于是选用四位IN12辉光管作为显示部分。</p>
<p><img src="https://img-blog.csdnimg.cn/2020112621553459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="4-4-电源模块"><a href="#4-4-电源模块" class="headerlink" title="4.4 电源模块"></a>4.4 电源模块</h2><h3 id="4-4-1-AMS1117-3-3稳压模块"><a href="#4-4-1-AMS1117-3-3稳压模块" class="headerlink" title="4.4.1 AMS1117-3.3稳压模块"></a>4.4.1 AMS1117-3.3稳压模块</h3><p>AMS1117-3.3为一块电压降压型直流线性稳压芯片，最大输出电流可达1A.，输出电压为3.3V。外部电路仅需要电容用来保证输出电压的稳定性，并添加LED灯用于指示稳压芯片是否工作正常。该稳压模块主要输出3.3V电压，给STM32F103，DS3231，ESP8266供电。<br> <img src="https://img-blog.csdnimg.cn/20201126215542955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="4-4-2-AMS1117-5-0稳压模块"><a href="#4-4-2-AMS1117-5-0稳压模块" class="headerlink" title="4.4.2 AMS1117-5.0稳压模块"></a>4.4.2 AMS1117-5.0稳压模块</h3><p>AMS1117-5.0为一块电压降压型直流线性稳压芯片，最大输出电流可达1A.，输出电压为5.0V。外部电路仅需要电容用来保证输出电压的稳定性，并添加LED灯用于指示稳压芯片是否工作正常。该稳压模块主要输出5.0V电压，给HV57708高压驱动芯片的逻辑部分供电。<br>电路设计如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20201126215553539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="4-4-3-MAX1771-12V升170V-boost升压电路模块"><a href="#4-4-3-MAX1771-12V升170V-boost升压电路模块" class="headerlink" title="4.4.3 MAX1771 12V升170V boost升压电路模块"></a>4.4.3 MAX1771 12V升170V boost升压电路模块</h3><p>设计要求：Vin=12V，Vout=170V</p>
<ol>
<li>   MOS管的选择<br>由于输出电压较高，所以需要耐压值较高的MOSFET，选择耐压值250V以上MOS，其内阻越低越好。考虑到成本和体积限制，我选用的是TK8P65W。</li>
<li>反馈电阻的选择<br>芯片的参考电压为1.5V，两个电阻对输出电压进行分压之后送入FB引脚进行反馈显然，其中电阻的选择公式如下。<br><img src="https://img-blog.csdnimg.cn/20201126215601124.png#pic_center" alt="在这里插入图片描述"></li>
</ol>
<p>这里我们选择R2=1.8MΩ，R1=16KΩ。</p>
<ol start="3">
<li>   电流控制电阻的选择<br>Rsense为电流控制电阻，控制着MOS管的最大电流，可以防止意外情况发生，诸如输出短路引起MOS烧毁。这里要根据我们的需求进行选择。假设我们要求输出20mA的最大电流，效率80%情况下， 可计算得到最大的Ids=354mA，此时由于比较电压为0.1V，可计算得到Rsense的最小值为0.1V/354mA=282mΩ。但是往往我们不这样做，因为这样计算出来的Rsense非常大，会严重影响效率。对于这里，我们不需要对输出电流进行太大限制，所以我们适当选择一个防止输出短路引起MOS发烫烧毁就好，我设计时选择的限流电阻为50mΩ。</li>
<li>   功率电感的选择<br>根据数据手册中的公式可以得到，选择最佳功率电感范围是10uH~300uH。我选取220uH作为电路中功率电感。</li>
<li>输入输出电容选择<br>为了保持电路输入输出端电压保持稳定，需要选取合适的电容稳定电压，这里选取220UF作为输入端电容，10UF作为输出端电容。<h2 id="4-5-其他I-O模块"><a href="#4-5-其他I-O模块" class="headerlink" title="4.5 其他I/O模块"></a>4.5 其他I/O模块</h2>LED指示灯：用于指示程序是否正常运行<h2 id="4-6-PCB的绘制，焊接与装配"><a href="#4-6-PCB的绘制，焊接与装配" class="headerlink" title="4.6 PCB的绘制，焊接与装配"></a>4.6 PCB的绘制，焊接与装配</h2>PCB的绘制<br> 为了保证设备整体美观大方，将控制部分和辉光管显示部分分成两个pcb板，中间使用排针排母连接。<br> 控制部分PCB板设计时分为电源部分和控制部分，并分成模拟地和数字地中间用0欧电阻用于隔离。控制部分将SWD烧写线和UART串口通讯用排针引出放于电路板边缘，美观且便于调试。<br> 显示部分使用插针的形式而不是直接将辉光管焊在板子上，保证辉光管可以重复利用。<br> 控制部分和显示部分在相同位置都有M3孔，便于使用铜柱相互连接，便于装配。</li>
</ol>
<p>控制板顶层和底层<br> <img src="https://img-blog.csdnimg.cn/2020112621561983.png#pic_center" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/20201126215625598.png#pic_center" alt="在这里插入图片描述"></p>
<p>显示板顶层和底层</p>
<p><img src="https://img-blog.csdnimg.cn/20201126215634361.png#pic_center" alt="在这里插入图片描述"></p>
<p>PCB的焊接和装配<br>    PCB的焊接遵循先电源后控制，由外而内，边焊接边测试的思路，先从电源模块开始焊接，测试电源模块工作情况，再焊接控制部分。电源部分焊接完毕后如图，开关稳压输出保持在170V附近，证明电源部分焊接完毕。<br>   <img src="https://img-blog.csdnimg.cn/20201126215647225.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201126215651699.png#pic_center" alt="在这里插入图片描述"></p>
<p>电源部分焊接与测试<br>    电源部分焊接完毕后焊接控制部分。控制部分主要芯片为stm32最小系统电路，实时时钟电路和WIFI模块电路。Stm32焊接完毕后烧写测试程序，控制点亮小灯隔1s闪烁一次，证明焊接成功，实时时钟芯片和无线模块焊接完成后分别使用IIC和UART总线使之和STM32完成通讯，证明焊接成功。<br>    下一步焊接辉光管驱动芯片模块和显示部分PCB板，焊接完毕后使用同铜柱将两个板子连接到一起，烧写测试程序并使用电压表测试各管脚电压是否正常，检查完毕后将辉光管插上，成功点亮辉光管。<br>  <img src="https://img-blog.csdnimg.cn/20201126215701635.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201126215706212.png#pic_center" alt="在这里插入图片描述"></p>
<p>控制板和显示板焊接成品图<br>  <img src="https://img-blog.csdnimg.cn/20201126215724367.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201126215728852.png#pic_center" alt="在这里插入图片描述"></p>
<p>控制板和显示板装配测试图</p>
<h1 id="五、程序部分编写与调试"><a href="#五、程序部分编写与调试" class="headerlink" title="五、程序部分编写与调试"></a>五、程序部分编写与调试</h1><h2 id="5-1-RT-Thread物联网操作系统"><a href="#5-1-RT-Thread物联网操作系统" class="headerlink" title="5.1 RT-Thread物联网操作系统"></a>5.1 RT-Thread物联网操作系统</h2><p>辉光钟对时间的要求非常严格。若采用普通的前后台系统，只依靠定时器中断很难做到各模块协调工作，很容易出现逻辑上的漏洞。采用嵌入式实时操作系统可以做到对逻辑和时序的精确控制，可以使各任务执行无误而且准时。<br>本系统采用RT-Thread嵌入式物联网实时操作系统。RT-Thread，全称是 Real Time-Thread，顾名思义，它是一个嵌入式实时多线程操作系统，基本属性之一是支持多任务，允许多个任务同时运行并不意味着处理器在同一时刻真地执行了多个任务。事实上，一个处理器核心在某一时刻只能运行一个任务，由于每次对一个任务的执行时间很短、任务与任务之间通过任务调度器进行非常快速地切换（调度器根据优先级决定此刻该执行的任务），给人造成多个任务在一个时刻同时运行的错觉。在 RT-Thread 系统中，任务通过线程实现的，RT-Thread 中的线程调度器也就是以上提到的任务调度器。对于资源丰富的物联网设备，RT-Thread 又能使用在线的软件包管理工具，配合系统配置工具实现直观快速的模块化裁剪，无缝地导入丰富的软件功能包，实现类似 Android 的图形界面及触摸滑动效果、智能语音交互效果等复杂功能。<br>相较于 Linux 操作系统，RT-Thread 体积小，成本低，功耗低、启动快速，除此以外 RT-Thread 还具有实时性高、占用资源小等特点，非常适用于各种资源受限（如成本、功耗限制等）的场合。<br>近年来，物联网（Internet Of Things，IoT）概念广为普及，物联网市场发展迅猛，嵌入式设备的联网已是大势所趋。终端联网使得软件复杂性大幅增加，传统的 RTOS 内核已经越来越难满足市场的需求，在这种情况下，物联网操作系统（IoT OS）的概念应运而生。物联网操作系统是指以操作系统内核（可以是 RTOS、Linux 等）为基础，包括如文件系统、图形库等较为完整的中间件组件，具备低功耗、安全、通信协议支持和云端连接能力的软件平台，RT-Thread 就是一个 IoT OS。<br>RT-Thread 与其他很多 RTOS 如 FreeRTOS、uC/OS 的主要区别之一是，它不仅仅是一个实时内核，还具备丰富的中间层组件，如下图所示。<br> <img src="https://img-blog.csdnimg.cn/20201126215741677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="RT-Thread操作系统的架构"><a href="#RT-Thread操作系统的架构" class="headerlink" title="RT-Thread操作系统的架构"></a>RT-Thread操作系统的架构</h3><p>物联网辉光钟的任务虽然不多，但是使用的模块很多，且都遵循自己的协议，为了方便管理和软件开发，主要使用物联网操作系统提供的中间件驱动的功能，可以为驱动开发节省很多时间。</p>
<h3 id="RT-Thread操作系统的使用"><a href="#RT-Thread操作系统的使用" class="headerlink" title="RT-Thread操作系统的使用"></a>RT-Thread操作系统的使用</h3><p>我使用RT-Thread官方提供的IDE RT-Thread Studio一站式配置软件包，并且可以进行调试和烧写。</p>
<p><img src="https://img-blog.csdnimg.cn/20210130192555996.png" alt="在这里插入图片描述"></p>
<p>使用软件包情况：</p>
<p>1.cjson，pahomptt：用于物联网相关的相关操作。cjson<br>用于解析json格式mqtt数据包。</p>
<p>2.netutils：一些网络相关小工具，使用其中的ntp协议用于开机联网校准时间。</p>
<p>3.ds3231，at_device:分别用于驱动ds3231实时时钟芯片和esp8266模块。</p>
<h2 id="5-2-硬件设备端软件架构设计"><a href="#5-2-硬件设备端软件架构设计" class="headerlink" title="5.2    硬件设备端软件架构设计"></a>5.2    硬件设备端软件架构设计</h2><p>程序首先执行各外设初始化，首先初始化的是HV57708，因为HV57708控制辉光管且电压为170V，操作不当就会导致同一根管子多个数字同时点亮电流过大烧坏电源。之后初始化DS3231，ESP8266.然后使用ESP8266连接网络，在线更新时间并使用IIC协议存入DS3231中，之后使用MQTT协议登录阿里云物联网平台，订阅控制话题，并开启显示线程。显示线程以200ms为一个周期，先通过DS3231获取当前时间，再通过云端传来的控制信号决定当前显示的是小时分钟模式或者是分钟秒模式。同时加入了阴极保护功能，每隔一段时间就让辉光管所有数字按顺序显示一遍，提高辉光管的寿命。<br> <img src="https://img-blog.csdnimg.cn/20201126215912922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>软件流程图</p>
<h3 id="5-2-1-NTP协议"><a href="#5-2-1-NTP协议" class="headerlink" title="5.2.1     NTP协议"></a>5.2.1     NTP协议</h3><p>NTP(Network Time Protocol）网络时间协议基于UDP，用于网络时间同步的协议，使网络中的计算机时钟同步到UTC，再配合各个时区的偏移调整就能实现精准同步对时功能。提供NTP对时的服务器有很多，比如微软的NTP对时服务器，利用NTP服务器提供的对时功能，可以使我们的设备时钟系统能够正确运行。<br>本系统通过使用RT-Thread提供的NTP协议中间件，在联网的状态下，通过调用相关函数，很方便的将设备时间和网络时间同步，保证时间的准确性。同时使用高精度时钟芯片DS3231，可保证时钟的精确走时。</p>
<h3 id="5-2-2-MQTT协议"><a href="#5-2-2-MQTT协议" class="headerlink" title="5.2.2 MQTT协议"></a>5.2.2 MQTT协议</h3><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的”轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。<br>MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。<br>实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。<br>在本系统中，物联网辉光钟作为客户端，既作为发布者也作为订阅者，发布当前辉光钟的状态，订阅云端发布的控制信息。信息的载体为JSON格式，所以发送和接收消息后都需要对消息进行一定的加工和利用。</p>
<h3 id="5-2-3-HV57708和ESP8266，DS3231驱动"><a href="#5-2-3-HV57708和ESP8266，DS3231驱动" class="headerlink" title="5.2.3 HV57708和ESP8266，DS3231驱动"></a>5.2.3 HV57708和ESP8266，DS3231驱动</h3><p>ESP8266，DS3231驱动均使用物联网操作系统提供的中间件驱动程序，使用较为简单，这里不再赘述。<br>HV57708使用场景较少，资料较少，于是查阅数据手册，通过研究数据手册中的芯片操作时序。编写调试驱动代码，最终实现了对HV57708的驱动。</p>
<h2 id="5-3-云服务器端软件架构设计"><a href="#5-3-云服务器端软件架构设计" class="headerlink" title="5.3    云服务器端软件架构设计"></a>5.3    云服务器端软件架构设计</h2><p>阿里云物联网平台端<br>     <img src="https://img-blog.csdnimg.cn/20201126215925788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>云端设备的定义<br>连接物联网平台需要先创建设备，根据这个设备的证书信息，和密码。设备可通过一个三元组证书信息连接到云服务器。阿里云物联网服务器作为设备的接收和中转站，管理所有通过MQTT协议发送和接收的信息。将Web服务器和硬件设备定义成两个设备，通过设置规则引擎，完成数据的接收和转发。<br>通过设计规则引擎，将WEB服务器和辉光钟之间的消息进行转发，实际上将阿里云物联网平台看做一个消息中转站的作用。<br>  <img src="https://img-blog.csdnimg.cn/20201126215957372.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201126220003604.png#pic_center" alt="在这里插入图片描述"></p>
<p>规则引擎设计<br>阿里云服务器端<br>技术架构<br>原生Linux系统加宝塔面板，对小白用户友好<br>使用node.js框架作为网站后端<br>使用node.js软件包中的node-red数据流处理工具<br>具体步骤<br>    使用node-red，node-red是一种图形化的后端处理工具，适用于物联网服务等小型服务端应用搭建，不需要写代码，部署比较快捷。<br>使用node-red主要完成以下几个功能</p>
<p>1.作为MQTT协议中的客户端，连接阿里云物联网平台，订阅相关话题，接收上传的JSON格式MQTT报文</p>
<p>2.对JSON格式的报文进行处理</p>
<p>3.下发控制信息到物联网辉光钟端</p>
<p>下图为在node-red上完成的配置，没有写一点代码，点击部署后完成部署，便可以在网页上看到<br><img src="https://img-blog.csdnimg.cn/20210130192729904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>打开硬件设备，待其连接到阿里云物联网平台，然后进入以下网址<br><a target="_blank" rel="noopener" href="http://39.99.247.63:1880/ui/">http://39.99.247.63:1880/ui/</a><br>就可以完成对辉光钟的显示模式的控制，并且可以设置闹钟，因为没有在硬件上设计蜂鸣器，于是想到了让网页端发声的解决方案。</p>
<p><img src="https://img-blog.csdnimg.cn/20210130192642206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="六、拓展功能"><a href="#六、拓展功能" class="headerlink" title="六、拓展功能"></a>六、拓展功能</h1><p>增加时钟功能，增加闹钟和倒计时和正计时的功能。因为板子上没有画蜂鸣器模块，于是就使用在网页端发声的方式，可以灵活地更改音乐种类。</p>
<h1 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h1><p>本次项目设计初步打通了物联网的整个数据链路，通过该实验，下一步可以完成更加复杂智能的物联网应用，比如实时操控家里的家电，家中电器通过检测环境变化自动开关机。添加微信小程序访问Web服务器，从而监控物联网设备等功能。同时还锻炼了通过查找数据手册完成对芯片的驱动，完成开关稳压的设计，很好的将课堂学习到的知识运用到实际中去。</p>
<p>本次项目从原理图出发，到PCB，到焊接装配和代码的编写。完整熟悉了开发嵌入式设备的全过程，是一次很好的历练，通过一个项目，使得课堂学习到的知识运用到实际，使我收获颇多。</p>
<h1 id="总体开支"><a href="#总体开支" class="headerlink" title="总体开支"></a>总体开支</h1><p>把备用原件的开支也算上了<br><img src="https://img-blog.csdnimg.cn/2020112622142175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/07/%E5%9F%BA%E4%BA%8EMQTT%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%B6%E5%BA%AD%E6%B8%A9%E6%B9%BF%E5%BA%A6%E7%9B%91%E6%B5%8B%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fran Hawk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张竞豪的小岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/07/%E5%9F%BA%E4%BA%8EMQTT%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%B6%E5%BA%AD%E6%B8%A9%E6%B9%BF%E5%BA%A6%E7%9B%91%E6%B5%8B%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">基于MQTT应用层协议的物联网家庭温湿度监测系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2020-05-07 19:50:43" itemprop="dateCreated datePublished" datetime="2020-05-07T19:50:43+08:00">2020-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2021-08-13 10:01:01" itemprop="dateModified" datetime="2021-08-13T10:01:01+08:00">2021-08-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>出生于互联网时代的我们，见证了智能手机和个人电脑通过计算机网络互相进行连接，把每个人紧密地连接在一起，形成了一个地球村。而今，我们即将迈入5G时代，在通信技术不断发展的今天，连接到互联网的将不仅是昂贵精密的手机电脑，身边的各种物体也可以通过物联网连接到云端，由物联网平台管理上云的物联网设备，使用者通过浏览器，小程序等接收物发出的通知并且完成想过操作。物联网不仅将物与物连接在一起，也将物与人紧密地连接在一起，让生活更加智慧便捷。这，就是即将到来的AIOT时代。<br>本次实验主要通过自制一个家庭物联网温湿度检测模块，学习具体的基于MQTT协议的物联网设计制作。在应用的过程中，也加深了对计算机网络各层次之间的理解。<br>硬件设备原代码附于文末。</p>
<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><ul>
<li>硬件设备可以读取温湿度信息</li>
<li>硬件设备可连接互联网上传消息</li>
<li>云端物联网平台24小时不间断工作，完成接入设备的管理，消息存储与转发</li>
<li>web服务器接收物联网平台的信息，经过处理使用户通过网页访问的方式查询信息</li>
</ul>
<h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><h3 id="系统总体数据流"><a href="#系统总体数据流" class="headerlink" title="系统总体数据流"></a>系统总体数据流</h3><ul>
<li>硬件设备stm32作为终端结点，通过MQTT协议将数据上传至物联网平台，同时接受物联网平台下发的信息。</li>
<li>云服务器作为与用户直接联系的平台，既作为http服务端，使用http协议向用户展示温湿度等信息接收用户发送的命令信息，又作为mqtt客户端与物联网平台交换信息。</li>
<li>物联网平台作为消息的中转站，负责物联网设备的管理与消息的转发。</li>
<li>总体计算机网络应用层协议数据流如下图<br><img src="https://img-blog.csdnimg.cn/20200317091316852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_1,color_FFFFFF,t_70"><h3 id="硬件设备端"><a href="#硬件设备端" class="headerlink" title="硬件设备端"></a>硬件设备端</h3><h4 id="各模块设计"><a href="#各模块设计" class="headerlink" title="各模块设计"></a>各模块设计</h4></li>
<li>为实现开发的便捷性和稳定性，使用意法半导体的STM32F103ZET6作为主控MCU，接收各传感器的消息。负责与服务器建立连接，并将消息构造成MQTT报文，上传至云端物联网平台。<br><img src="https://img-blog.csdnimg.cn/20200316225134702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_1,color_FFFFFF,t_70"></li>
<li> 使用DHT11温湿度传感器，可同时检测温湿度，测量范围为0-100，精度为1度，采用单总线与主控芯片完成数据传递，单总线协议不是本文主要内容，概不介绍<br><img src="https://img-blog.csdnimg.cn/20200316225951636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_1,color_FFFFFF,t_70"></li>
<li>使用ESP8266模块完成硬件设备的物联网功能，ESP8266在数据链路层使用WIFI协议，适用于家庭室内这种不需要经常移动的场合。ESP8266已完整封装TCP/IP协议，只需要通过AT指令连接WIFI网络，然后进入透传模式，主控MCU发送过来的MQTT消息包就会经ESP8266发送至互联网，完成设备之间的解耦。ESP8266模块通过串口与主控MCU完成通讯。<br><img src="https://img-blog.csdnimg.cn/20200316230956379.png"></li>
</ul>
<h4 id="硬件设备数据流"><a href="#硬件设备数据流" class="headerlink" title="硬件设备数据流"></a>硬件设备数据流</h4><p><img src="https://img-blog.csdnimg.cn/20200316231550547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_1,color_FFFFFF,t_70"></p>
<h3 id="云端物联网服务平台和Web服务器"><a href="#云端物联网服务平台和Web服务器" class="headerlink" title="云端物联网服务平台和Web服务器"></a>云端物联网服务平台和Web服务器</h3><ul>
<li>云端服务全部使用阿里云平台的服务，阿里云的服务具有稳定性强，配置便捷的特点，方便部署物联网应用，云端总体应用架构如下。<br><img src="https://img-blog.csdnimg.cn/2020031709364994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_1,color_FFFFFF,t_70"></li>
<li>云端物联网平台使用<strong>阿里云物联网平台</strong>。阿里云物联网平台为设备提供安全可靠的连接通信能力，向下连接海量设备，支撑设备数据采集上云；向上提供云端API，服务端通过调用云端API将指令下发至设备端，实现远程控制。提供设备接入，设备管理，安全能力和规则引擎。其中规则引擎用来完成数据转发，负责沟通数据在设备间，设备与数据库间，设备与服务器间流转。</li>
<li>Web服务器使用<strong>阿里云服务器ECS</strong>，云服务器（Elastic Compute Service，简称ECS）是阿里云提供的性能卓越、稳定可靠、弹性扩展的IaaS（Infrastructure as a Service）级别云计算服务。云服务器ECS免去了您采购IT硬件的前期准备，让您像使用水、电、天然气等公共资源一样便捷、高效地使用服务器，实现计算资源的即开即用和弹性伸缩。阿里云ECS持续提供创新型服务器，解决多种业务需求，助力业务发展。</li>
</ul>
<h1 id="MQTT协议"><a href="#MQTT协议" class="headerlink" title="MQTT协议"></a>MQTT协议</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p> MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的”轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。</p>
<p>MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。</p>
<h3 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h3><ul>
<li>工作在低带宽、不可靠的网络的协议，数据精简，节约流量，不添加冗余功能</li>
<li>使用TCP/IP提供网络连接</li>
<li>使用订阅/发布消息模式，可以完成一对多的消息传递，消息并不是通过端到端传递，而是经过代理端转发，比如硬件设备端并不直接将数据发送到服务器，而是硬件设备将数据发送到指定话题，然后服务器订阅该话题，完成数据的传递。使用订阅/发布消息模式，可完成设备之间的解耦，同一个话题可以有多个发布者和多个订阅者。</li>
<li>有三种消息发布服务质量（Qos）用于不同的通讯环境中，分为Qos0，Qos1，和Qos2，分别代表消息至少到达一次，消息重复一次，消息至少重复两次。灵活可变的消息服务质量可以用于不同的场合。</li>
<li>使用遗嘱机制，通知有关各方客户端异常中断的机制，当设备断开连接时，通过遗嘱信息通知各方，以便于后续处理。</li>
</ul>
<h3 id="协议原理"><a href="#协议原理" class="headerlink" title="协议原理"></a>协议原理</h3><p>实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。</p>
<p>MQTT传输的消息分为：主题（Topic）和负载（payload）两部分：</p>
<ul>
<li>Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）</li>
<li> payload，可以理解为消息的内容，是指订阅者具体要使用的内容。</li>
</ul>
<p>在这次实验中，硬件设备和阿里云服务器作为客户端订阅和发布相关话题，阿里云物联网平台作为消息代理服务器</p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>一个使用MQTT协议的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以：</p>
<p>（1）发布其他客户端可能会订阅的信息；<br>（2）订阅其它客户端发布的消息；<br>（3）退订或删除应用程序的消息；<br>（4）断开与服务器连接。</p>
<h4 id="MQTT服务器"><a href="#MQTT服务器" class="headerlink" title="MQTT服务器"></a>MQTT服务器</h4><p>MQTT服务器以称为”消息代理”（Broker），可以是一个应用程序或一台设备。它是位于消息发布者和订阅者之间，它可以：</p>
<p>（1）接受来自客户的网络连接；<br>（2）接受客户发布的应用信息；<br>（3）处理来自客户端的订阅和退订请求；<br>（4）向订阅的客户转发应用程序消息。</p>
<h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><ul>
<li>Connect。等待与服务器建立连接。</li>
<li>Disconnect。等待MQTT客户端完成所做的工作，并与服务器断开TCP/IP会话。</li>
<li>Subscribe。等待完成订阅。</li>
<li>UnSubscribe。等待服务器取消客户端的一个或多个topics订阅。</li>
<li>Publish。MQTT客户端发送消息请求，发送完成后返回应用程序线程。</li>
</ul>
<h3 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h3><p>MQTT报文由三部分组成</p>
<ul>
<li><strong>固定报头</strong></li>
<li><strong>可变报头</strong></li>
<li><strong>有效载荷</strong></li>
</ul>
<h4 id="固定报头"><a href="#固定报头" class="headerlink" title="固定报头"></a>固定报头</h4><p>每个MQTT报文都包含一个固定报头，下图描述了固定报头的格式<br><img src="https://img-blog.csdnimg.cn/20200317172229863.png"><br>其中MQTT控制报文的类型决定了这个报文是Connect，还是Disconnect，还是Subscribe，7到4位不同数值代表的数字如下<br><img src="https://img-blog.csdnimg.cn/20200317173204950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_1,color_FFFFFF,t_70"></p>
<ul>
<li>用于指定控制类型的标志位只有PUBLISH有用，用来标志这个消息的Qos，</li>
<li>剩余长度用于显示该报文端剩余字节的长度</li>
</ul>
<h4 id="可变报头"><a href="#可变报头" class="headerlink" title="可变报头"></a>可变报头</h4><p>它在固定报头和负载之间。可变报头的内容根据报文类型的不同而不同。可变报头的报文标识符（Packet Identifier）字段存在于在多个类型的报文里。</p>
<h4 id="有效载荷"><a href="#有效载荷" class="headerlink" title="有效载荷"></a>有效载荷</h4><p>有效载荷搭载报文段的有效内容，比如在PUBLISH中，有效载荷就是硬件设备要发送到物联网平台的内容。在硬件设备作为客户端连接到服务端使用Connect时，有效载荷就是用户名和密码等内容。</p>
<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><h3 id="硬件设备端-1"><a href="#硬件设备端-1" class="headerlink" title="硬件设备端"></a>硬件设备端</h3><p>硬件设备端需要完成温湿度数据的读取，wifi的连接，MQTT服务端的连接和数据的上报。因为任务比较简单，不使用操作系统，直接使用裸机开发。MQTT报文需要用JSON格式收发，所以发送数据之前需要自行封装成JSON格式。之前分析过MQTT协议，这里为了使用方便，我们使用开源的Paho MQTT协议栈，可完成多个平台间的切换，该代码不仅可使用阿里云物联网平台，也适用于其他物联网平台。详细步骤为：</p>
<p>1.硬件初始化<br>2.连接WIFI，TCP/IP协议建立与阿里云服务器建立连接<br>3.使用MQTT协议发送CONNECT报文连接阿里云物联网平台<br>4.大循环中读取温湿度传感器的数据，并且封装成JSON格式使用MQTT协议的PUBLISH向指定话题发布消息，将消息发送到阿里云物联网服务器</p>
<p>JSON格式数据如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;id&quot;</span>:<span class="string">&quot;12345&quot;</span>,</span><br><span class="line">	<span class="string">&quot;method&quot;</span>:<span class="string">&quot;thing.event.property.post&quot;</span>,</span><br><span class="line">	<span class="string">&quot;params&quot;</span>:&#123;</span><br><span class="line">		<span class="string">&quot;LEDSwitch&quot;</span>:当前LED灯的状态,</span><br><span class="line">		<span class="string">&quot;CurrentHumidity&quot;</span>:当前湿度,</span><br><span class="line">		<span class="string">&quot;CurrentTemperature&quot;</span>,当前温度</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大循环主要代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">	  HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">	  <span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port,KEY1_Pin))</span><br><span class="line">	  &#123;</span><br><span class="line">		KEY_STATUS = <span class="number">1</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">else</span>&#123;</span><br><span class="line">		KEY_STATUS = <span class="number">0</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">	  DHT11_Read_Data(&amp;temperature,&amp;humidity);</span><br><span class="line">	  </span><br><span class="line">	  cJSON * pJsonRoot = <span class="literal">NULL</span>;</span><br><span class="line">	  pJsonRoot = cJSON_CreateObject();<span class="comment">//</span></span><br><span class="line">	  cJSON_AddStringToObject(pJsonRoot, <span class="string">&quot;id&quot;</span>, <span class="string">&quot;12345&quot;</span>);<span class="comment">//</span></span><br><span class="line">	  cJSON_AddStringToObject(pJsonRoot, <span class="string">&quot;method&quot;</span>, <span class="string">&quot;thing.event.property.post&quot;</span>);<span class="comment">//</span></span><br><span class="line">	  cJSON * pJsonChild = cJSON_CreateObject();<span class="comment">//</span></span><br><span class="line">	  cJSON_AddNumberToObject(pJsonChild, <span class="string">&quot;LEDSwitch&quot;</span>, KEY_STATUS);</span><br><span class="line">		cJSON_AddNumberToObject(pJsonChild, <span class="string">&quot;CurrentHumidity&quot;</span>,humidity);</span><br><span class="line">		cJSON_AddNumberToObject(pJsonChild, <span class="string">&quot;CurrentTemperature&quot;</span>,temperature);</span><br><span class="line">	  cJSON_AddItemToObject(pJsonRoot, <span class="string">&quot;params&quot;</span>, pJsonChild);<span class="comment">//</span></span><br><span class="line">	  </span><br><span class="line">	  <span class="keyword">char</span> * lpJsonStr = cJSON_Print(pJsonRoot);</span><br><span class="line">		<span class="comment">//cJSON_Delete(pJsonChild);</span></span><br><span class="line">	  cJSON_Delete(pJsonRoot);<span class="comment">//</span></span><br><span class="line">	  u1_printf(<span class="string">&quot;time:%s\r\n&quot;</span>,lpJsonStr);</span><br><span class="line">	  IOT_baidu_connect_publish(P_TOPIC_NAME,lpJsonStr);</span><br><span class="line">		<span class="built_in">free</span>(lpJsonStr);</span><br><span class="line">		</span><br><span class="line">  &#125;		</span><br></pre></td></tr></table></figure>

<p>连接实物图</p>
<p><img src="https://img-blog.csdnimg.cn/20200317181222570.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<h3 id="阿里云物联网平台端"><a href="#阿里云物联网平台端" class="headerlink" title="阿里云物联网平台端"></a>阿里云物联网平台端</h3><p><img src="https://img-blog.csdnimg.cn/20200317184702106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>连接物联网平台需要先创建设备，根据这个设备的证书信息，和密码。设备可通过一个三元组证书信息连接到云服务器。<br>阿里云物联网服务器作为设备的接收和中转站，管理所有通过MQTT协议发送和接收的信息。<br>将Web服务器和硬件设备定义成两个设备，通过设置规则引擎，完成数据的接收和转发。</p>
<p>下图为规则引擎设计<br><img src="https://img-blog.csdnimg.cn/20200317185742480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_1,color_FFFFFF,t_70"></p>
<h3 id="阿里云Web服务器端"><a href="#阿里云Web服务器端" class="headerlink" title="阿里云Web服务器端"></a>阿里云Web服务器端</h3><h4 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h4><ul>
<li>原生Linux系统</li>
<li>使用node.js框架作为网站后端</li>
<li>使用node.js软件包中的node-red数据流处理工具</li>
</ul>
<h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><p>使用node-red，node-red是一种图形化的后端处理工具，适用于物联网服务等小型服务端应用搭建，不需要写代码，部署比较快捷。<br>使用node-red主要完成以下几个功能</p>
<ul>
<li>作为MQTT协议中的客户端，连接阿里云物联网平台，订阅相关话题，接收上传的JSON格式MQTT报文</li>
<li>对JSON格式的报文进行处理，获得上传的温湿度信息</li>
<li>将接收到的温湿度信息以表盘和曲线图的形式显示出来</li>
</ul>
<p>下图为在node-red上完成的配置，没有写一点代码，点击部署后完成部署，便可以在网页上看到<br><img src="https://img-blog.csdnimg.cn/20200317191840160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<p>打开硬件设备，待其连接到阿里云物联网平台，然后进入以下网址</p>
<p><a target="_blank" rel="noopener" href="http://47.105.207.251:1880/ui">http://47.105.207.251:1880/ui</a></p>
<p>截至这篇文章提交，我使用的阿里云服务器免费七天试用期已到，应该不可访问。。。</p>
<p>就可以看到实时的温湿度信息。<br><img src="https://img-blog.csdnimg.cn/20200317192820477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<p>湿度比较大的两个尖峰是我用嘴吹了两口气。人工增加了湿度。</p>
<p><strong>至此完成了基于MQTT应用层协议的物联网家庭温湿度监测系统的设计与制作。</strong></p>
<h1 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h1><p>这次基于MQTT应用层协议的物联网家庭温湿度监测系统的实验过程中，我查询了很多资料，解决了不少bug。主要锻炼了学习新知识并且运用新知识的能力，在此过程中运用到了嵌入式，服务器前后端等知识。通过物联网实验，对计算机网络各个层次的理解和应用更加深刻透彻，充分理解了TCP/IP协议在实际计算机网络的应用中起到了什么样的作用。深入学习了MQTT协议，初步掌握了物联网产品的架构和开发流程，为以后制作物联网相关应用打下了基础。<br>本实验初步打通了物联网的整个数据链路，通过该实验，下一步可以完成更加复杂智能的物联网应用，比如实时操控家里的家电，家中电器通过检测环境变化自动开关机。添加微信小程序访问Web服务器，从而监控物联网设备等功能。<br>总之，在5G时代即将到来之际，物联网及其应用将迎来新的发展机遇，值得我们好好研究。</p>
<p><strong>硬件设备端stm32源码</strong><br><a target="_blank" rel="noopener" href="https://github.com/FranHawk/TemHumIViewer.git">https://github.com/FranHawk/TemHumIViewer.git</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/03/03/%E7%89%A9%E8%81%94%E7%BD%91%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%20%EF%BC%88%E5%85%AD%EF%BC%89%20stm32+mqtt%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91IOT%E5%AE%8C%E6%88%90%E8%AF%9D%E9%A2%98%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fran Hawk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张竞豪的小岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/03/%E7%89%A9%E8%81%94%E7%BD%91%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%20%EF%BC%88%E5%85%AD%EF%BC%89%20stm32+mqtt%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91IOT%E5%AE%8C%E6%88%90%E8%AF%9D%E9%A2%98%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85/" class="post-title-link" itemprop="url">物联网项目设计 （六） stm32+mqtt连接阿里云IOT完成话题发布与订阅</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2020-03-03 19:50:43" itemprop="dateCreated datePublished" datetime="2020-03-03T19:50:43+08:00">2020-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2021-08-13 10:01:01" itemprop="dateModified" datetime="2021-08-13T10:01:01+08:00">2021-08-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>上一部分成功连接阿里云，完成了阿里云的连接与ping操作。<br>下面介绍使用pahomqtt连接阿里云IOT，完成消息的发布和订阅。完成云端和设备端的通讯。</p>
<h1 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h1><p>1.使用MQTT.fx模拟设备端，与阿里云平台进行通讯，验证可行性<br>2.使用stm32编写代码，完成真机调试</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h3 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h3><p>使用stm32系列MCU，并有带网络功能的外设</p>
<h3 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h3><ul>
<li>CubeMX用于配置工程</li>
<li>MDK5编写编译代码</li>
<li>MQTT.fx作为虚拟设备端完成仿真调试</li>
<li>阿里云IOT平台</li>
</ul>
<h1 id="实现部分"><a href="#实现部分" class="headerlink" title="实现部分"></a>实现部分</h1><h3 id="使用MQTT-fx完成仿真"><a href="#使用MQTT-fx完成仿真" class="headerlink" title="使用MQTT.fx完成仿真"></a>使用MQTT.fx完成仿真</h3><p>1.根据阿里云的文档创建一个产品，创建一个这个产品的设备，并添加一个自定义功能<br><img src="https://img-blog.csdnimg.cn/20200303163827588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20200303163911960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>为了便于验证，我创建的是一个最简单的属性，一个LED灯的开关<br><img src="https://img-blog.csdnimg.cn/20200303164031251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>2.根据生成的设备三元组，使用MQTT.fx添加参数连接阿里云<br><img src="https://img-blog.csdnimg.cn/20200303164229112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>以上参数如何填写在阿里云文档里都能找到，我在前面的内容中也说过，这里不再赘述。见物联网设计 （五）</p>
<p>填写完，点击Connect，连接阿里云，成功后看到阿里云控制台显示在线<br><img src="https://img-blog.csdnimg.cn/2020030316454025.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>2.在MQTT.fx中添加要订阅和发布的话题<br><img src="https://img-blog.csdnimg.cn/20200303165020381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>在设备的Topic列表中发现，有两个话题分别是我们需要的上报属性的话题和云端设置属性的话题。<br>根据这个，在MQTT.fx中订阅<code>/sys/a1w0XJbXwh0/SmartLED_01/thing/service/property/set</code>这个话题<br>发布<code>sys/a1w0XJbXwh0/SmartLED_01/thing/event/property/post</code>这个话题</p>
<p>3.在阿里云控制台点击在线运维，选择刚刚我们创建的设备的功能，方法选择：<strong>设置</strong><br><img src="https://img-blog.csdnimg.cn/20200303165416603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>如上图，会自动生成一个JSON格式的数据。点击发送指令。我们会在MQTT.fx端接收到消息。<br><img src="https://img-blog.csdnimg.cn/20200303165627527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>接收成功，下面我们要向post话题发布消息<br>发布消息的JSON格式仿照我们接收回来的消息格式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;method&quot;</span> : <span class="string">&quot;thing.service.property.post&quot;</span>,</span><br><span class="line">  <span class="string">&quot;id&quot;</span> : <span class="string">&quot;12345&quot;</span>,</span><br><span class="line">  <span class="string">&quot;params&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;LEDSwitch&quot;</span> : <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;version&quot;</span> : <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中method一定要填对，id可以随便填，LEDSwitch就是我们需要的属性<br>点击Publish发送<br><img src="https://img-blog.csdnimg.cn/20200303170018400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>在阿里云控制台观察到LED开关的状态已经被我们更新了<br><img src="https://img-blog.csdnimg.cn/20200303170127796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>至此，完成使用MQTT.fx模拟设备端与阿里云IOT平台进行通讯。</p>
<h3 id="使用stm32编写代码，完成真机调试"><a href="#使用stm32编写代码，完成真机调试" class="headerlink" title="使用stm32编写代码，完成真机调试"></a>使用stm32编写代码，完成真机调试</h3><h3 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h3><p>工程基于物联网设计 （五）的工程，使用CubeMx增加一个按键和一个LED的配置，使用CubeMx增加LED1和KEY1<br><img src="https://img-blog.csdnimg.cn/20200303171534778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<h3 id="分成两个步骤，我们分别完成订阅和发送的功能"><a href="#分成两个步骤，我们分别完成订阅和发送的功能" class="headerlink" title="分成两个步骤，我们分别完成订阅和发送的功能"></a>分成两个步骤，我们分别完成订阅和发送的功能</h3><p>在头文件中添加订阅和发布的话题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  S_TOPIC_NAME         <span class="meta-string">&quot;/sys/a1w0XJbXwh0/SmartLED_01/thing/service/property/set&quot;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  P_TOPIC_NAME         <span class="meta-string">&quot;/sys/a1w0XJbXwh0/SmartLED_01/thing/event/property/post&quot;</span>      </span></span><br></pre></td></tr></table></figure>

<h4 id="发送功能"><a href="#发送功能" class="headerlink" title="发送功能"></a>发送功能</h4><p>1.编写向指定话题发布消息的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">IOT_baidu_connect_publish</span><span class="params">(<span class="keyword">char</span> *pTopic,<span class="keyword">char</span> *pMessage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">uint8_t</span> err_cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> len;</span><br><span class="line">    MQTTString topicString = MQTTString_initializer;</span><br><span class="line">    <span class="keyword">int</span> msglen = <span class="built_in">strlen</span>(pMessage);</span><br><span class="line">    <span class="keyword">int</span> buflen = <span class="keyword">sizeof</span>(buf);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (MQTTPacket_read(buf, buflen, transport_getdata) == PUBREC)</span><br><span class="line">		&#123;</span><br><span class="line">				<span class="keyword">unsigned</span> <span class="keyword">char</span> packettype = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">unsigned</span> <span class="keyword">char</span> dup_ack = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">unsigned</span> <span class="keyword">short</span> packetid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">				MQTTDeserialize_ack(&amp;packettype,&amp;dup_ack,&amp;packetid,buf,buflen);</span><br><span class="line">				err_cnt=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//Ã»½ÓÊÕµ½»Ø¸´</span></span><br><span class="line">		&#123;</span><br><span class="line">				err_cnt++;</span><br><span class="line">				<span class="keyword">if</span>(err_cnt&gt;<span class="number">3</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					err_cnt=<span class="number">0</span>;</span><br><span class="line">					u1_printf(<span class="string">&quot;Something Wrong\r\n&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,buflen);</span><br><span class="line">    topicString.cstring = pTopic;</span><br><span class="line">    len = MQTTSerialize_publish(buf, buflen, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, topicString, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)pMessage, msglen);</span><br><span class="line"></span><br><span class="line">	USART3_RX_STA = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(USART3_RX_BUF,<span class="number">0</span>,USART3_MAX_RECV_LEN);</span><br><span class="line">    transport_sendPacketBuffer(<span class="number">3</span>,buf,len);</span><br><span class="line">		<span class="built_in">free</span>(pMessage);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.在main函数中扫描按键，并将按键状态作为LEDStatus，按照之前说的格式，制作JSON数据包并发布</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">  HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port,KEY1_Pin))</span><br><span class="line">  &#123;</span><br><span class="line">	KEY_STATUS = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">	KEY_STATUS = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cJSON * pJsonRoot = <span class="literal">NULL</span>;</span><br><span class="line">  pJsonRoot = cJSON_CreateObject();<span class="comment">//</span></span><br><span class="line">  cJSON_AddStringToObject(pJsonRoot, <span class="string">&quot;id&quot;</span>, <span class="string">&quot;12345&quot;</span>);<span class="comment">//</span></span><br><span class="line">  cJSON_AddStringToObject(pJsonRoot, <span class="string">&quot;method&quot;</span>, <span class="string">&quot;thing.event.property.post&quot;</span>);<span class="comment">//</span></span><br><span class="line">  cJSON * pJsonChild = cJSON_CreateObject();<span class="comment">//</span></span><br><span class="line">  cJSON_AddNumberToObject(pJsonChild, <span class="string">&quot;LEDSwitch&quot;</span>, KEY_STATUS);</span><br><span class="line">  cJSON_AddItemToObject(pJsonRoot, <span class="string">&quot;params&quot;</span>, pJsonChild);<span class="comment">//</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">char</span> * lpJsonStr = cJSON_Print(pJsonRoot);</span><br><span class="line">  cJSON_Delete(pJsonRoot);<span class="comment">//</span></span><br><span class="line">  </span><br><span class="line">  IOT_baidu_connect_publish(P_TOPIC_NAME,lpJsonStr);</span><br><span class="line"> &#125;		</span><br></pre></td></tr></table></figure>

<p>3.通过阿里云控制台观察现象<br>通过调试窗口发现，每隔一秒，接收到一个数据<br><img src="https://img-blog.csdnimg.cn/20200303185010204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>通过设备状态窗口看到，按键按下，显示为0，按键松开，显示为1，说明向话题发送数据成功<br><img src="https://img-blog.csdnimg.cn/20200303185235567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20200303185247255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<h4 id="接收功能"><a href="#接收功能" class="headerlink" title="接收功能"></a>接收功能</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/03/02/%E7%89%A9%E8%81%94%E7%BD%91%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%20%EF%BC%88%E4%BA%94%EF%BC%89%20Paho%20mqtt%20%E5%BA%93%E5%9C%A8STM32+esp8266%20%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E7%A7%BB%E6%A4%8D%E5%92%8C%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%8C%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91IOT%E5%B9%B3%E5%8F%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fran Hawk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张竞豪的小岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/02/%E7%89%A9%E8%81%94%E7%BD%91%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%20%EF%BC%88%E4%BA%94%EF%BC%89%20Paho%20mqtt%20%E5%BA%93%E5%9C%A8STM32+esp8266%20%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E7%A7%BB%E6%A4%8D%E5%92%8C%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%8C%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91IOT%E5%B9%B3%E5%8F%B0/" class="post-title-link" itemprop="url">物联网项目设计 （五） Paho mqtt 库在STM32+esp8266 硬件平台上的移植和使用第一部分，连接阿里云IOT平台</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2020-03-02 19:50:43" itemprop="dateCreated datePublished" datetime="2020-03-02T19:50:43+08:00">2020-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2021-08-13 10:01:01" itemprop="dateModified" datetime="2021-08-13T10:01:01+08:00">2021-08-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文代码链接 <a target="_blank" rel="noopener" href="https://github.com/FranHawk/ConnectTOAliIOTServer.git">https://github.com/FranHawk/ConnectTOAliIOTServer.git</a><br>之前一直准备使用百度云天工作为物联网云平台，但是百度云天工平台的文档写的确实不是很好，相关API的接口也和其他方案有不一样，安全性不够好，故准备使用阿里云IOT平台。后期估计还要涉及到前后端的实现，自己搭建云服务器，才能完成数据存储和小程序开发。阿里云也提供了相关的接口，使用起来比较方便。</p>
<p>这几天查阅了很多的MQTT相关的资料，结果发现查到了太多底层的东西。根本没有太大的作用，浪费了很多时间。在掌握基本的MQTT的概念后，我发现只用掌握连接服务器，订阅话题，发布话题这些操作就足以满足最基本的需要。</p>
<p>在物联网设计（三）中，完成了连接本地服务器的功能，通过MQTT连接云服务器的步骤有所改变。</p>
<p>1.在使用TCP连接服务器的阶段，我们需要把连接的域名和端口改成云服务器的端口。<br>2.连接成功后进入透传模式<br>3.使用paho mqtt提供的函数连接服务器</p>
<p>接下来就要讲述如何一步步的完成这些操作</p>
<h1 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h1><p>stm32+esp8266硬件设备一套</p>
<h1 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h1><p>已经注册好阿里云帐号并创建好设备，创建过程和前面百度云的创建过程类似，这里还是给出<a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/73705.html?spm=a2c4g.11186623.6.560.626f580023CUIY">文档链接</a></p>
<h5 id="当创建好设备后，会生成一个设备三元组，后面我们连接IOT平台使用一机一密的方式，这个设备三元组后面会经常用，记得妥善保存"><a href="#当创建好设备后，会生成一个设备三元组，后面我们连接IOT平台使用一机一密的方式，这个设备三元组后面会经常用，记得妥善保存" class="headerlink" title="当创建好设备后，会生成一个设备三元组，后面我们连接IOT平台使用一机一密的方式，这个设备三元组后面会经常用，记得妥善保存"></a>当创建好设备后，会生成一个设备三元组，后面我们连接IOT平台使用一机一密的方式，这个设备三元组后面会经常用，记得妥善保存</h5><p><img src="https://img-blog.csdnimg.cn/20200302133049752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<h1 id="移植paho-mqtt库至STM32工程中"><a href="#移植paho-mqtt库至STM32工程中" class="headerlink" title="移植paho mqtt库至STM32工程中"></a>移植paho mqtt库至STM32工程中</h1><h4 id="1-从github上下载paho-mqtt嵌入式版本开源库，代码链接。"><a href="#1-从github上下载paho-mqtt嵌入式版本开源库，代码链接。" class="headerlink" title="1.从github上下载paho mqtt嵌入式版本开源库，代码链接。"></a>1.从github上下载paho mqtt嵌入式版本开源库，<a target="_blank" rel="noopener" href="https://github.com/eclipse/paho.mqtt.embedded-c">代码链接</a>。</h4><h4 id="2-解压并打开"><a href="#2-解压并打开" class="headerlink" title="2.解压并打开"></a>2.解压并打开</h4><p>找到<code>paho.mqtt.embedded-c-master\MQTTPacket\src</code>的所有文件和<code>paho.mqtt.embedded-c-master\MQTTPacket\samples</code>里面的transport.c和transport.h两个文件<br><img src="https://img-blog.csdnimg.cn/20200227202513947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20200227202523681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<h4 id="3-在自己的工程中新建一个文件夹存放这些文件，我用的工程是物联网（三）中创建的工程"><a href="#3-在自己的工程中新建一个文件夹存放这些文件，我用的工程是物联网（三）中创建的工程" class="headerlink" title="3.在自己的工程中新建一个文件夹存放这些文件，我用的工程是物联网（三）中创建的工程"></a>3.在自己的工程中新建一个文件夹存放这些文件，我用的工程是物联网（三）中创建的工程</h4><p><img src="https://img-blog.csdnimg.cn/20200227202910686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20200227202919966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<h4 id="4-在工程中添加这些文件"><a href="#4-在工程中添加这些文件" class="headerlink" title="4.在工程中添加这些文件"></a>4.在工程中添加这些文件</h4><p><img src="https://img-blog.csdnimg.cn/20200227215325572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<h4 id="5-找到transport-c-对其进行更改，首先改掉上面用的include函数，改为自己的，下面的是我根据自己的软件环境更改的头文件如下"><a href="#5-找到transport-c-对其进行更改，首先改掉上面用的include函数，改为自己的，下面的是我根据自己的软件环境更改的头文件如下" class="headerlink" title="5.找到transport.c ,对其进行更改，首先改掉上面用的include函数，改为自己的，下面的是我根据自己的软件环境更改的头文件如下"></a>5.找到transport.c ,对其进行更改，首先改掉上面用的include函数，改为自己的，下面的是我根据自己的软件环境更改的头文件如下</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f1xx_hal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp8266.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;transport.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>除了上面的头文件之外。这个文件自己带的include和define都被我删了</p>
<h4 id="6-重点：更改transport-sendPacketBuffer和transport-getdatanb函数，这两个函数就是MQTT操作单片机发送和接受数据的主要函数，在这里我们用USART来改变里面的发送数据的函数，使用中断方式发送，中断方式接收"><a href="#6-重点：更改transport-sendPacketBuffer和transport-getdatanb函数，这两个函数就是MQTT操作单片机发送和接受数据的主要函数，在这里我们用USART来改变里面的发送数据的函数，使用中断方式发送，中断方式接收" class="headerlink" title="6.重点：更改transport_sendPacketBuffer和transport_getdatanb函数，这两个函数就是MQTT操作单片机发送和接受数据的主要函数，在这里我们用USART来改变里面的发送数据的函数，使用中断方式发送，中断方式接收"></a>6.重点：更改<code>transport_sendPacketBuffer</code>和<code>transport_getdatanb</code>函数，这两个函数就是MQTT操作单片机发送和接受数据的主要函数，在这里我们用USART来改变里面的发送数据的函数，使用中断方式发送，中断方式接收</h4><p>通过这样的方式，使硬件和上层MQTT应用层代码解耦合，如果之后使用不同的硬件，其他代码不需要更改，只需要更改transport中的代码。来适应当时使用的通讯模块就可以了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">transport_sendPacketBuffer</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">unsigned</span> <span class="keyword">char</span>* buf, <span class="keyword">int</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	USART3_RX_STA = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(USART3_RX_BUF,<span class="number">0</span>,USART3_MAX_RECV_LEN);</span><br><span class="line">	HAL_UART_Transmit(&amp;huart3, buf, buflen,<span class="number">1000</span>);</span><br><span class="line">	<span class="keyword">return</span> buflen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">transport_getdata</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* buf, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint8_t</span> i=<span class="number">10</span>;</span><br><span class="line">	<span class="built_in">memcpy</span>(buf, (<span class="keyword">const</span> <span class="keyword">char</span>*)USART3_RX_BUF, count);</span><br><span class="line">	</span><br><span class="line">	USART3_RX_STA = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(USART3_RX_BUF,<span class="number">0</span>,USART3_MAX_RECV_LEN);</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-剩下的三个函数让他们直接变为空"><a href="#7-剩下的三个函数让他们直接变为空" class="headerlink" title="7.剩下的三个函数让他们直接变为空"></a>7.剩下的三个函数让他们直接变为空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">transport_getdatanb</span><span class="params">(<span class="keyword">void</span> *sck, <span class="keyword">unsigned</span> <span class="keyword">char</span>* buf, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">transport_open</span><span class="params">(<span class="keyword">char</span>* addr, <span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">transport_close</span><span class="params">(<span class="keyword">int</span> sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-在main函数中加入头文件，以检验移植是否成功"><a href="#8-在main函数中加入头文件，以检验移植是否成功" class="headerlink" title="8.在main函数中加入头文件，以检验移植是否成功"></a>8.在main函数中加入头文件，以检验移植是否成功</h4><p><img src="https://img-blog.csdnimg.cn/20200227222730240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp8266.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MQTTPacket.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;transport.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="9-编译工程，没有错误，移植成功"><a href="#9-编译工程，没有错误，移植成功" class="headerlink" title="9.编译工程，没有错误，移植成功"></a>9.编译工程，没有错误，移植成功</h4><p><img src="https://img-blog.csdnimg.cn/20200227223635333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<h1 id="连接阿里云服务器"><a href="#连接阿里云服务器" class="headerlink" title="连接阿里云服务器"></a>连接阿里云服务器</h1><h4 id="1-根据单步调试的原则，先测试用TCP连接阿里云IOT服务器是否成功"><a href="#1-根据单步调试的原则，先测试用TCP连接阿里云IOT服务器是否成功" class="headerlink" title="1.根据单步调试的原则，先测试用TCP连接阿里云IOT服务器是否成功"></a>1.根据单步调试的原则，先测试用TCP连接阿里云IOT服务器是否成功</h4><p><img src="https://img-blog.csdnimg.cn/2020030213262457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>根据以上的域名，更改在AT指令连接TCP服务器处的域名和端口号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOT_DOMAIN_NAME <span class="meta-string">&quot;a1w0XJbXwh0.iot-as-mqtt.cn-shanghai.aliyuncs.com&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOT_PORTNUM 	<span class="meta-string">&quot;1883&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">esp8266_Connect_Server</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint8_t</span> i=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">char</span> *p = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">50</span>);</span><br><span class="line">	<span class="built_in">sprintf</span>((<span class="keyword">char</span>*)p,<span class="string">&quot;AT+CIPSTART=\&quot;TCP\&quot;,\&quot;%s\&quot;,\%s&quot;</span>,IOT_DOMAIN_NAME,IOT_PORTNUM);</span><br><span class="line">	<span class="keyword">while</span>(esp8266_send_cmd(p,<span class="string">&quot;CONNECT&quot;</span>,<span class="number">1000</span>)&amp;&amp;i)</span><br><span class="line">	&#123;</span><br><span class="line">		u1_printf(<span class="string">&quot;链接服务器失败，尝试重新连接\r\n&quot;</span>);</span><br><span class="line">		i--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">if</span>(i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是esp8266初始化函数的代码片段，完整代码请看物联网项目设计(三)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">u1_printf(<span class="string">&quot;设置为关闭多路连接\r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(esp8266_send_cmd(<span class="string">&quot;AT+CIPMUX=0&quot;</span>,<span class="string">&quot;OK&quot;</span>,<span class="number">100</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		u1_printf(<span class="string">&quot;关闭多路连接失败，准备重启\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> u1_printf(<span class="string">&quot;设置关闭多路连接成功\r\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	u1_printf(<span class="string">&quot;准备链接服务器\r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(esp8266_Connect_Server())</span><br><span class="line">	&#123;</span><br><span class="line">		u1_printf(<span class="string">&quot;连接服务器失败，等待重启\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> u1_printf(<span class="string">&quot;连接服务器成功\r\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	u1_printf(<span class="string">&quot;准备退出透传模式\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(esp8266_quit_trans())</span><br><span class="line">	&#123;</span><br><span class="line">		u1_printf(<span class="string">&quot;退出透传模式失败，准备重启\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> u1_printf(<span class="string">&quot;退出透传模式成功\r\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>通过串口助手发现成功连接<br><img src="https://img-blog.csdnimg.cn/20200228102652418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<h4 id="2-参考开源代码和文档，寻找连接方法。"><a href="#2-参考开源代码和文档，寻找连接方法。" class="headerlink" title="2.参考开源代码和文档，寻找连接方法。"></a>2.参考开源代码和文档，寻找连接方法。</h4><p>这里先使用ping的方法而不是直接的订阅或发布一个MQTT话题还是考虑到步子不要跨的太大，先测试是否能连接上。<br>paho mqtt的github代码包中有比较简单的测试代码，我们可以借鉴<br><img src="https://img-blog.csdnimg.cn/20200228103624301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>研究了下他的步骤，先是创建一个结构体，然后对结构体中的参数进行赋值，最后使用<code>MQTTSerialize_connect</code>连接，使用<code>MQTTPacket_read(buf, buflen, transport_getdata) == CONNACK</code>检测是否连接成功，然后定时，不停地ping，但是这些初始化参数如何设定呢，准备连接好后仔细研究下阿里云的文档，少走弯路。<a target="_blank" rel="noopener" href="https://helpcdn.aliyun.com/document_detail/73742.html?spm=a2c4g.11186623.6.589.2fb76eebBvUFK3#title-gu1-dfz-qzi">文档链接</a></p>
<p><em>以下是阿里云文档中对链接信息的描述</em><br><img src="https://img-blog.csdnimg.cn/20200228105224445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>以下是Paho开源代码中的示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">MQTTPacket_connectData data = MQTTPacket_connectData_initializer;</span><br><span class="line">	data.clientID.cstring = <span class="string">&quot;me&quot;</span>;</span><br><span class="line">	data.keepAliveInterval = KEEPALIVE_INTERVAL;</span><br><span class="line">	data.cleansession = <span class="number">1</span>;</span><br><span class="line">	data.username.cstring = <span class="string">&quot;testuser&quot;</span>;</span><br><span class="line">	data.password.cstring = <span class="string">&quot;testpassword&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	len = MQTTSerialize_connect(buf, buflen, &amp;data);</span><br><span class="line">	rc = transport_sendPacketBuffer(mysock, buf, len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Sent MQTT connect\n&quot;</span>);</span><br><span class="line">	<span class="comment">/* wait for connack */</span></span><br><span class="line">	<span class="keyword">if</span> (MQTTPacket_read(buf, buflen, transport_getdata) == CONNACK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">char</span> sessionPresent, connack_rc;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (MQTTDeserialize_connack(&amp;sessionPresent, &amp;connack_rc, buf, buflen) != <span class="number">1</span> || connack_rc != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Unable to connect, return code %d\n&quot;</span>, connack_rc);</span><br><span class="line">			<span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;MQTT connected\n&quot;</span>);</span><br><span class="line">	start_ping_timer();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!toStop)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(!time_to_ping());</span><br><span class="line">		len = MQTTSerialize_pingreq(buf, buflen);</span><br><span class="line">		transport_sendPacketBuffer(mysock, buf, len);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Ping...&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (MQTTPacket_read(buf, buflen, transport_getdata) == PINGRESP)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Pong\n&quot;</span>);</span><br><span class="line">			start_ping_timer();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;OOPS\n&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-尝试编写MQTT协议连接阿里云IOT服务器并ping通。"><a href="#3-尝试编写MQTT协议连接阿里云IOT服务器并ping通。" class="headerlink" title="3.尝试编写MQTT协议连接阿里云IOT服务器并ping通。"></a>3.尝试编写MQTT协议连接阿里云IOT服务器并ping通。</h4><p>1.为了保证高度松耦合，连接MQTT服务器部分的代码我重新建立一个文件夹，并建立两个文件如下<img src="https://img-blog.csdnimg.cn/20200302134044223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20200302134052863.png"></p>
<p>因为最开始连的是百度服务器，所以名字起成上面的样子了。。。</p>
<p>2.头文件中按照之前的设备三元组构建宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PRODUCTKEY           <span class="meta-string">&quot;a1w0XJbXwh0&quot;</span>                                        </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PRODUCTKEY_LEN       strlen(PRODUCTKEY)                                   #<span class="meta-keyword">define</span>  DEVICENAME			 <span class="meta-string">&quot;SmartLED_01&quot;</span>                                              </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  DEVICENAME_LEN       strlen(DEVICENAME)                                   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  DEVICESECRE          <span class="meta-string">&quot;uwMJYOGSoAPNdZBOi8hyDXXXXXXXXXXX&quot;</span>                  				 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  DEVICESECRE_LEN      strlen(DEVICESECRE)</span></span><br></pre></td></tr></table></figure>
<p>3.按照开源例程的写法，并参照<a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/146611.html?spm=a2c4g.11186623.2.27.7abc2cf04h8Xbs#task-2361871">阿里云的文档</a>，就能知道如何连接云服务器，编写相关代码，每三秒ping一次阿里云的服务器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;IOT_baidu.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;utils_hmac.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint16_t</span> buflen=<span class="number">200</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ClientID[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">uint8_t</span> ClientID_len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Username[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">uint8_t</span> Username_len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Password[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">uint8_t</span> Password_len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">IOT_baidu_connect</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">uint32_t</span> len;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">char</span> temp[<span class="number">128</span>];</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">		MQTTPacket_connectData data = MQTTPacket_connectData_initializer;<span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">		buflen = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">		<span class="built_in">memset</span>(buf,<span class="number">0</span>,buflen);</span><br><span class="line">	</span><br><span class="line">		<span class="built_in">memset</span>(ClientID,<span class="number">128</span>,<span class="number">0</span>);                                               </span><br><span class="line">		<span class="built_in">sprintf</span>(ClientID,<span class="string">&quot;%s|securemode=3,signmethod=hmacsha1|&quot;</span>,DEVICENAME);  </span><br><span class="line">	</span><br><span class="line">		<span class="built_in">memset</span>(Username,<span class="number">128</span>,<span class="number">0</span>);                                               </span><br><span class="line">		<span class="built_in">sprintf</span>(Username,<span class="string">&quot;%s&amp;%s&quot;</span>,DEVICENAME,PRODUCTKEY);                      </span><br><span class="line">	</span><br><span class="line">		Username_len = <span class="built_in">strlen</span>(Username);</span><br><span class="line">	</span><br><span class="line">		<span class="built_in">memset</span>(temp,<span class="number">128</span>,<span class="number">0</span>);                                                                      </span><br><span class="line">		<span class="built_in">sprintf</span>(temp,<span class="string">&quot;clientId%sdeviceName%sproductKey%s&quot;</span>,DEVICENAME,DEVICENAME,PRODUCTKEY);       </span><br><span class="line">		utils_hmac_sha1(temp,<span class="built_in">strlen</span>(temp),Password,DEVICESECRE,DEVICESECRE_LEN); <span class="comment">//Password的生成我使用的是网上的开源代码，如果没有的话可以使用阿里云文档中提供的密码静态生成工具                </span></span><br><span class="line">		Password_len = <span class="built_in">strlen</span>(Password);                                                         	</span><br><span class="line">		u1_printf(<span class="string">&quot;ClientId:%s\r\n&quot;</span>,ClientID);</span><br><span class="line">		u1_printf(<span class="string">&quot;Username:%s\r\n&quot;</span>,Username);</span><br><span class="line">		u1_printf(<span class="string">&quot;Password:%s\r\n&quot;</span>,Password);</span><br><span class="line">		</span><br><span class="line">		data.MQTTVersion = <span class="number">3</span>;</span><br><span class="line">		data.clientID.cstring = ClientID;						</span><br><span class="line">		data.keepAliveInterval = <span class="number">120</span>;		<span class="comment">//保活时间，单位为秒，也就是120秒内必须和服务器通讯一次，否则判定你下线，你就要重新连接					</span></span><br><span class="line">		data.cleansession = <span class="number">1</span>;									</span><br><span class="line">		data.username.cstring = Username;						</span><br><span class="line">		data.password.cstring = Password;						</span><br><span class="line">		</span><br><span class="line">		len = MQTTSerialize_connect(buf, buflen, &amp;data); 		</span><br><span class="line">		</span><br><span class="line">		transport_sendPacketBuffer(<span class="number">3</span>,buf, len);				</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">char</span> sessionPresent, connack_rc;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(MQTTPacket_read(buf, buflen, transport_getdata) != CONNACK)<span class="comment">//¶Ô½ÓÊÕµ½µÄ±¨ÎÄ½øÐÐ½âÎö</span></span><br><span class="line">            &#123;</span><br><span class="line">                ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(MQTTDeserialize_connack(&amp;sessionPresent, &amp;connack_rc, buf, buflen) != <span class="number">1</span> || connack_rc != <span class="number">0</span>);</span><br><span class="line">					<span class="keyword">if</span>(connack_rc != <span class="number">0</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						u1_printf(<span class="string">&quot;connack_rc:%uc\r\n&quot;</span>,connack_rc);</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">					u1_printf(<span class="string">&quot;Connect Success!\r\n&quot;</span>);</span><br><span class="line">					</span><br><span class="line">					<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						HAL_Delay(<span class="number">3000</span>);</span><br><span class="line">						len = MQTTSerialize_pingreq(buf, buflen);</span><br><span class="line">						transport_sendPacketBuffer(<span class="number">3</span>, buf, len);</span><br><span class="line">						HAL_Delay(<span class="number">100</span>);</span><br><span class="line">						u1_printf(<span class="string">&quot;Ping...\r\n&quot;</span>);</span><br><span class="line">						<span class="keyword">if</span> (MQTTPacket_read(buf, buflen, transport_getdata) == PINGRESP)&#123;</span><br><span class="line">							u1_printf(<span class="string">&quot;Pong\r\n&quot;</span>);</span><br><span class="line">						</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							u1_printf(<span class="string">&quot;OOPS\r\n&quot;</span>);</span><br><span class="line">						</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">IOT_baidu_ping</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">uint32_t</span> len;</span><br><span class="line">		len = MQTTSerialize_pingreq(buf, buflen);</span><br><span class="line">		transport_sendPacketBuffer(<span class="number">3</span>, buf, len);</span><br><span class="line">		u1_printf(<span class="string">&quot;Ping...\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (MQTTPacket_read(buf, buflen, transport_getdata) == PINGRESP)&#123;</span><br><span class="line">			u1_printf(<span class="string">&quot;Pong\r\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			u1_printf(<span class="string">&quot;OOPS\r\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4.最后在main中编写测试代码，并通过串口观察现象，每三秒ping一次</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">u1_printf(<span class="string">&quot;开始配置&quot;</span>);</span><br><span class="line">	HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">	HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">	HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">	</span><br><span class="line">  <span class="comment">/* USER CODE END 2 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">  <span class="keyword">while</span>(esp8266_Connect_IOTServer());</span><br><span class="line">  <span class="keyword">while</span>(IOT_baidu_connect());</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">	  IOT_baidu_ping();</span><br><span class="line">	  HAL_Delay(<span class="number">3000</span>);</span><br><span class="line">	  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200302140656538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>连接成功并ping通，同时在阿里云端发现设备在线，试验成功</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h5 id="1-本次实验演示了如何使用Paho-MQTT协议栈连接阿里云IOT平台，使用开源协议如MQTT的便利之处在于资料多，且多平台适用。"><a href="#1-本次实验演示了如何使用Paho-MQTT协议栈连接阿里云IOT平台，使用开源协议如MQTT的便利之处在于资料多，且多平台适用。" class="headerlink" title="1.本次实验演示了如何使用Paho MQTT协议栈连接阿里云IOT平台，使用开源协议如MQTT的便利之处在于资料多，且多平台适用。"></a>1.本次实验演示了如何使用Paho MQTT协议栈连接阿里云IOT平台，使用开源协议如MQTT的便利之处在于资料多，且多平台适用。</h5><h5 id="2-下一部分内容，使用stm32-esp8266订阅与发布阿里云平台的话题，并控制板子上LED的亮灭"><a href="#2-下一部分内容，使用stm32-esp8266订阅与发布阿里云平台的话题，并控制板子上LED的亮灭" class="headerlink" title="2.下一部分内容，使用stm32+esp8266订阅与发布阿里云平台的话题，并控制板子上LED的亮灭"></a>2.下一部分内容，使用stm32+esp8266订阅与发布阿里云平台的话题，并控制板子上LED的亮灭</h5><h5 id="3-研究了下阿里云整套开发流程，完成小程序的开发恐怕还要完成服务器的建立，工作量怕是要提升了"><a href="#3-研究了下阿里云整套开发流程，完成小程序的开发恐怕还要完成服务器的建立，工作量怕是要提升了" class="headerlink" title="3.研究了下阿里云整套开发流程，完成小程序的开发恐怕还要完成服务器的建立，工作量怕是要提升了"></a>3.研究了下阿里云整套开发流程，完成小程序的开发恐怕还要完成服务器的建立，工作量怕是要提升了</h5>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/27/%E7%89%A9%E8%81%94%E7%BD%91%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%9B%9B%EF%BC%89cJSON%20%E5%9C%A8%20STM32%20%E7%A7%BB%E6%A4%8D%E5%92%8C%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fran Hawk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张竞豪的小岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/27/%E7%89%A9%E8%81%94%E7%BD%91%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%9B%9B%EF%BC%89cJSON%20%E5%9C%A8%20STM32%20%E7%A7%BB%E6%A4%8D%E5%92%8C%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">物联网项目设计（四）cJSON 在 STM32 移植和使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2020-02-27 19:50:43" itemprop="dateCreated datePublished" datetime="2020-02-27T19:50:43+08:00">2020-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2021-08-13 10:01:01" itemprop="dateModified" datetime="2021-08-13T10:01:01+08:00">2021-08-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>JSON格式是互联网通讯过程中常用的格式。包括MQTT协议也不例外，MQTT协议的数据收发都是使用JSON格式完成的。在使用MQTT协议进行通讯之前，我们需要掌握在c语言环境下JSON格式数据的操作。对JSON数据的操作我们使用了cJSON开源库。在使用的过程中，也遇到了不少问题（见后文），为此我查阅了很多资料，最后找到比较简单的方法解决了这个问题。</p>
<ul>
<li><p>本篇介绍如何生成cJSON格式数据，并转化成字符串，通过串口发送到上位机。</p>
</li>
<li><p>关于cJSON的介绍和使用说明，这里推荐<a target="_blank" rel="noopener" href="https://blog.csdn.net/Mculover666/article/details/103796256?ops_request_misc=%7B%22request_id%22:%22158280087919724847048271%22,%22scm%22:%2220140713.130056874..%22%7D&request_id=158280087919724847048271&biz_id=0&utm_source=distribute.pc_search_result.none-task">另外一篇博文</a>。</p>
</li>
<li><p>下面是cJSON的源码github<a target="_blank" rel="noopener" href="https://github.com/DaveGamble/cJSON">地址</a></p>
</li>
</ul>
<h1 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><p>使用STM32主控的开发板或相关硬件设备</p>
<h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><p>上位机串口助手</p>
<h1 id="实际操作步骤"><a href="#实际操作步骤" class="headerlink" title="实际操作步骤"></a>实际操作步骤</h1><p>1.使用CubeMx建立一个简单的工程，只需要配置串口，<strong>但一定要注意，配置堆栈大小的时候一定要配置的大一点，因为cJSON分配内存的时候会占用不少内存空间，内存分配是单片机移植cJSON遇到的最常见的问题，如果内存分配的不对，很容易就导致生成的JSON字符串里面什么都没有。网上很多解决方案是自行编写内存管理函数，也就是malloc和free，这种方法太麻烦而且可移植性不高，最后我选择了使用增大堆栈的方式。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200227191553249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<p>2.从github上获取cJSON的源码并解压，如下图<br><img src="https://img-blog.csdnimg.cn/20200227191638231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<p>我们只需要其中的cJSON.c和cJSON.h，并把他们复制到工程中。<br><img src="https://img-blog.csdnimg.cn/20200227192018430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<p>3.实际编写代码部分，我们需要生成一个JSON格式的字符串如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;name&quot;</span>:	<span class="string">&quot;Alpha&quot;</span>,</span><br><span class="line">	<span class="string">&quot;address&quot;</span>:	&#123;</span><br><span class="line">		<span class="string">&quot;conutry&quot;</span>:	<span class="string">&quot;China&quot;</span>,</span><br><span class="line">		<span class="string">&quot;city&quot;</span>:	<span class="string">&quot;Luoyang&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;info&quot;</span>:	&#123;</span><br><span class="line">		<span class="string">&quot;age&quot;</span>:	<span class="number">21</span>,</span><br><span class="line">		<span class="string">&quot;weight&quot;</span>:	<span class="number">66</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际编写代码部分，我们要注意的是，在使用cJSON之后，要及时将其删除，其中删除父对象也会自动迭代删除子对象</p>
<p>下面是初始化部分，完成生成JSON格式数据，并将其转化为字符串格式数据，最后删除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">char</span> *buffer;</span><br><span class="line">cJSON* cjson_test = <span class="literal">NULL</span>;</span><br><span class="line">cJSON* cjson_address = <span class="literal">NULL</span>;</span><br><span class="line">cJSON* cjson_info = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cjson_test = cJSON_CreateObject();</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">cJSON_AddStringToObject(cjson_test,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Alpha&quot;</span>);</span><br><span class="line"></span><br><span class="line">cjson_address = cJSON_CreateObject();</span><br><span class="line">cJSON_AddStringToObject(cjson_address,<span class="string">&quot;conutry&quot;</span>,<span class="string">&quot;China&quot;</span>);</span><br><span class="line">cJSON_AddStringToObject(cjson_address,<span class="string">&quot;city&quot;</span>,<span class="string">&quot;Luoyang&quot;</span>);</span><br><span class="line"></span><br><span class="line">cJSON_AddItemToObject(cjson_test,<span class="string">&quot;address&quot;</span>,cjson_address);</span><br><span class="line"></span><br><span class="line">cjson_info = cJSON_CreateObject();</span><br><span class="line">cJSON_AddNumberToObject(cjson_info,<span class="string">&quot;age&quot;</span>,<span class="number">21</span>);</span><br><span class="line">cJSON_AddNumberToObject(cjson_info,<span class="string">&quot;weight&quot;</span>,<span class="number">66</span>);</span><br><span class="line"></span><br><span class="line">cJSON_AddItemToObject(cjson_test,<span class="string">&quot;info&quot;</span>,cjson_info);</span><br><span class="line"></span><br><span class="line">buffer = cJSON_Print(cjson_test);</span><br><span class="line"></span><br><span class="line">cJSON_Delete(cjson_test);</span><br></pre></td></tr></table></figure>
<p>下面是发送字符串到上位机部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">	  HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">	  u1_printf(<span class="string">&quot;You Json Is:%s\r\n&quot;</span>,buffer);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END 3 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4，编译代码并在上位机中观察现象<br><img src="https://img-blog.csdnimg.cn/20200227192658566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<p>完成了所需要的功能</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本部分内容完成了cJSON的移植和JSON格式的初步使用，下一阶段准备使用paho 的开源mqtt库链接百度云天工，并且使用paho自带的ping函数，完成stm32链接百度云天工后的连接检测。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/26/%E7%89%A9%E8%81%94%E7%BD%91%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%89%EF%BC%89STM32%E9%85%8D%E7%BD%AEESP8266%E4%BD%BF%E7%94%A8%20STA%20TCP%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fran Hawk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张竞豪的小岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/26/%E7%89%A9%E8%81%94%E7%BD%91%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%89%EF%BC%89STM32%E9%85%8D%E7%BD%AEESP8266%E4%BD%BF%E7%94%A8%20STA%20TCP%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%AD%A5/" class="post-title-link" itemprop="url">物联网项目设计（三）STM32配置ESP8266使用 STA TCP客户端模式初步</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2020-02-26 19:50:43" itemprop="dateCreated datePublished" datetime="2020-02-26T19:50:43+08:00">2020-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2021-08-13 10:01:01" itemprop="dateModified" datetime="2021-08-13T10:01:01+08:00">2021-08-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a><a target="_blank" rel="noopener" href="https://github.com/FranHawk/STM32_ESP8266_STA.git">代码地址</a></h1><p><a target="_blank" rel="noopener" href="https://github.com/FranHawk/STM32_ESP8266_STA.git">https://github.com/FranHawk/STM32_ESP8266_STA.git</a></p>
<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>本部分内容介绍如何使用STM32配置ESP8266使用STA模式，这个是使用MQTT与上层服务器链接的必要前提，笔者也是第一次使用ESP8266，通过AT指令来配置，查找了很多资料与代码，借鉴了正点原子ESP8266库和例程，在其基础上修改而来，这篇博客也是我边学边写的记录。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h1 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h1><ul>
<li>带有stm32主控的硬件一套</li>
<li>esp8266模块一个</li>
<li>路由器一个</li>
</ul>
<h1 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h1><ul>
<li>CubeMx用来配置工程</li>
<li>MDK5用于编写调试和下载代码</li>
</ul>
<h1 id="配置ESP8266的步骤"><a href="#配置ESP8266的步骤" class="headerlink" title="配置ESP8266的步骤"></a>配置ESP8266的步骤</h1><p>配置ESP8266的目的是为了进入透传模式从而使用MQTT链接网络，我们需要使用AT指令，使ESP8266进入透传模式，步骤如下<br>1.AT+CWMODE=1                         设置模块为STA模式<br>2.AT+CWAUTOCONN=0<br>|按顺序要执行指令|执行指令的意义  |<br>|–|–|<br>|<code>+++</code>|退出透传模式|<br>|<code>AE0</code>|关闭回显|<br>| <code>AT+CWMODE=1</code>      | 设置模块为STA模式 |<br>|<code>AT+RST</code>|重启生效|<br>|等待三秒|等待三秒|<br>|<code>AT+CWAUTOCONN=0</code>|取消自动连接|<br>|<code>AT+ CWJAP = &lt;ssid&gt;,&lt; password&gt;</code>|连接路由器|<br>|<code>AT+CIPMUX=0</code>|关闭多链接|<br>|<code>AT+CIPSTART=&quot;TCP&quot;,&quot;IP号&quot;,端口号</code>|连接到服务器|<br>|<code>AT+CIPMODE=1</code>|设置为透传模式|<br>|<code>AT+CIPSEND</code>|开启透传模式|</p>
<p>ESP8266的发送命令函数由正点原子的函数改进而来<br>STM32与ESP8266通过串口连接，需要配置的模块有</p>
<ul>
<li><strong>TIM2，定时器中断，用来判断接收命令是否超时，如果超时就按照接受命令，中断优先级为1</strong></li>
<li><strong>USART1，用于向电脑发送数据，便于调试</strong></li>
<li><strong>USART3，用于向ESP发送数据，包括发送和接受，采用中断方式接收，查询方式发送，中断优先级为2</strong></li>
<li><strong>整个发送命令并接收的流程比较复杂，用到了定时器中断来设置发送指令，接收到的回复是否完成，并在定时器中断中将接收指令的回复接受完成的标志位置为1，并且与预期回复进行比较。</strong></li>
<li><strong>这样发送命令并接收的整个流程的好处在于，可以保证发送指令的质量，得到准确的反馈。</strong></li>
<li><strong>就好像你向一个人说，你帮我倒杯水好吗，然后要等待他的回复，如果听到他说：好的。说明他听到了我们的命令，这个时候我们才能放心。</strong></li>
</ul>
<p> <img src="https://img-blog.csdnimg.cn/20200224182524264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<h1 id="实际操作部分"><a href="#实际操作部分" class="headerlink" title="实际操作部分"></a>实际操作部分</h1><h2 id="CubeMx配置工程"><a href="#CubeMx配置工程" class="headerlink" title="CubeMx配置工程"></a>CubeMx配置工程</h2><h3 id="配置工程就像我上面所述的步骤，需要配置相应的外设，两个串口和一个定时器"><a href="#配置工程就像我上面所述的步骤，需要配置相应的外设，两个串口和一个定时器" class="headerlink" title="配置工程就像我上面所述的步骤，需要配置相应的外设，两个串口和一个定时器"></a>配置工程就像我上面所述的步骤，需要配置相应的外设，两个串口和一个定时器</h3><p> 1.打开CubeMx，选择对应型号的芯片，始终选择外部晶振<br> <img src="https://img-blog.csdnimg.cn/20200224205748537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br> 2.查看原理图，选择相应的引脚<img src="https://img-blog.csdnimg.cn/20200224205936362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br> <img src="https://img-blog.csdnimg.cn/20200224205948715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br> 配置UART1，UART3，并设置波特率<br> <img src="https://img-blog.csdnimg.cn/20200224210256453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br> 设置定时器2，并开启定时器中断，分频为7200，重装值为500，这样，接收信息的缓冲时间为50ms<br> <img src="https://img-blog.csdnimg.cn/2020022421075060.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br> 设置中断分组与中断优先级<br> <img src="https://img-blog.csdnimg.cn/20200224210947109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<p> 配置时钟树，使主频最高为72MHZ<br> <img src="https://img-blog.csdnimg.cn/20200224211119317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br> 配置工程并生成代码<br> <img src="https://img-blog.csdnimg.cn/20200224211300805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<h2 id="编写ESP8266函数并添加配套函数"><a href="#编写ESP8266函数并添加配套函数" class="headerlink" title="编写ESP8266函数并添加配套函数"></a>编写ESP8266函数并添加配套函数</h2><h4 id="首先添加两个uart重定向printf函数和uart接收中断处理函数"><a href="#首先添加两个uart重定向printf函数和uart接收中断处理函数" class="headerlink" title="首先添加两个uart重定向printf函数和uart接收中断处理函数"></a>首先添加两个uart重定向printf函数和uart接收中断处理函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">u3_printf</span><span class="params">(<span class="keyword">char</span>* fmt,...)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	<span class="keyword">uint8_t</span> i,j; </span><br><span class="line">	va_list ap; </span><br><span class="line">	va_start(ap,fmt);</span><br><span class="line">	<span class="built_in">vsprintf</span>((<span class="keyword">char</span>*)USART3_TX_BUF,fmt,ap);</span><br><span class="line">	va_end(ap);</span><br><span class="line">	i=<span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)USART3_TX_BUF);		<span class="comment">//此次发送数据的长度</span></span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)							<span class="comment">//循环发送数据</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>((USART3-&gt;SR&amp;<span class="number">0X40</span>)==<span class="number">0</span>);			<span class="comment">//循环发送,直到发送完毕   </span></span><br><span class="line">		USART3-&gt;DR=USART3_TX_BUF[j];  </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">u1_printf</span><span class="params">(<span class="keyword">char</span>* fmt,...)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	<span class="keyword">uint8_t</span> i,j; </span><br><span class="line">	va_list ap; </span><br><span class="line">	va_start(ap,fmt);</span><br><span class="line">	<span class="built_in">vsprintf</span>((<span class="keyword">char</span>*)USART1_TX_BUF,fmt,ap);</span><br><span class="line">	va_end(ap);</span><br><span class="line">	i=<span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)USART1_TX_BUF);		<span class="comment">//此次发送数据的长度</span></span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)							<span class="comment">//循环发送数据</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>((USART1-&gt;SR&amp;<span class="number">0X40</span>)==<span class="number">0</span>);			<span class="comment">//循环发送,直到发送完毕   </span></span><br><span class="line">		USART3-&gt;DR=USART1_TX_BUF[j];  </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(huart-&gt;Instance==USART3)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">if</span>((USART3_RX_STA&amp;(<span class="number">1</span>&lt;&lt;<span class="number">15</span>))==<span class="number">0</span>)<span class="comment">//接收完的一批数据,还没有被处理,则不再接收其他数据</span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">if</span>(USART3_RX_STA&lt;USART3_MAX_RECV_LEN)	<span class="comment">//还可以接收数据</span></span><br><span class="line">			&#123;</span><br><span class="line">	 			__HAL_TIM_SET_COUNTER(&amp;htim2,<span class="number">0</span>);         				<span class="comment">//计数器清空	</span></span><br><span class="line">				<span class="keyword">if</span>(USART3_RX_STA==<span class="number">0</span>) 				<span class="comment">//使能定时器7的中断 </span></span><br><span class="line">				&#123;</span><br><span class="line">					__HAL_TIM_ENABLE(&amp;htim2);     			<span class="comment">//使能定时器2</span></span><br><span class="line">				&#125;</span><br><span class="line">				USART3_RX_BUF[USART3_RX_STA++]=temp_rx;	<span class="comment">//记录接收到的值	 </span></span><br><span class="line">			&#125;<span class="keyword">else</span> </span><br><span class="line">			&#123;</span><br><span class="line">				USART3_RX_STA|=<span class="number">1</span>&lt;&lt;<span class="number">15</span>;				<span class="comment">//强制标记接收完成</span></span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编写发送和检查命令核心函数"><a href="#编写发送和检查命令核心函数" class="headerlink" title="编写发送和检查命令核心函数"></a>编写发送和检查命令核心函数</h4><ul>
<li>创建esp8266.c esp8266.h并按照之前的流程图编写函数如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">esp8266_send_cmd</span><span class="params">(<span class="keyword">uint8_t</span> *cmd,<span class="keyword">uint8_t</span> *ack,<span class="keyword">uint16_t</span> waittime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint8_t</span> res = <span class="number">0</span>;</span><br><span class="line">	USART3_RX_STA = <span class="number">0</span>;</span><br><span class="line">	u3_printf(<span class="string">&quot;%s\r\n&quot;</span>,cmd);</span><br><span class="line">	<span class="keyword">if</span>(ack&amp;&amp;waittime)		<span class="comment">//需要等待应答</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(--waittime)	<span class="comment">//等待倒计时</span></span><br><span class="line">		&#123;</span><br><span class="line">			HAL_Delay(<span class="number">10</span>);</span><br><span class="line">			<span class="keyword">if</span>(USART3_RX_STA&amp;<span class="number">0X8000</span>)<span class="comment">//接收到期待的应答结果</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(esp8266_check_cmd(ack))</span><br><span class="line">				&#123;</span><br><span class="line">					u1_printf(<span class="string">&quot;ack:%s\r\n&quot;</span>,(<span class="keyword">uint8_t</span>*)ack);</span><br><span class="line">					<span class="keyword">break</span>;<span class="comment">//得到有效数据 </span></span><br><span class="line">				&#125;</span><br><span class="line">					USART3_RX_STA=<span class="number">0</span>;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(waittime==<span class="number">0</span>)res=<span class="number">1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span>* <span class="title">esp8266_check_cmd</span><span class="params">(<span class="keyword">uint8_t</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> *strx=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(USART3_RX_STA&amp;<span class="number">0X8000</span>)		<span class="comment">//接收到一次数据了</span></span><br><span class="line">	&#123; </span><br><span class="line">		</span><br><span class="line">		USART3_RX_BUF[USART3_RX_STA&amp;<span class="number">0X7FFF</span>]=<span class="number">0</span>;<span class="comment">//添加结束符</span></span><br><span class="line">		u1_printf(<span class="string">&quot;%s\r\n&quot;</span>,(<span class="keyword">char</span>*)USART3_RX_BUF);</span><br><span class="line">		strx=<span class="built_in">strstr</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)USART3_RX_BUF,(<span class="keyword">const</span> <span class="keyword">char</span>*)str);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">uint8_t</span>*)strx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在定时器文件中编写定时器中断服务函数"><a href="#在定时器文件中编写定时器中断服务函数" class="headerlink" title="在定时器文件中编写定时器中断服务函数"></a>在定时器文件中编写定时器中断服务函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(htim-&gt;Instance == TIM2)</span><br><span class="line">    &#123;</span><br><span class="line">		</span><br><span class="line">		USART3_RX_STA|=<span class="number">1</span>&lt;&lt;<span class="number">15</span>;	<span class="comment">//标记接收完成</span></span><br><span class="line">		__HAL_TIM_CLEAR_FLAG(&amp;htim2,TIM_EVENTSOURCE_UPDATE );       <span class="comment">//清除TIM7更新中断标志  </span></span><br><span class="line">		__HAL_TIM_DISABLE(&amp;htim2);     			<span class="comment">//关闭定时器2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="在esp8266-c中按照上面的表格编写esp8266的初始化函数"><a href="#在esp8266-c中按照上面的表格编写esp8266的初始化函数" class="headerlink" title="在esp8266.c中按照上面的表格编写esp8266的初始化函数"></a>在esp8266.c中按照上面的表格编写esp8266的初始化函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">esp8266_Connect_IOTServer</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u1_printf(<span class="string">&quot;准备配置模块\r\n&quot;</span>);</span><br><span class="line">	HAL_Delay(<span class="number">100</span>);</span><br><span class="line">	</span><br><span class="line">	u1_printf(<span class="string">&quot;准备退出透传模式\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(esp8266_quit_trans())</span><br><span class="line">	&#123;</span><br><span class="line">		u1_printf(<span class="string">&quot;退出透传模式失败，准备重启\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> u1_printf(<span class="string">&quot;退出透传模式成功\r\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	u1_printf(<span class="string">&quot;准备关闭回显\r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(esp8266_send_cmd(<span class="string">&quot;ATE0&quot;</span>,<span class="string">&quot;OK&quot;</span>,<span class="number">50</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		u1_printf(<span class="string">&quot;关闭回显失败准备重启\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> u1_printf(<span class="string">&quot;关闭回显成功\r\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	u1_printf(<span class="string">&quot;查询模块是否在线\r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(esp8266_send_cmd(<span class="string">&quot;AT&quot;</span>,<span class="string">&quot;OK&quot;</span>,<span class="number">50</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		u1_printf(<span class="string">&quot;模块不在线准备重启\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> u1_printf(<span class="string">&quot;设置查询在线成功\r\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	u1_printf(<span class="string">&quot;准备设置STA模式\r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(esp8266_send_cmd(<span class="string">&quot;AT+CWMODE=1&quot;</span>,<span class="string">&quot;OK&quot;</span>,<span class="number">50</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		u1_printf(<span class="string">&quot;设置STA模式失败准备重启\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> u1_printf(<span class="string">&quot;设置STA模式成功\r\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	u1_printf(<span class="string">&quot;准备重启\r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(esp8266_send_cmd(<span class="string">&quot;AT+RST&quot;</span>,<span class="string">&quot;OK&quot;</span>,<span class="number">50</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		u1_printf(<span class="string">&quot;重启失败，准备重启\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> u1_printf(<span class="string">&quot;重启成功，等待三秒\r\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">	HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">	HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">	HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">	</span><br><span class="line">	u1_printf(<span class="string">&quot;准备取消自动连接\r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(esp8266_send_cmd(<span class="string">&quot;AT+CWAUTOCONN=0&quot;</span>,<span class="string">&quot;OK&quot;</span>,<span class="number">50</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		u1_printf(<span class="string">&quot;取消自动连接失败，准备重启\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> u1_printf(<span class="string">&quot;取消自动连接成功\r\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	u1_printf(<span class="string">&quot;准备链接路由器\r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(esp8266_Connect_AP())</span><br><span class="line">	&#123;</span><br><span class="line">		u1_printf(<span class="string">&quot;连接路由器失败，等待重启\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> u1_printf(<span class="string">&quot;连接路由器成功\r\n&quot;</span>);</span><br><span class="line">	HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">	HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">	u1_printf(<span class="string">&quot;设置为关闭多路连接\r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(esp8266_send_cmd(<span class="string">&quot;AT+CIPMUX=0&quot;</span>,<span class="string">&quot;OK&quot;</span>,<span class="number">100</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		u1_printf(<span class="string">&quot;关闭多路连接失败，准备重启\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> u1_printf(<span class="string">&quot;设置关闭多路连接成功\r\n&quot;</span>);</span><br><span class="line">	u1_printf(<span class="string">&quot;准备链接服务器\r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(esp8266_Connect_Server())</span><br><span class="line">	&#123;</span><br><span class="line">		u1_printf(<span class="string">&quot;连接服务器失败，等待重启\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> u1_printf(<span class="string">&quot;连接服务器成功\r\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	u1_printf(<span class="string">&quot;准备退出透传模式\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(esp8266_quit_trans())</span><br><span class="line">	&#123;</span><br><span class="line">		u1_printf(<span class="string">&quot;退出透传模式失败，准备重启\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> u1_printf(<span class="string">&quot;退出透传模式成功\r\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	u1_printf(<span class="string">&quot;设置为透传模式\r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(esp8266_send_cmd(<span class="string">&quot;AT+CIPMODE=1&quot;</span>,<span class="string">&quot;OK&quot;</span>,<span class="number">50</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		u1_printf(<span class="string">&quot;设置透传失败，准备重启\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> u1_printf(<span class="string">&quot;设置透传成功\r\n&quot;</span>);</span><br><span class="line">	u1_printf(<span class="string">&quot;设置开启透传模式\r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(esp8266_send_cmd(<span class="string">&quot;AT+CIPSEND&quot;</span>,<span class="string">&quot;OK&quot;</span>,<span class="number">1000</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		u1_printf(<span class="string">&quot;开启透传失败，准备重启\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> u1_printf(<span class="string">&quot;开启透传成功\r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">		<span class="comment">//esp8266_send_cmd(&quot;AT+CIPSEND&quot;,&quot;OK&quot;,200);  //发送指定长度的数据</span></span><br><span class="line">		u3_printf(<span class="string">&quot;This is a message\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在主函数中初始化相应模块并调用esp8266的初始化函数"><a href="#在主函数中初始化相应模块并调用esp8266的初始化函数" class="headerlink" title="在主函数中初始化相应模块并调用esp8266的初始化函数"></a>在主函数中初始化相应模块并调用esp8266的初始化函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">	  </span><br><span class="line">	  esp8266_Connect_IOTServer();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="观察实验现象"><a href="#观察实验现象" class="headerlink" title="观察实验现象"></a>观察实验现象</h1><ul>
<li>打开网络调试助手，调整到TCP服务器模式，并记下此时的ip地址和端口号</li>
<li>打开串口调试助手</li>
<li>打开开发板观察现象</li>
</ul>
<p>下面是串口调试助手的消息<br><img src="https://img-blog.csdnimg.cn/20200226175511622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20200226175525381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>上面的图就是进入透传模式的过程，整个过程的AT指令是按照本文章最上面的表格来设置的，观察网络调试助手观察现象<br><img src="https://img-blog.csdnimg.cn/20200226180200798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>发现进入透传模式之后的数据成功发送到服务器端，试验成功。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本部分内容介绍了如何使STM32使用串口与ESP8266进行通讯，并且配置ESP8266进入TCP客户端的透传模式链接服务器，下一部分内容不出意外的话应该是介绍如何使STM32使用paho的开源MQTT库连接到百度云天工服务器</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/24/%E7%89%A9%E8%81%94%E7%BD%91%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89%20MQTT.fx%E4%B8%8E%E7%99%BE%E5%BA%A6%E4%BA%91%E5%A4%A9%E5%B7%A5%20IOT%20hub%20%E7%9A%84%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fran Hawk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张竞豪的小岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/24/%E7%89%A9%E8%81%94%E7%BD%91%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89%20MQTT.fx%E4%B8%8E%E7%99%BE%E5%BA%A6%E4%BA%91%E5%A4%A9%E5%B7%A5%20IOT%20hub%20%E7%9A%84%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95/" class="post-title-link" itemprop="url">物联网项目设计（二） MQTT.fx与百度云天工 IOT hub 的连接调试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2020-02-24 19:50:43" itemprop="dateCreated datePublished" datetime="2020-02-24T19:50:43+08:00">2020-02-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2021-08-13 10:01:01" itemprop="dateModified" datetime="2021-08-13T10:01:01+08:00">2021-08-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><ul>
<li>介绍如何使用MQTT.fx调试工具与百度云天工物联网服务器之间，通过MQTT协议进行通讯。</li>
<li>这部分内容属于服务器端与设备端之间的通讯，MQTT是之后用于手机，服务器，嵌入式物联网设备主要用于通讯的应用层协议，也是MQTT协议的开篇，之后肯定要学习MQTT更多相关的知识</li>
<li> 该部分假设读者对MQTT有入门级的了解。如果不了解也可以参看下文中的百度云天工的指南</li>
</ul>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul>
<li>电脑已安装JAVA运行环境，如何安装请自行百度</li>
<li>MQTT.fx调试软件，该软件是MQTT主流的调试软件，软件安装方法可参照<a target="_blank" rel="noopener" href="https://blog.csdn.net/Mculover666/article/details/103799033">这篇博客</a></li>
</ul>
<h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul>
<li>可联网的电脑一台</li>
</ul>
<h2 id="操作部分"><a href="#操作部分" class="headerlink" title="操作部分"></a>操作部分</h2><p>百度云天工的手册写的非常细致，对MQTT的介绍也很详细。我下面的所有操作都是根据官方指南和他人博客而成的<br> <a target="_blank" rel="noopener" href="https://cloud.baidu.com/doc/IOT/s/5jwvy6tdd">官方文档</a><br> <a target="_blank" rel="noopener" href="https://blog.csdn.net/Mculover666/article/details/103803859">参考博客</a></p>
<p>访问百度云天工物联网平台首页，<a target="_blank" rel="noopener" href="https://cloud.baidu.com/solution/iot/index.html">官网链接在这</a>注册或登录，进入平台。在左侧选择物接入<br><img src="https://img-blog.csdnimg.cn/20200223230058244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>只有开通了计费服务才能进入下一步的配置，关于计费，开发使用的话，有一定的免费额度，平时开发肯定是够用了<br><img src="https://img-blog.csdnimg.cn/20200223230222689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>点击创建项目，设备项目分为两种，设备型项目和数据型项目，设备型项目允许创建一个，数据型设备允许创建9个。两者区别在于设备型项目适用于大多数情况，自动配置数据库，可添加话题等等。数据型项目可以使用户完成定制化的服务，当然也更难配置，一般情况下使用设备型项目就可以了。关于两者介绍请看天工官网。<br><img src="https://img-blog.csdnimg.cn/20200223230845371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20200223230904753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>上图中，输入相关信息即可创建设备型项目。<br><img src="https://img-blog.csdnimg.cn/20200223231642340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>然后新建一个物模型，可以看到还有一个物影子，物模型和物影子之间的关系就如C++里面类和实例的关系，物影子就是物模型的实例。物影子是实际的嵌入式设备在云端的映射，代码设置合理的情况下，通过操作云端的物影子就可以操作实际的物联网设备。<br><img src="https://img-blog.csdnimg.cn/20200223231921453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>上图是物模型的配置界面，在配置界面中需要添加物模型的属性，这些属性是用来操作物影子的相关功能的。<br><img src="https://img-blog.csdnimg.cn/20200223232220793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>配置一个物模型的属性如上图<br><img src="https://img-blog.csdnimg.cn/20200223232301874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>物模型创建好之后就可以创建一个物影子<img src="https://img-blog.csdnimg.cn/20200223232342700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>创建物影子的时候要设置相应的物模型，这个地方存储配置先不勾选，这个是用来配置是否使用时序数据库的，这个地方暂时用不到。<br><img src="https://img-blog.csdnimg.cn/20200223232500602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>每一个物影子都有相应的访问网址和用户名和密码，这个是物联网设备端与云端通讯时必备的信息。必须妥善保存，待会我们也会用到。<br><img src="https://img-blog.csdnimg.cn/20200223232639619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<p>创建好物影子后我们就可以看到，如果想访问物影子或者控制物联网设备的话，我们就需要订阅相关的话题，或者发布相关的话题，上图列出了基本的话题。</p>
<p><img src="https://img-blog.csdnimg.cn/20200223233158936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>打开mqtt.fx,按照上图进行配置，不过密码什么的要改成自己的，这些信息就是刚刚创建物影子时生成的信息。<br><img src="https://img-blog.csdnimg.cn/20200223233327687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<p>创建好后点击Connect，如果界面右侧的绿灯亮起，则说明链接成功，这时候打开云天工，发现对应的物影子上面的灯也亮了，说明使用mqtt.fx链接云天工成功。</p>
<p><img src="https://img-blog.csdnimg.cn/20200223233535707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<p>如上图，点击subscrib，根据物影子上的信息，我们先订阅两个话题，话题名称如下图所示，需要在物影子里面找<br><img src="https://img-blog.csdnimg.cn/20200223233610829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>订阅的话题</p>
<ul>
<li>$baidu/iot/shadow/Smart_light_001/update/accepted</li>
<li>$baidu/iot/shadow/Smart_light_001/update/rejected</li>
</ul>
<p>要发布的话题</p>
<ul>
<li>$baidu/iot/shadow/Smart_light_001/update</li>
</ul>
<p>Smart_light_001是我创建的物影子，然后我们需要向这个话题发布消息，这个发布动作无论成功与否，刚刚我们订阅的话题中至少有一个会收到反馈消息。</p>
<p>mqtt传输的消息格式采用json格式，在发送的过程中，我们不需要自己写这种格式，只需要查看物影子的模型数据，编辑，给这个物影子的属性一个初始值。然后打开原始数据，就可以找到发送数据的数据格式。<br><img src="https://img-blog.csdnimg.cn/20200224084640480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<p>打开pubilish，向指定话题发布消息<img src="https://img-blog.csdnimg.cn/20200224084740591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20200224085312655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>订阅的话题</p>
<ul>
<li>$baidu/iot/shadow/Smart_light_001/update/accepted<br>收到了消息，说明发送成功<br><img src="https://img-blog.csdnimg.cn/20200224085431670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></li>
</ul>
<p>接下来在模型数据的地方进行编辑，更改物影子属性的期望值，先不要点确定。然后再MQTT.fx中订阅指定话题。</p>
<ul>
<li>$baidu/iot/shadow/Smart_light_001/delta<br><img src="https://img-blog.csdnimg.cn/20200224085554161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>在物影子属性模型数据处点确定，会发现我们刚刚订阅的话题收到了一条消息。<img src="https://img-blog.csdnimg.cn/20200224085759451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>这就是实现了云端对物联网设备的控制。</li>
</ul>
<h3 id="至此，我们实现了MQTT-fx和天工云服务器的双向数据传输，这样的方法不仅适用于天工云，还适用于所有使用MQTT的云服务器"><a href="#至此，我们实现了MQTT-fx和天工云服务器的双向数据传输，这样的方法不仅适用于天工云，还适用于所有使用MQTT的云服务器" class="headerlink" title="至此，我们实现了MQTT.fx和天工云服务器的双向数据传输，这样的方法不仅适用于天工云，还适用于所有使用MQTT的云服务器"></a>至此，我们实现了MQTT.fx和天工云服务器的双向数据传输，这样的方法不仅适用于天工云，还适用于所有使用MQTT的云服务器</h3><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这部分内容介绍了如何使用windows端的MQTT.fx与云服务器进行通讯，但这个只能算是调试，最终还是要使用嵌入式设备连接云服务器，预计下一部分要做的工作就是这个，笔者还属于新手，这些东西要慢慢掌握</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="الصفحة السابقة"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="الصفحة التالية"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          المحتويات
        </li>
        <li class="sidebar-nav-overview">
          عام
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fran Hawk</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">المقالات</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">الوسوم</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fran Hawk</span>
</div>
  <div class="powered-by">تطبيق الموقع <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
