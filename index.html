<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="张竞豪的小岛">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="张竞豪的小岛">
<meta property="og:locale">
<meta property="article:author" content="Fran Hawk">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'cn'
  };
</script>

  <title>张竞豪的小岛</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Navigationsleiste an/ausschalten">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">张竞豪的小岛</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Startseite</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archiv</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/17/%E5%9F%BA%E4%BA%8Earduino%E7%9A%84ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%20TFT_eSPI%E5%92%8CLVGL%E5%BA%93%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fran Hawk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张竞豪的小岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/17/%E5%9F%BA%E4%BA%8Earduino%E7%9A%84ESP32%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%20TFT_eSPI%E5%92%8CLVGL%E5%BA%93%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">基于arduino的ESP32 学习笔记（二） TFT_eSPI和LVGL库使用笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              

              <time title="Erstellt: 2021-08-17 19:50:43 / Geändert am: 20:19:39" itemprop="dateCreated datePublished" datetime="2021-08-17T19:50:43+08:00">2021-08-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文的目的是为了给将要制作的ESP32手环做技术储备</p>
<p>记录基于arduino的ESP32驱动TFT-LCD屏幕的配置过程，并且进一步使用LVGL这个GUI框架</p>
<h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul>
<li><p>ST7789 240x240 1.3寸 SPI接口LCD屏 16位色深RGB565</p>
</li>
<li><p>ESP-WROOM-32E开发板</p>
</li>
<li><p>ESP32的数据手册链接 <a target="_blank" rel="noopener" href="https://download.csdn.net/download/weixin_42487906/21119656">https://download.csdn.net/download/weixin_42487906/21119656</a></p>
</li>
</ul>
<h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul>
<li>Arduino 1.8.9</li>
</ul>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>LVGL移植到arduino的官方文档 <a target="_blank" rel="noopener" href="https://docs.lvgl.io/7.11/get-started/arduino.html#get-the-lvgl-ardunio-library">https://docs.lvgl.io/7.11/get-started/arduino.html#get-the-lvgl-ardunio-library</a></p>
<p>TFT_eSPI github仓库 <a target="_blank" rel="noopener" href="https://github.com/Bodmer/TFT_eSPI">https://github.com/Bodmer/TFT_eSPI</a></p>
<p>相关博客 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44007534/article/details/113653031?spm=1001.2014.3001.5501">https://blog.csdn.net/weixin_44007534/article/details/113653031?spm=1001.2014.3001.5501</a></p>
<p>LVGL移植到arduino的官方文档里提到LVGL在arduino运行是基于TFT_eSPI库，所以我们先配置TFT_eSPI库</p>
<h1 id="TFT-eSPI库配置"><a href="#TFT-eSPI库配置" class="headerlink" title="TFT_eSPI库配置"></a>TFT_eSPI库配置</h1><p>在库管理器下载TFT_eSPI库</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210817154706690.png" alt="image-20210817154706690" style="zoom: 67%;" />

<p>安装好后不能直接用，需要针对自己使用的LCD来完成配置</p>
<p>安装好的库通常在 C:\Users\Alpha\Documents\Arduino\libraries  Alpha是我的用户名</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210817144251670.png" alt="image-20210817140527617" style="zoom:80%;" />

<p>进入TFT_eSPI库文件夹，打开User_Setup_select.h</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210817155022840.png" alt="image-20210817155022840" style="zoom:50%;" />

<p>注释掉User_Setup.h头文件，同时找到适合自己屏幕的头文件，解开他的注释</p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210817155132689.png" alt="image-20210817155132689"></p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210817155107439.png" alt="image-20210817155107439"></p>
<p>最终效果如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;User_Setup.h&gt;           // Default setup is root library folder</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;User_Setups/Setup24_ST7789.h&gt;</span>            <span class="comment">// Setup file configured for ST7789 240 x 240</span></span></span><br></pre></td></tr></table></figure>

<p>然后还要进到Setup24_ST7789.h，完成引脚更改。根据开发板的数据手册，MOSI设置为IO23引脚，也就是VSPID，SCLK设置为IO18引脚，也就是VSPICLK，其他脚接到一般的IO上就行，记得RST引脚一定记得接到板子的引脚上不能省，LCD的BLK背光控制引脚可以不用接悬空。剩下一些字库的配置暂时不管</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210817194611495.png" alt="image-20210817194611495" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210817190336018.png" alt="image-20210817190336018" style="zoom:50%;" />

<p>完成硬件上的接线，除了MOSI,SCLK,DC,RST外还要接VCC,GND总共6条线</p>
<p>然后在tft_espi的示例代码中找到boing_ball示例程序，别的示例程序也可以，来做个测试，这个程序虽然是320*240的但是也能在我们的屏幕上用，编译下载观察现象</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210817190312536.png" alt="image-20210817190312536" style="zoom:50%;" />

<p>可以看到屏幕正常显示</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210817195203295.png" alt="image-20210817195203295" style="zoom:67%;" />

<h1 id="LVGL库配置"><a href="#LVGL库配置" class="headerlink" title="LVGL库配置"></a>LVGL库配置</h1><p>在库管理器中安装lvgl和lv_examples,保险起见我安装的是7.6.0版本</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210817143010859.png" alt="image-20210817143010859" style="zoom:67%;" />

<p>下面根据，LVGL移植到arduino的官方文档完成配置</p>
<h2 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h2><p>下图，官方文档让我们进到库所在文件夹里，把lv_conf_template.h从lvgl文件夹里拿出来放到与lvgl同级的文件夹里，并改名为lv_conf.h</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210817144235394.png" alt="image-20210817144235394" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210817144345002.png" alt="image-20210817144345002" style="zoom:50%;" />

<p>最终的效果如下图</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210817151254582.png" alt="image-20210817151254582" style="zoom:50%;" />

<p>打开lv_conf.h,将LV_TICK_CUSTOM设为1</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210817145630538.png" alt="image-20210817145630538" style="zoom:67%;" />

<p>把分辨率和色深改成自己屏幕的，将最上面的#if 0改成#if 1</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210817145646292.png" alt="image-20210817145646292" style="zoom:67%;" />

<h2 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h2><p>将lv_examples文件夹中lv_ex_conf_template.h拿出来放到与lv_exmaples文件夹同级的文件夹中，也就是libraries文件夹中，并改名为lv_ex_conf.h</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210817151439664.png" alt="image-20210817151439664" style="zoom: 67%;" />

<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210817151508376.png" alt="image-20210817151508376" style="zoom: 67%;" />

<p>最终效果如下图</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210817151624179.png" alt="image-20210817151624179" style="zoom:67%;" />

<p>修改 lv_ex_conf.h 中内容，将#if 0 改为 #if 1</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210817151548808.png" alt="image-20210817151548808" style="zoom:67%;" />



<p>根据官方文档，找到LVGL_Arduino.ino,打开这个工程</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210817152023751.png" alt="image-20210817152023751" style="zoom:67%;" />

<p>打开工程后，提示建立同名文件夹，建立后重启arduino就可以看到lvgl的示例了</p>
<p>示例工程LVGL_Arduino.ino中也有包含触摸屏的部分，本文用不到，就将其删去</p>
<p>注意要加入#include &lt;lv_examples.h&gt;，不然示例程序会报错，示例程序是以函数的形式出现的lv_ex_btn_1();</p>
<p>还有最后的loop中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> last_time = millis();</span><br><span class="line">    lv_task_handler(); <span class="comment">/* let the GUI do its work */</span></span><br><span class="line">    delay(<span class="number">5</span>);</span><br><span class="line">    lv_tick_inc(<span class="keyword">int</span>(millis()-last_time));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原本是这样的，但是参考一些博客后，按照上面代码方式改，可以保证lvgl的获得的执行时间是准确的，理论上lv_tick_inc()执行的间隔实践会决定LVGL刷屏的最大帧率</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lv_task_handler(); <span class="comment">/* let the GUI do its work */</span></span><br><span class="line">    delay(<span class="number">5</span>);</span><br><span class="line">    lv_tick_inc(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是工程的所有代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;lvgl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;lv_examples.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TFT_eSPI.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">TFT_eSPI tft = TFT_eSPI(); <span class="comment">/* TFT instance */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">lv_disp_buf_t</span> disp_buf;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">lv_color_t</span> buf[LV_HOR_RES_MAX * <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_LV_LOG != 0</span></span><br><span class="line"><span class="comment">/* Serial debugging */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_print</span><span class="params">(<span class="keyword">lv_log_level_t</span> level, <span class="keyword">const</span> <span class="keyword">char</span> * file, <span class="keyword">uint32_t</span> line, <span class="keyword">const</span> <span class="keyword">char</span> * dsc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;%s@%d-&gt;%s\r\n&quot;</span>, file, line, dsc);</span><br><span class="line">    Serial.flush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Display flushing */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_disp_flush</span><span class="params">(<span class="keyword">lv_disp_drv_t</span> *disp, <span class="keyword">const</span> <span class="keyword">lv_area_t</span> *area, <span class="keyword">lv_color_t</span> *color_p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> w = (area-&gt;x2 - area-&gt;x1 + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> h = (area-&gt;y2 - area-&gt;y1 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    tft.startWrite();</span><br><span class="line">    tft.setAddrWindow(area-&gt;x1, area-&gt;y1, w, h);</span><br><span class="line">    tft.pushColors(&amp;color_p-&gt;full, w * h, <span class="literal">true</span>);</span><br><span class="line">    tft.endWrite();</span><br><span class="line"></span><br><span class="line">    lv_disp_flush_ready(disp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Serial.begin(<span class="number">115200</span>); <span class="comment">/* prepare for possible serial debug */</span></span><br><span class="line"></span><br><span class="line">    lv_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_LV_LOG != 0</span></span><br><span class="line">    lv_log_register_print_cb(my_print); <span class="comment">/* register print function for debugging */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    tft.begin(); <span class="comment">/* TFT init */</span></span><br><span class="line">    tft.setRotation(<span class="number">1</span>); <span class="comment">/* Landscape orientation */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    lv_disp_buf_init(&amp;disp_buf, buf, <span class="literal">NULL</span>, LV_HOR_RES_MAX * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Initialize the display*/</span></span><br><span class="line">    <span class="keyword">lv_disp_drv_t</span> disp_drv;</span><br><span class="line">    lv_disp_drv_init(&amp;disp_drv);</span><br><span class="line">    disp_drv.hor_res = <span class="number">240</span>;</span><br><span class="line">    disp_drv.ver_res = <span class="number">240</span>;</span><br><span class="line">    disp_drv.flush_cb = my_disp_flush;</span><br><span class="line">    disp_drv.buffer = &amp;disp_buf;</span><br><span class="line">    lv_disp_drv_register(&amp;disp_drv);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Try an example from the lv_examples repository</span></span><br><span class="line"><span class="comment">		 * https://github.com/lvgl/lv_examples */</span></span><br><span class="line">		lv_ex_btn_1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> last_time = millis();</span><br><span class="line">    lv_task_handler(); <span class="comment">/* let the GUI do its work */</span></span><br><span class="line">    delay(<span class="number">5</span>);</span><br><span class="line">    lv_tick_inc(<span class="keyword">int</span>(millis()-last_time));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/13/RT-Thread%20ART-PI%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%BD%BB%E9%87%8F%E5%8C%96GUI%E6%A1%86%E6%9E%B6LVGL%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fran Hawk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张竞豪的小岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/13/RT-Thread%20ART-PI%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%BD%BB%E9%87%8F%E5%8C%96GUI%E6%A1%86%E6%9E%B6LVGL%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">RT-Thread ART-PI 学习笔记：轻量化GUI框架LVGL的使用和配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              <time title="Erstellt: 2021-08-13 19:50:43" itemprop="dateCreated datePublished" datetime="2021-08-13T19:50:43+08:00">2021-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2021-08-16 21:38:42" itemprop="dateModified" datetime="2021-08-16T21:38:42+08:00">2021-08-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文记录RT-Thread官方开发板ART-PI配置和使用LVGL图形库的过程</p>
<p>旨在以ART-PI学习LVGL，但是在配置的过程中遇到不少问题，ART-PI对LVGL的适配并没有TOUCHGFX那么好，还存在不少问题，其中一些还有待解决</p>
<p>以这篇博客作为记录配置和使用过程，之后有时间会完善这篇博客</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://club.rt-thread.org/ask/article/2464.html">https://club.rt-thread.org/ask/article/2464.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_37127273/article/details/110134225">https://blog.csdn.net/weixin_37127273/article/details/110134225</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e01bf5b628bc">https://www.jianshu.com/p/e01bf5b628bc</a></p>
<h1 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h1><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813111840289.png" alt="image-20210813111840289" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813112836674.png" alt="image-20210813112836674" style="zoom:67%;" />

<img src="C:/Users/Alpha/AppData/Roaming/Typora/typora-user-images/image-20210813113945181.png" alt="image-20210813113945181" style="zoom:33%;" />

<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813114505991.png" alt="image-20210813114505991" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813114524630.png" alt="image-20210813114524630" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813114849205.png" alt="image-20210813114849205" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813115623593.png" alt="image-20210813115623593" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813120135440.png" alt="image-20210813120135440" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813142506705.png" alt="image-20210813142506705" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813142621201.png" alt="image-20210813142621201" style="zoom: 80%;" />



<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813144052366.png" alt="image-20210813144052366"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/RT-Thread-Studio/sdk-bsp-stm32h750-realthread-artpi/blob/master/documents/board/ART-Pi_HW_V1.5/ART-Pi_SCH_V1.5_Release.pdf">https://github.com/RT-Thread-Studio/sdk-bsp-stm32h750-realthread-artpi/blob/master/documents/board/ART-Pi_HW_V1.5/ART-Pi_SCH_V1.5_Release.pdf</a></p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813145319027.png" alt="image-20210813145319027"></p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813145336358.png" alt="image-20210813145336358"></p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813150213630.png" alt="image-20210813150213630"></p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813150253189.png" alt="image-20210813150253189"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;drv_common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GT9147_IRQ_PIN GET_PIN(G,12)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GT9147_RST_PIN GET_PIN(D,3)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rt_hw_gt9147_port</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_touch_config</span> <span class="title">config</span>;</span></span><br><span class="line">    <span class="keyword">rt_uint8_t</span> rst;</span><br><span class="line"></span><br><span class="line">    rst = GT9147_RST_PIN;</span><br><span class="line">    config.dev_name = <span class="string">&quot;i2c1&quot;</span>;</span><br><span class="line">    config.irq_pin.pin  = GT9147_IRQ_PIN;</span><br><span class="line">    config.irq_pin.mode = PIN_MODE_INPUT_PULLDOWN;</span><br><span class="line">    config.user_data = &amp;rst;</span><br><span class="line"></span><br><span class="line">    rt_hw_gt9147_init(<span class="string">&quot;gt&quot;</span>, &amp;config);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">INIT_DEVICE_EXPORT(rt_hw_gt9147_port);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813150415372.png" alt="image-20210813150415372"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gt9147_sample(<span class="string">&quot;gt&quot;</span>,<span class="number">800</span>,<span class="number">480</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INIT_APP_EXPORT(touch_init);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813151036707.png" alt="image-20210813151036707"></p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813151635140.png" alt="image-20210813151635140"></p>
<p><strong>别忘了加头文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;littlevgl2rtt.h&quot;</span><br><span class="line"></span><br><span class="line">#define TOUCH_LCD_WIDTH  800</span><br><span class="line">#define TOUCH_LCD_HEIGHT 480</span><br><span class="line"></span><br><span class="line">static void gt9147_entry(void *parameter)</span><br><span class="line">&#123;</span><br><span class="line">    uint16_t x;</span><br><span class="line">    uint16_t y;</span><br><span class="line">    </span><br><span class="line">    rt_device_control(dev, RT_TOUCH_CTRL_GET_INFO, &amp;info);</span><br><span class="line"></span><br><span class="line">    read_data = (struct rt_touch_data *)rt_malloc(sizeof(struct rt_touch_data) * info.point_num);</span><br><span class="line"></span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_sem_take(gt9147_sem, RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line">        if (rt_device_read(dev, 0, read_data, info.point_num) == info.point_num)</span><br><span class="line">        &#123;</span><br><span class="line">            for (rt_uint8_t i = 0; i &lt; info.point_num; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                x = TOUCH_LCD_WIDTH-(uint16_t)read_data[i].x_coordinate;</span><br><span class="line">                y = TOUCH_LCD_HEIGHT-(uint16_t)read_data[i].y_coordinate;</span><br><span class="line">                littlevgl2rtt_send_input_event(x,y,read_data[i].event);</span><br><span class="line">                if (read_data[i].event == RT_TOUCH_EVENT_DOWN || read_data[i].event == RT_TOUCH_EVENT_MOVE)</span><br><span class="line">                &#123;</span><br><span class="line">//                    rt_kprintf(&quot;%d %d %d %d %d\n&quot;, read_data[i].track_id,</span><br><span class="line">//                               read_data[i].x_coordinate,</span><br><span class="line">//                               read_data[i].y_coordinate,</span><br><span class="line">//                               read_data[i].timestamp,</span><br><span class="line">//                               read_data[i].width);</span><br><span class="line">                    rt_kprintf(&quot;(%d,%d)\n&quot;,x,y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rt_device_control(dev, RT_TOUCH_CTRL_ENABLE_INT, RT_NULL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813152856907.png" alt="image-20210813152856907"></p>
<p><strong>下面是启用DMA2D提高LVGL的屏幕刷新率，但是最后出现白屏的现象不知道为什么，有待解决</strong></p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813163527495.png" alt="image-20210813163527495"></p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813172902373.png" alt="image-20210813172902373"></p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813173029874.png" alt="image-20210813173029874"></p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813173400190.png" alt="image-20210813173400190"></p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813173601592.png" alt="image-20210813173601592"></p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813173623234.png" alt="image-20210813173623234"></p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813173640673.png" alt="image-20210813173640673"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief DMA2D MSP Initialization</span></span><br><span class="line"><span class="comment">* This function configures the hardware resources used in this example</span></span><br><span class="line"><span class="comment">* @param hdma2d: DMA2D handle pointer</span></span><br><span class="line"><span class="comment">* @retval None</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_DMA2D_MspInit</span><span class="params">(DMA2D_HandleTypeDef* hdma2d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(hdma2d-&gt;Instance==DMA2D)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN DMA2D_MspInit 0 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END DMA2D_MspInit 0 */</span></span><br><span class="line">    <span class="comment">/* Peripheral clock enable */</span></span><br><span class="line">    __HAL_RCC_DMA2D_CLK_ENABLE();</span><br><span class="line">    <span class="comment">/* DMA2D interrupt Init */</span></span><br><span class="line">    HAL_NVIC_SetPriority(DMA2D_IRQn, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    HAL_NVIC_EnableIRQ(DMA2D_IRQn);</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN DMA2D_MspInit 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END DMA2D_MspInit 1 */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief DMA2D MSP De-Initialization</span></span><br><span class="line"><span class="comment">* This function freeze the hardware resources used in this example</span></span><br><span class="line"><span class="comment">* @param hdma2d: DMA2D handle pointer</span></span><br><span class="line"><span class="comment">* @retval None</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_DMA2D_MspDeInit</span><span class="params">(DMA2D_HandleTypeDef* hdma2d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(hdma2d-&gt;Instance==DMA2D)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN DMA2D_MspDeInit 0 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END DMA2D_MspDeInit 0 */</span></span><br><span class="line">    <span class="comment">/* Peripheral clock disable */</span></span><br><span class="line">    __HAL_RCC_DMA2D_CLK_DISABLE();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* DMA2D interrupt DeInit */</span></span><br><span class="line">    HAL_NVIC_DisableIRQ(DMA2D_IRQn);</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN DMA2D_MspDeInit 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END DMA2D_MspDeInit 1 */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813190103577.png" alt="image-20210813190103577"></p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813190324367.png" alt="image-20210813190324367"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">DMA2D_HandleTypeDef hdma2d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MX_DMA2D_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN DMA2D_Init 0 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END DMA2D_Init 0 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN DMA2D_Init 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END DMA2D_Init 1 */</span></span><br><span class="line">  hdma2d.Instance = DMA2D;</span><br><span class="line">  hdma2d.Init.Mode = DMA2D_M2M;</span><br><span class="line">  hdma2d.Init.ColorMode = DMA2D_OUTPUT_RGB565;</span><br><span class="line">  hdma2d.Init.OutputOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  hdma2d.LayerCfg[<span class="number">1</span>].InputOffset = <span class="number">0</span>;</span><br><span class="line">  hdma2d.LayerCfg[<span class="number">1</span>].InputColorMode = DMA2D_INPUT_RGB565;</span><br><span class="line">  hdma2d.LayerCfg[<span class="number">1</span>].AlphaMode = DMA2D_NO_MODIF_ALPHA;</span><br><span class="line">  hdma2d.LayerCfg[<span class="number">1</span>].InputAlpha = <span class="number">0</span>;</span><br><span class="line">  hdma2d.LayerCfg[<span class="number">1</span>].AlphaInverted = DMA2D_REGULAR_ALPHA;</span><br><span class="line">  hdma2d.LayerCfg[<span class="number">1</span>].RedBlueSwap = DMA2D_RB_REGULAR;</span><br><span class="line">  hdma2d.LayerCfg[<span class="number">1</span>].ChromaSubSampling = DMA2D_NO_CSS;</span><br><span class="line">  <span class="keyword">if</span> (HAL_DMA2D_Init(&amp;hdma2d) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (HAL_DMA2D_ConfigLayer(&amp;hdma2d, <span class="number">1</span>) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN DMA2D_Init 2 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END DMA2D_Init 2 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813190435208.png" alt="image-20210813190435208"></p>
<p>drv_lcd_hw_init()</p>
<p>littlevgl2rtt_init</p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813192314323.png" alt="image-20210813192314323"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lv_color_t</span> *buf1 = rt_malloc(<span class="keyword">sizeof</span>(<span class="keyword">lv_color_t</span>)*LV_HOR_RES_MAX*LV_VER_RES_MAX);</span><br><span class="line">rt_memset(buf1, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">lv_color_t</span>)*LV_HOR_RES_MAX*LV_VER_RES_MAX);</span><br><span class="line"></span><br><span class="line"><span class="keyword">lv_color_t</span> *buf2 = rt_malloc(<span class="keyword">sizeof</span>(<span class="keyword">lv_color_t</span>)*LV_HOR_RES_MAX*LV_VER_RES_MAX);</span><br><span class="line">rt_memset(buf2, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">lv_color_t</span>)*LV_HOR_RES_MAX*LV_VER_RES_MAX);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210813192519216.png" alt="image-20210813192519216"></p>
<p>``</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/07/%E5%9F%BA%E4%BA%8ERT-Thread%E7%9A%84CAN%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E6%9D%BF%E8%AE%BE%E8%AE%A1%20(%E4%BA%94)%20%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fran Hawk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张竞豪的小岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/07/%E5%9F%BA%E4%BA%8ERT-Thread%E7%9A%84CAN%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E6%9D%BF%E8%AE%BE%E8%AE%A1%20(%E4%BA%94)%20%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">基于RT-Thread的CAN电机驱动板设计 （五）文章汇总</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              <time title="Erstellt: 2021-06-07 19:50:43" itemprop="dateCreated datePublished" datetime="2021-06-07T19:50:43+08:00">2021-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2021-08-13 09:58:54" itemprop="dateModified" datetime="2021-08-13T09:58:54+08:00">2021-08-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42487906/article/details/117524353">基于RT-Thread的CAN电机驱动板设计 （一）需求分析与硬件设计</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42487906/article/details/117560534">基于RT-Thread的CAN电机驱动板设计 （二）uart串口DMA的实现</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42487906/article/details/117589085">基于RT-Thread的CAN电机驱动板设计 （三）CAN驱动配置与实现</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42487906/article/details/117600115">基于RT-Thread的CAN电机驱动板设计 （四）使用PIN设备配置按键中断实现电机启停</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/07/%E5%9F%BA%E4%BA%8ERT-Thread%E7%9A%84CAN%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E6%9D%BF%E8%AE%BE%E8%AE%A1%20%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BD%BF%E7%94%A8PIN%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE%E6%8C%89%E9%94%AE%E4%B8%AD%E6%96%AD%E5%AE%9E%E7%8E%B0%E7%94%B5%E6%9C%BA%E5%90%AF%E5%81%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fran Hawk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张竞豪的小岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/07/%E5%9F%BA%E4%BA%8ERT-Thread%E7%9A%84CAN%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E6%9D%BF%E8%AE%BE%E8%AE%A1%20%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BD%BF%E7%94%A8PIN%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE%E6%8C%89%E9%94%AE%E4%B8%AD%E6%96%AD%E5%AE%9E%E7%8E%B0%E7%94%B5%E6%9C%BA%E5%90%AF%E5%81%9C/" class="post-title-link" itemprop="url">基于RT-Thread的CAN电机驱动板设计 （四）使用PIN设备配置按键中断实现电机启停</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              <time title="Erstellt: 2021-06-07 19:50:43" itemprop="dateCreated datePublished" datetime="2021-06-07T19:50:43+08:00">2021-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2021-08-13 10:01:02" itemprop="dateModified" datetime="2021-08-13T10:01:02+08:00">2021-08-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在前几篇文章中实现了电机驱动板需要实现的大部分功能，本来想进一步加一点锦上添花的小功能即配置按键中断向电机发送CAN指令实现电机的启动与停止，但是在这个过程中也遇到了不少问题，所以记录下来。</p>
<h1 id="资料连接"><a href="#资料连接" class="headerlink" title="资料连接"></a>资料连接</h1><p>本项目的所有资料全部开源：</p>
<p><strong>硬件工程</strong>：<a target="_blank" rel="noopener" href="https://lceda.cn/FranHawk/485tocan_motor_controller">https://lceda.cn/FranHawk/485tocan_motor_controller</a><br><strong>软件工程</strong>：<a target="_blank" rel="noopener" href="https://github.com/FranHawk/RT-Thread-485toCAN">https://github.com/FranHawk/RT-Thread-485toCAN</a></p>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><ul>
<li>制作好的电机驱动板一块</li>
<li>USB转485模块一个，用来插在PC上实现485协议与电机驱动板通讯</li>
<li>rtthread studio开发环境</li>
</ul>
<h1 id="电机启动停止指令"><a href="#电机启动停止指令" class="headerlink" title="电机启动停止指令"></a>电机启动停止指令</h1><p><img src="https://img-blog.csdnimg.cn/20210605170111741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210605170128462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<h1 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h1><p>主要参照了rtthread官方的pin设备文档，但是发现根据PIN设备文档来配置仍存在一些问题，这个后面会提到<br>官方文档链接：<br><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/device/pin/pin">https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/device/pin/pin</a><br>根据官方文档，PIN设备的接口如下<br><img src="https://img-blog.csdnimg.cn/20210605170400714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>通过PIN接口为按键绑定中断函数，官方文档中给出的示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY0_PIN_NUM            55  <span class="comment">/* PD8 */</span></span></span><br><span class="line"><span class="comment">/* 中断回调函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beep_on</span><span class="params">(<span class="keyword">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;turn on beep!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    rt_pin_write(BEEP_PIN_NUM, PIN_HIGH);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pin_beep_sample</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 按键0引脚为输入模式 */</span></span><br><span class="line">    rt_pin_mode(KEY0_PIN_NUM, PIN_MODE_INPUT_PULLUP);</span><br><span class="line">    <span class="comment">/* 绑定中断，上升沿模式，回调函数名为beep_on */</span></span><br><span class="line">    rt_pin_attach_irq(KEY0_PIN_NUM, PIN_IRQ_MODE_FALLING, beep_on, RT_NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我刚开始编写代码的时候，按照示例代码编写发现根本进入不了中断服务函数，最后通过在rtthread studio中查找pin设备的API发现下面这个例子。<br><img src="https://img-blog.csdnimg.cn/20210605170643946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210605170707561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210605171200961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2006-2018, RT-Thread Development Team</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * SPDX-License-Identifier: Apache-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Change Logs:</span></span><br><span class="line"><span class="comment"> * Date           Author       Notes</span></span><br><span class="line"><span class="comment"> * 2018-08-15     misonyo      first implementation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序清单：这是一个 PIN 设备使用例程</span></span><br><span class="line"><span class="comment"> * 例程导出了 pin_beep_sample 命令到控制终端</span></span><br><span class="line"><span class="comment"> * 命令调用格式：pin_beep_sample</span></span><br><span class="line"><span class="comment"> * 程序功能：通过按键控制蜂鸣器对应引脚的电平状态控制蜂鸣器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rtdevice.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 引脚编号，通过查看驱动文件drv_gpio.c确定 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BEEP_PIN_NUM</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> BEEP_PIN_NUM            35  <span class="comment">/* PB0 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> KEY0_PIN_NUM</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> KEY0_PIN_NUM            55  <span class="comment">/* PD8 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> KEY1_PIN_NUM</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> KEY1_PIN_NUM            56  <span class="comment">/* PD9 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beep_on</span><span class="params">(<span class="keyword">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;turn on beep!\n&quot;</span>);</span><br><span class="line">    rt_pin_write(BEEP_PIN_NUM, PIN_HIGH);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beep_off</span><span class="params">(<span class="keyword">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;turn off beep!\n&quot;</span>);</span><br><span class="line">    rt_pin_write(BEEP_PIN_NUM, PIN_LOW);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pin_beep_sample</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 蜂鸣器引脚为输出模式 */</span></span><br><span class="line">    rt_pin_mode(BEEP_PIN_NUM, PIN_MODE_OUTPUT);</span><br><span class="line">    <span class="comment">/* 默认低电平 */</span></span><br><span class="line">    rt_pin_write(BEEP_PIN_NUM, PIN_LOW);</span><br><span class="line">    <span class="comment">/* 按键0引脚为输入模式 */</span></span><br><span class="line">    rt_pin_mode(KEY0_PIN_NUM, PIN_MODE_INPUT_PULLUP);</span><br><span class="line">    <span class="comment">/* 绑定中断，上升沿模式，回调函数名为beep_on */</span></span><br><span class="line">    rt_pin_attach_irq(KEY0_PIN_NUM, PIN_IRQ_MODE_FALLING, beep_on, RT_NULL);</span><br><span class="line">    <span class="comment">/* 使能中断 */</span></span><br><span class="line">    rt_pin_irq_enable(KEY0_PIN_NUM, PIN_IRQ_ENABLE);</span><br><span class="line">    <span class="comment">/* 按键1引脚为输入模式 */</span></span><br><span class="line">    rt_pin_mode(KEY1_PIN_NUM, PIN_MODE_INPUT_PULLUP);</span><br><span class="line">    <span class="comment">/* 绑定中断，上升沿模式，回调函数名为beep_off */</span></span><br><span class="line">    rt_pin_attach_irq(KEY1_PIN_NUM, PIN_IRQ_MODE_FALLING, beep_off, RT_NULL);</span><br><span class="line">    <span class="comment">/* 使能中断 */</span></span><br><span class="line">    rt_pin_irq_enable(KEY1_PIN_NUM, PIN_IRQ_ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 导出到 msh 命令列表中 */</span></span><br><span class="line">MSH_CMD_EXPORT(pin_beep_sample, pin beep sample);</span><br></pre></td></tr></table></figure>
<p>发现官网文档中的示例程序少了一句<br><strong>rt_pin_irq_enable(KEY1_PIN_NUM, PIN_IRQ_ENABLE);</strong><br>手动使能pin中断，这个问题卡了我半天…在这里记录下来。</p>
<h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2><p>同样采用顶半处理和底半处理的结构，通过信号量完成同步，代码比较简单，重要的是别忘了<strong>rt_pin_irq_enable</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//KEY0电机启动中断函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">motor_on_irq</span><span class="params">(<span class="keyword">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rt_sem_release(&amp;motor_on_sem);</span><br><span class="line">    rt_pin_write(LED0_PIN, PIN_HIGH);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//KEY1电机关闭中断函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">motor_off_irq</span><span class="params">(<span class="keyword">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rt_sem_release(&amp;motor_off_sem);</span><br><span class="line">    rt_pin_write(LED0_PIN, PIN_HIGH);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//电机启动底半处理</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">motor_on_thread_entry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_size_t</span> size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_can_msg</span> <span class="title">can_motor_on_msg</span>;</span></span><br><span class="line">    <span class="comment">/* 电机开启指令初始化 */</span></span><br><span class="line">    can_motor_on_msg.ide = RT_CAN_STDID; <span class="comment">/* 标准格式 */</span></span><br><span class="line">    can_motor_on_msg.rtr = RT_CAN_DTR; <span class="comment">/* 数据帧 */</span></span><br><span class="line">    can_motor_on_msg.len = <span class="number">8</span>; <span class="comment">/* 数据长度为 8 */</span></span><br><span class="line">    can_motor_on_msg.data[<span class="number">0</span>] = MOTOR_ON_CMD;<span class="comment">/* 指令类型为状态查询 */</span></span><br><span class="line">    can_motor_on_msg.data[<span class="number">1</span>] = <span class="number">0x00</span>;</span><br><span class="line">    can_motor_on_msg.data[<span class="number">2</span>] = <span class="number">0x00</span>;</span><br><span class="line">    can_motor_on_msg.data[<span class="number">3</span>] = <span class="number">0x00</span>;</span><br><span class="line">    can_motor_on_msg.data[<span class="number">4</span>] = <span class="number">0x00</span>;</span><br><span class="line">    can_motor_on_msg.data[<span class="number">5</span>] = <span class="number">0x00</span>;</span><br><span class="line">    can_motor_on_msg.data[<span class="number">6</span>] = <span class="number">0x00</span>;</span><br><span class="line">    can_motor_on_msg.data[<span class="number">7</span>] = <span class="number">0x00</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 阻塞等待接收信号量 */</span></span><br><span class="line">        rt_sem_take(&amp;motor_on_sem, RT_WAITING_FOREVER);</span><br><span class="line">        <span class="comment">//rt_kprintf(&quot;power up motor!\n&quot;);</span></span><br><span class="line">        <span class="comment">/* CAN向电机1发送数据 */</span></span><br><span class="line">        can_motor_on_msg.id = MOTOR1_ID;</span><br><span class="line">        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_motor_on_msg, <span class="keyword">sizeof</span>(can_motor_on_msg));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* CAN向电机2发送数据 */</span></span><br><span class="line">        can_motor_on_msg.id = MOTOR2_ID;</span><br><span class="line">        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_motor_on_msg, <span class="keyword">sizeof</span>(can_motor_on_msg));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* CAN向电机3发送数据 */</span></span><br><span class="line">        can_motor_on_msg.id = MOTOR3_ID;</span><br><span class="line">        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_motor_on_msg, <span class="keyword">sizeof</span>(can_motor_on_msg));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* CAN向电机4发送数据 */</span></span><br><span class="line">        can_motor_on_msg.id = MOTOR4_ID;</span><br><span class="line">        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_motor_on_msg, <span class="keyword">sizeof</span>(can_motor_on_msg));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* CAN向电机5发送数据 */</span></span><br><span class="line">        can_motor_on_msg.id = MOTOR5_ID;</span><br><span class="line">        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_motor_on_msg, <span class="keyword">sizeof</span>(can_motor_on_msg));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* CAN向电机6发送数据 */</span></span><br><span class="line">        can_motor_on_msg.id = MOTOR6_ID;</span><br><span class="line">        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_motor_on_msg, <span class="keyword">sizeof</span>(can_motor_on_msg));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* CAN向电机7发送数据 */</span></span><br><span class="line">        can_motor_on_msg.id = MOTOR7_ID;</span><br><span class="line">        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_motor_on_msg, <span class="keyword">sizeof</span>(can_motor_on_msg));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* CAN向电机8发送数据 */</span></span><br><span class="line">        can_motor_on_msg.id = MOTOR8_ID;</span><br><span class="line">        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_motor_on_msg, <span class="keyword">sizeof</span>(can_motor_on_msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//电机停止底半处理</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">motor_off_thread_entry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_size_t</span> size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_can_msg</span> <span class="title">can_motor_off_msg</span>;</span></span><br><span class="line">    <span class="comment">/* 电机关闭指令初始化 */</span></span><br><span class="line">    can_motor_off_msg.ide = RT_CAN_STDID; <span class="comment">/* 标准格式 */</span></span><br><span class="line">    can_motor_off_msg.rtr = RT_CAN_DTR; <span class="comment">/* 数据帧 */</span></span><br><span class="line">    can_motor_off_msg.len = <span class="number">8</span>; <span class="comment">/* 数据长度为 8 */</span></span><br><span class="line">    can_motor_off_msg.data[<span class="number">0</span>] = MOTOR_OFF_CMD;<span class="comment">/* 指令类型为状态查询 */</span></span><br><span class="line">    can_motor_off_msg.data[<span class="number">1</span>] = <span class="number">0x00</span>;</span><br><span class="line">    can_motor_off_msg.data[<span class="number">2</span>] = <span class="number">0x00</span>;</span><br><span class="line">    can_motor_off_msg.data[<span class="number">3</span>] = <span class="number">0x00</span>;</span><br><span class="line">    can_motor_off_msg.data[<span class="number">4</span>] = <span class="number">0x00</span>;</span><br><span class="line">    can_motor_off_msg.data[<span class="number">5</span>] = <span class="number">0x00</span>;</span><br><span class="line">    can_motor_off_msg.data[<span class="number">6</span>] = <span class="number">0x00</span>;</span><br><span class="line">    can_motor_off_msg.data[<span class="number">7</span>] = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 阻塞等待接收信号量 */</span></span><br><span class="line">        rt_sem_take(&amp;motor_off_sem, RT_WAITING_FOREVER);</span><br><span class="line">        <span class="comment">//rt_kprintf(&quot;power off motor!\n&quot;);</span></span><br><span class="line">        <span class="comment">/* CAN向电机1发送数据 */</span></span><br><span class="line">        can_motor_off_msg.id = MOTOR1_ID;</span><br><span class="line">        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_motor_off_msg, <span class="keyword">sizeof</span>(can_motor_off_msg));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* CAN向电机2发送数据 */</span></span><br><span class="line">        can_motor_off_msg.id = MOTOR2_ID;</span><br><span class="line">        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_motor_off_msg, <span class="keyword">sizeof</span>(can_motor_off_msg));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* CAN向电机3发送数据 */</span></span><br><span class="line">        can_motor_off_msg.id = MOTOR3_ID;</span><br><span class="line">        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_motor_off_msg, <span class="keyword">sizeof</span>(can_motor_off_msg));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* CAN向电机4发送数据 */</span></span><br><span class="line">        can_motor_off_msg.id = MOTOR4_ID;</span><br><span class="line">        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_motor_off_msg, <span class="keyword">sizeof</span>(can_motor_off_msg));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* CAN向电机5发送数据 */</span></span><br><span class="line">        can_motor_off_msg.id = MOTOR5_ID;</span><br><span class="line">        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_motor_off_msg, <span class="keyword">sizeof</span>(can_motor_off_msg));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* CAN向电机6发送数据 */</span></span><br><span class="line">        can_motor_off_msg.id = MOTOR6_ID;</span><br><span class="line">        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_motor_off_msg, <span class="keyword">sizeof</span>(can_motor_off_msg));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* CAN向电机7发送数据 */</span></span><br><span class="line">        can_motor_off_msg.id = MOTOR7_ID;</span><br><span class="line">        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_motor_off_msg, <span class="keyword">sizeof</span>(can_motor_off_msg));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* CAN向电机8发送数据 */</span></span><br><span class="line">        can_motor_off_msg.id = MOTOR8_ID;</span><br><span class="line">        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_motor_off_msg, <span class="keyword">sizeof</span>(can_motor_off_msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//电机启停线程初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">rt_err_t</span> <span class="title">motor_on_off_thread_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">rt_err_t</span> res_on, res_off, res;</span><br><span class="line">    <span class="keyword">rt_thread_t</span> thread_on, thread_off;</span><br><span class="line">    res = RT_EOK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 按键0引脚为输入模式 */</span></span><br><span class="line">    rt_pin_mode(KEY0_PIN, PIN_MODE_INPUT_PULLUP);</span><br><span class="line">    <span class="comment">/* 绑定中断，上升沿模式，回调函数名为motor_on */</span></span><br><span class="line">    rt_pin_attach_irq(KEY0_PIN, PIN_IRQ_MODE_FALLING, motor_on_irq, RT_NULL);</span><br><span class="line">    rt_pin_irq_enable(KEY0_PIN, PIN_IRQ_ENABLE);</span><br><span class="line">    <span class="comment">/* 按键1引脚为输入模式 */</span></span><br><span class="line">    rt_pin_mode(KEY1_PIN, PIN_MODE_INPUT_PULLUP);</span><br><span class="line">    <span class="comment">/* 绑定中断，上升沿模式，回调函数名为motor_on */</span></span><br><span class="line">    rt_pin_attach_irq(KEY1_PIN, PIN_IRQ_MODE_FALLING, motor_off_irq, RT_NULL);</span><br><span class="line">    rt_pin_irq_enable(KEY1_PIN, PIN_IRQ_ENABLE);</span><br><span class="line">    <span class="comment">/* 初始化电机启动信号量 */</span></span><br><span class="line">    rt_sem_init(&amp;motor_on_sem, <span class="string">&quot;motor_on_sem&quot;</span>, <span class="number">0</span>, RT_IPC_FLAG_FIFO);</span><br><span class="line">    <span class="comment">/* 初始化电机启动信号量 */</span></span><br><span class="line">    rt_sem_init(&amp;motor_off_sem, <span class="string">&quot;motor_off_sem&quot;</span>, <span class="number">0</span>, RT_IPC_FLAG_FIFO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建电机启动线程,优先级为4 */</span></span><br><span class="line">    thread_on = rt_thread_create(<span class="string">&quot;motor_on&quot;</span>, motor_on_thread_entry, RT_NULL, <span class="number">1024</span>, <span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (thread_on != RT_NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_thread_startup(thread_on);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        res_on = RT_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 创建电机停止线程,优先级为4 */</span></span><br><span class="line">    thread_off = rt_thread_create(<span class="string">&quot;motor_off&quot;</span>, motor_off_thread_entry, RT_NULL, <span class="number">1024</span>, <span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (thread_off != RT_NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_thread_startup(thread_off);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        res_off = RT_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((res_on == RT_ERROR) || (res_off == RT_ERROR))</span><br><span class="line">    &#123;</span><br><span class="line">        res = RT_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，整个基于RT-Thread的CAN电机驱动板项目开发完毕，学到了很多新东西，加深了我对rtthread中驱动还有线程间通信和同步的理解，这个项目的可扩展性比较强，不仅可以用于这款电机，还能用于其他CAN协议的电机，值得大家借鉴。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/06/%E5%9F%BA%E4%BA%8ERT-Thread%E7%9A%84CAN%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E6%9D%BF%E8%AE%BE%E8%AE%A1%20%EF%BC%88%E4%B8%89%EF%BC%89CAN%E9%A9%B1%E5%8A%A8%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fran Hawk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张竞豪的小岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/06/%E5%9F%BA%E4%BA%8ERT-Thread%E7%9A%84CAN%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E6%9D%BF%E8%AE%BE%E8%AE%A1%20%EF%BC%88%E4%B8%89%EF%BC%89CAN%E9%A9%B1%E5%8A%A8%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">基于RT-Thread的CAN电机驱动板设计 （三）CAN驱动配置与实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              <time title="Erstellt: 2021-06-06 19:50:43" itemprop="dateCreated datePublished" datetime="2021-06-06T19:50:43+08:00">2021-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2021-08-13 10:01:02" itemprop="dateModified" datetime="2021-08-13T10:01:02+08:00">2021-08-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>上一篇文章实现了基于rtthread的uart 的DMA接收驱动的配置与使用。下面重点需要完成rtthread对stm32的CAN驱动的配置，由于rtthread默认工程中没有对特定芯片如stm32的CAN驱动的芯片级驱动代码，但是在rtthread的github仓库中有相关的代码，需要我们自己完成配置。因此本文的重点工作是完成stm32的CAN驱动的配置，通过上述流程达到一以贯之的效果，以后再遇到其他协议也可以如此处理。</p>
<h1 id="资料连接"><a href="#资料连接" class="headerlink" title="资料连接"></a>资料连接</h1><p>本项目的所有资料全部开源：</p>
<p><strong>硬件工程</strong>：<a target="_blank" rel="noopener" href="https://lceda.cn/FranHawk/485tocan_motor_controller">https://lceda.cn/FranHawk/485tocan_motor_controller</a><br><strong>软件工程</strong>：<a target="_blank" rel="noopener" href="https://github.com/FranHawk/RT-Thread-485toCAN">https://github.com/FranHawk/RT-Thread-485toCAN</a></p>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><ul>
<li>制作好的电机驱动板一块</li>
<li>USB转485模块一个，用来插在PC上实现485协议与电机驱动板通讯</li>
<li>rtthread studio开发环境</li>
<li>cubemx配置工具</li>
<li>硬件连接图如下所示，蓝色的就是USB转485模块<br><img src="https://img-blog.csdnimg.cn/20210604144019677.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70#pic_center"><h1 id="CAN驱动配置"><a href="#CAN驱动配置" class="headerlink" title="CAN驱动配置"></a>CAN驱动配置</h1>这篇文章依托上一篇文章已经创建好的工程<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>这篇文章是rtthread官方文档的CAN驱动说明，里面有CAN协议简要介绍和CAN应用层代码示例<br><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/device/can/can">https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/device/can/can</a><br>这几篇文章教如何在rtthread studio中配置CAN驱动，重点看前三篇，里面有一些疑难问题的解决<br><a target="_blank" rel="noopener" href="https://club.rt-thread.org/ask/question/429883.html">https://club.rt-thread.org/ask/question/429883.html</a><br><a target="_blank" rel="noopener" href="https://www.icode9.com/content-4-826571.html">https://www.icode9.com/content-4-826571.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_25186745/article/details/112788923?utm_source=app&app_version=4.8.0&code=app_1562916241&uLinkId=usr1mkqgl919blen">https://blog.csdn.net/qq_25186745/article/details/112788923?utm_source=app&amp;app_version=4.8.0&amp;code=app_1562916241&amp;uLinkId=usr1mkqgl919blen</a><br><a target="_blank" rel="noopener" href="https://club.rt-thread.org/ask/question/427543.html">https://club.rt-thread.org/ask/question/427543.html</a><h2 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h2>根据上述几篇参考文献，我们首先要去rtthread的github仓库下载stm32的can驱动支持代码<br>打开以下链接<br><a target="_blank" rel="noopener" href="https://github.com/RT-Thread/rt-thread">https://github.com/RT-Thread/rt-thread</a><br><img src="https://img-blog.csdnimg.cn/20210605111914719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>进入bsp文件夹，找到stm32<br><img src="https://img-blog.csdnimg.cn/20210605112000702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>进入以下路径，找到drv_can.h和drv_can.c,下载这两个文件，并分别放到rtthread studio工程的drivers/include和drivers文件夹中，然后在rtthread studio中刷新，才能看到新添加的两个文件<br><img src="https://img-blog.csdnimg.cn/20210605112102554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210605112229283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210605112351903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><h2 id="配置CAN驱动"><a href="#配置CAN驱动" class="headerlink" title="配置CAN驱动"></a>配置CAN驱动</h2>打开stm32f1xx_hal_conf.h，注释掉CAN的使能如下图<br><img src="https://img-blog.csdnimg.cn/20210605112705740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>打开rtthread settings，使能CAN设备驱动程序<br><img src="https://img-blog.csdnimg.cn/20210605112752650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>在board.h中添加</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BSP_USING_CAN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BSP_USING_CAN1</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210605112849458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>最后还需要CAN的两个引脚初始化的代码，我们打开cubemx完成CAN配置<br><img src="https://img-blog.csdnimg.cn/20210605113816142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>选中master mode就行了，我们只用到cubemx生成的引脚初始化代码，其余的包括波特率不用管，这个后面用rtthread的设备驱动设置，最后打开生成的MDK5工程，把stm32f1xx_hal_msp.c中的如下代码复制到rtthread studio的board.c中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief CAN MSP Initialization</span></span><br><span class="line"><span class="comment">* This function configures the hardware resources used in this example</span></span><br><span class="line"><span class="comment">* @param hcan: CAN handle pointer</span></span><br><span class="line"><span class="comment">* @retval None</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_CAN_MspInit</span><span class="params">(CAN_HandleTypeDef* hcan)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span>(hcan-&gt;Instance==CAN1)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN CAN1_MspInit 0 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END CAN1_MspInit 0 */</span></span><br><span class="line">    <span class="comment">/* Peripheral clock enable */</span></span><br><span class="line">    __HAL_RCC_CAN1_CLK_ENABLE();</span><br><span class="line">  </span><br><span class="line">    __HAL_RCC_GPIOA_CLK_ENABLE();</span><br><span class="line">    <span class="comment">/**CAN GPIO Configuration    </span></span><br><span class="line"><span class="comment">    PA11     ------&gt; CAN_RX</span></span><br><span class="line"><span class="comment">    PA12     ------&gt; CAN_TX </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    GPIO_InitStruct.Pin = GPIO_PIN_11;</span><br><span class="line">    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;</span><br><span class="line">    GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">    GPIO_InitStruct.Pin = GPIO_PIN_12;</span><br><span class="line">    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;</span><br><span class="line">    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN CAN1_MspInit 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END CAN1_MspInit 1 */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief CAN MSP De-Initialization</span></span><br><span class="line"><span class="comment">* This function freeze the hardware resources used in this example</span></span><br><span class="line"><span class="comment">* @param hcan: CAN handle pointer</span></span><br><span class="line"><span class="comment">* @retval None</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_CAN_MspDeInit</span><span class="params">(CAN_HandleTypeDef* hcan)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(hcan-&gt;Instance==CAN1)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN CAN1_MspDeInit 0 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END CAN1_MspDeInit 0 */</span></span><br><span class="line">    <span class="comment">/* Peripheral clock disable */</span></span><br><span class="line">    __HAL_RCC_CAN1_CLK_DISABLE();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**CAN GPIO Configuration    </span></span><br><span class="line"><span class="comment">    PA11     ------&gt; CAN_RX</span></span><br><span class="line"><span class="comment">    PA12     ------&gt; CAN_TX </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_11|GPIO_PIN_12);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN CAN1_MspDeInit 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END CAN1_MspDeInit 1 */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210605122652132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>至此完成了CAN驱动配置</p>
<h2 id="参考rtthread官网的CAN设备的示例程序编写代码"><a href="#参考rtthread官网的CAN设备的示例程序编写代码" class="headerlink" title="参考rtthread官网的CAN设备的示例程序编写代码"></a>参考rtthread官网的CAN设备的示例程序编写代码</h2><p><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/device/can/can">https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/device/can/can</a><br><img src="https://img-blog.csdnimg.cn/20210605123035129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>根据电机数据手册，设置波特率是1M，8个电机的ID号从0x141到0x148</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*各电机ID定义*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOTOR1_ID   0x141</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOTOR2_ID   0x142</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOTOR3_ID   0x143</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOTOR4_ID   0x144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOTOR5_ID   0x145</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOTOR6_ID   0x146</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOTOR7_ID   0x147</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOTOR8_ID   0x148</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210605094724457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210605094748588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210605094828795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>根据数据手册，定义电机命令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*电机控制指令定义*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TORQUE_CURRENT_CMD 0xA1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATE_QUEST_CMD    0x9C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOTOR_ON_CMD       0x81</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOTOR_OFF_CMD      0x88</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CAN 设备名称定义 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAN_DEV_NAME       <span class="meta-string">&quot;can1&quot;</span></span></span><br><span class="line"><span class="comment">/* 用于CAN接收消息的信号量 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_semaphore</span> <span class="title">can_rx_sem</span>;</span></span><br><span class="line"><span class="comment">/* CAN设备句柄 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">rt_device_t</span> can_dev;</span><br></pre></td></tr></table></figure>
<p>CAN采用中断的方式接收数据，还是分为顶半处理和底半处理，顶半处理就是CAN接收中断函数，里面只负责释放信号量，底半处理是CAN数据处理线程，负责对CAN接收的数据进行解码，并且把有效信息存放在数组中等待被电机驱动板发送至上位机。<br>下面是CAN接收中断函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CAN接收数据回调函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">rt_err_t</span> <span class="title">can_rx_call</span><span class="params">(<span class="keyword">rt_device_t</span> dev, <span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* CAN 接收到数据后产生中断，调用此回调函数，然后发送接收信号量 */</span></span><br><span class="line">    rt_sem_release(&amp;can_rx_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CAN数据处理线程初始化函数，由于CAN发送控制和查询指令至电机的程序在串口数据处理线程中，优先级为5，每发给一个电机指令，电机就会返回一条指令，为了不让CAN数据接收受到影响，将CAN数据接收线程的优先级调整至比CAN数据发送更高。CAN数据处理线程优先级设为6。<strong>这个地方要注意的是，在电机驱动板连接电机时，将CAN工作模式设为正常模式，在未连接电机，单独调试时需要设置为LOOPBACK回环模式</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CAN接收数据处理初始化 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">rt_err_t</span> <span class="title">can_rx_thread_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">rt_err_t</span> res;</span><br><span class="line">    <span class="keyword">rt_thread_t</span> thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查找 CAN 设备 */</span></span><br><span class="line">    can_dev = rt_device_find(CAN_DEV_NAME);</span><br><span class="line">    <span class="keyword">if</span> (!can_dev)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;find %s failed!\n&quot;</span>, CAN_DEV_NAME);</span><br><span class="line">        <span class="keyword">return</span> RT_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化 CAN 接收信号量 */</span></span><br><span class="line">    rt_sem_init(&amp;can_rx_sem, <span class="string">&quot;rx_sem&quot;</span>, <span class="number">0</span>, RT_IPC_FLAG_FIFO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 以中断接收及发送方式打开 CAN 设备 */</span></span><br><span class="line">    res = rt_device_open(can_dev, RT_DEVICE_FLAG_INT_TX | RT_DEVICE_FLAG_INT_RX);</span><br><span class="line">    res = rt_device_control(can_dev, RT_CAN_CMD_SET_BAUD, (<span class="keyword">void</span> *) CAN1MBaud);</span><br><span class="line">    res = rt_device_control(can_dev, RT_CAN_CMD_SET_MODE, (<span class="keyword">void</span> *) RT_CAN_MODE_NORMAL);</span><br><span class="line">    RT_ASSERT(res == RT_EOK);</span><br><span class="line">    <span class="comment">/* 创建数据接收线程,优先级为5 */</span></span><br><span class="line">    thread = rt_thread_create(<span class="string">&quot;can_rx&quot;</span>, can_rx_thread_entry, RT_NULL, <span class="number">2048</span>, <span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (thread != RT_NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_thread_startup(thread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        res = RT_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CAN数据处理线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CAN接收数据处理线程 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">can_rx_thread_entry</span><span class="params">(<span class="keyword">void</span> *parameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_can_msg</span> <span class="title">rxmsg</span> =</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    serial_tx_buffer[<span class="number">0</span>] = <span class="number">0x5A</span>;</span><br><span class="line">    serial_tx_buffer[<span class="number">34</span>] = <span class="number">0xA5</span>;</span><br><span class="line">    <span class="comment">/* 设置接收回调函数 */</span></span><br><span class="line">    rt_device_set_rx_indicate(can_dev, can_rx_call);</span><br><span class="line">    <span class="comment">/*不使用硬件过滤表*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_CAN_USING_HDR</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_can_filter_item</span> <span class="title">items</span>[5] =</span></span><br><span class="line">    &#123;</span><br><span class="line">        RT_CAN_FILTER_ITEM_INIT(<span class="number">0x100</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0x700</span>, RT_NULL, RT_NULL), <span class="comment">/* std,match ID:0x100~0x1ff，hdr 为 - 1，设置默认过滤表 */</span></span><br><span class="line">        RT_CAN_FILTER_ITEM_INIT(<span class="number">0x300</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0x700</span>, RT_NULL, RT_NULL), <span class="comment">/* std,match ID:0x300~0x3ff，hdr 为 - 1 */</span></span><br><span class="line">        RT_CAN_FILTER_ITEM_INIT(<span class="number">0x211</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0x7ff</span>, RT_NULL, RT_NULL), <span class="comment">/* std,match ID:0x211，hdr 为 - 1 */</span></span><br><span class="line">        RT_CAN_FILTER_STD_INIT(<span class="number">0x486</span>, RT_NULL, RT_NULL), <span class="comment">/* std,match ID:0x486，hdr 为 - 1 */</span></span><br><span class="line">        &#123;   <span class="number">0x555</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0x7ff</span>, <span class="number">7</span>,&#125; <span class="comment">/* std,match ID:0x555，hdr 为 7，指定设置 7 号过滤表 */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_can_filter_config</span> <span class="title">cfg</span> =</span></span><br><span class="line">    &#123;   <span class="number">5</span>, <span class="number">1</span>, items&#125;; <span class="comment">/* 一共有 5 个过滤表 */</span></span><br><span class="line">    <span class="comment">/* 设置硬件过滤表 */</span></span><br><span class="line">    res = rt_device_control(can_dev, RT_CAN_CMD_SET_FILTER, &amp;cfg);</span><br><span class="line">    RT_ASSERT(res == RT_EOK);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* hdr 值为 - 1，表示直接从 uselist 链表读取数据 */</span></span><br><span class="line">        rxmsg.hdr = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">/* 阻塞等待接收信号量 */</span></span><br><span class="line">        rt_sem_take(&amp;can_rx_sem, RT_WAITING_FOREVER);</span><br><span class="line">        <span class="comment">/* 从 CAN 读取一帧数据 */</span></span><br><span class="line">        rt_device_read(can_dev, <span class="number">0</span>, &amp;rxmsg, <span class="keyword">sizeof</span>(rxmsg));</span><br><span class="line">        <span class="comment">/* 打印数据 ID 及内容 */</span></span><br><span class="line"><span class="comment">//        rt_kprintf(&quot;ID:%x&quot;, rxmsg.id);</span></span><br><span class="line"><span class="comment">//        for (i = 0; i &lt; 8; i++)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            rt_kprintf(&quot;%2x&quot;, rxmsg.data[i]);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//rt_kprintf(&quot;\n&quot;);</span></span><br><span class="line">        <span class="comment">// rt_kprintf(&quot;state_quest\n&quot;);</span></span><br><span class="line">        <span class="comment">/*根据id号判断是哪个电机，并把相应的值放进数据发送数组中*/</span></span><br><span class="line">        <span class="comment">/*由于控制指令和查询状态指令的返回值格式相同，这里不做区分*/</span></span><br><span class="line">        <span class="keyword">if</span> (rxmsg.data[<span class="number">0</span>] == STATE_QUEST_CMD || rxmsg.data[<span class="number">0</span>] == TORQUE_CURRENT_CMD)<span class="comment">/*判断是不是状态查询帧*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (rxmsg.id)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> MOTOR1_ID:</span><br><span class="line">                serial_tx_buffer[<span class="number">1</span>] = rxmsg.data[<span class="number">2</span>];</span><br><span class="line">                serial_tx_buffer[<span class="number">2</span>] = rxmsg.data[<span class="number">3</span>];</span><br><span class="line">                serial_tx_buffer[<span class="number">17</span>] = rxmsg.data[<span class="number">6</span>];</span><br><span class="line">                serial_tx_buffer[<span class="number">18</span>] = rxmsg.data[<span class="number">7</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MOTOR2_ID:</span><br><span class="line">                serial_tx_buffer[<span class="number">3</span>] = rxmsg.data[<span class="number">2</span>];</span><br><span class="line">                serial_tx_buffer[<span class="number">4</span>] = rxmsg.data[<span class="number">3</span>];</span><br><span class="line">                serial_tx_buffer[<span class="number">19</span>] = rxmsg.data[<span class="number">6</span>];</span><br><span class="line">                serial_tx_buffer[<span class="number">20</span>] = rxmsg.data[<span class="number">7</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MOTOR3_ID:</span><br><span class="line">                serial_tx_buffer[<span class="number">5</span>] = rxmsg.data[<span class="number">2</span>];</span><br><span class="line">                serial_tx_buffer[<span class="number">6</span>] = rxmsg.data[<span class="number">3</span>];</span><br><span class="line">                serial_tx_buffer[<span class="number">21</span>] = rxmsg.data[<span class="number">6</span>];</span><br><span class="line">                serial_tx_buffer[<span class="number">22</span>] = rxmsg.data[<span class="number">7</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MOTOR4_ID:</span><br><span class="line">                serial_tx_buffer[<span class="number">7</span>] = rxmsg.data[<span class="number">2</span>];</span><br><span class="line">                serial_tx_buffer[<span class="number">8</span>] = rxmsg.data[<span class="number">3</span>];</span><br><span class="line">                serial_tx_buffer[<span class="number">23</span>] = rxmsg.data[<span class="number">6</span>];</span><br><span class="line">                serial_tx_buffer[<span class="number">24</span>] = rxmsg.data[<span class="number">7</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MOTOR5_ID:</span><br><span class="line">                serial_tx_buffer[<span class="number">9</span>] = rxmsg.data[<span class="number">2</span>];</span><br><span class="line">                serial_tx_buffer[<span class="number">10</span>] = rxmsg.data[<span class="number">3</span>];</span><br><span class="line">                serial_tx_buffer[<span class="number">25</span>] = rxmsg.data[<span class="number">6</span>];</span><br><span class="line">                serial_tx_buffer[<span class="number">26</span>] = rxmsg.data[<span class="number">7</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MOTOR6_ID:</span><br><span class="line">                serial_tx_buffer[<span class="number">11</span>] = rxmsg.data[<span class="number">2</span>];</span><br><span class="line">                serial_tx_buffer[<span class="number">12</span>] = rxmsg.data[<span class="number">3</span>];</span><br><span class="line">                serial_tx_buffer[<span class="number">27</span>] = rxmsg.data[<span class="number">6</span>];</span><br><span class="line">                serial_tx_buffer[<span class="number">28</span>] = rxmsg.data[<span class="number">7</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MOTOR7_ID:</span><br><span class="line">                serial_tx_buffer[<span class="number">13</span>] = rxmsg.data[<span class="number">2</span>];</span><br><span class="line">                serial_tx_buffer[<span class="number">14</span>] = rxmsg.data[<span class="number">3</span>];</span><br><span class="line">                serial_tx_buffer[<span class="number">29</span>] = rxmsg.data[<span class="number">6</span>];</span><br><span class="line">                serial_tx_buffer[<span class="number">30</span>] = rxmsg.data[<span class="number">7</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MOTOR8_ID:<span class="comment">/*收到电机8数据，说明所有数据均发送完成*/</span></span><br><span class="line">                serial_tx_buffer[<span class="number">15</span>] = rxmsg.data[<span class="number">2</span>];</span><br><span class="line">                serial_tx_buffer[<span class="number">16</span>] = rxmsg.data[<span class="number">3</span>];</span><br><span class="line">                serial_tx_buffer[<span class="number">31</span>] = rxmsg.data[<span class="number">6</span>];</span><br><span class="line">                serial_tx_buffer[<span class="number">32</span>] = rxmsg.data[<span class="number">7</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面都是CAN接收数据的部分，下面展示部分CAN发送数据的代码，下面是上一篇所述的串口数据处理函数，对上位机的指令解码，然后通过CAN向电机发送指令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 串口处理接收数据线程入口 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rs485_serial_thread_entry</span><span class="params">(<span class="keyword">void</span> *parameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">rt_size_t</span> size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rs485_serial_rx_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_can_msg</span> <span class="title">can_tx_msg</span> =</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">rt_err_t</span> result;</span><br><span class="line">    <span class="keyword">rt_uint32_t</span> rx_length;</span><br><span class="line">    <span class="keyword">rt_uint8_t</span> check_sum, check_index;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> rx_buffer[RT_SERIAL_RB_BUFSZ + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_memset(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="comment">/* 从消息队列中读取消息*/</span></span><br><span class="line">        result = rt_mq_recv(&amp;rs485_serial_rx_mq, &amp;msg, <span class="keyword">sizeof</span>(msg), RT_WAITING_FOREVER);</span><br><span class="line">        <span class="keyword">if</span> (result == RT_EOK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//rt_kprintf(&quot;%d\n&quot;, msg.size);</span></span><br><span class="line">            <span class="comment">/* 从串口读取数据*/</span></span><br><span class="line"></span><br><span class="line">            rx_length = rt_device_read(msg.dev, <span class="number">0</span>, rx_buffer, msg.size);</span><br><span class="line">            <span class="keyword">if</span> ((rx_buffer[<span class="number">0</span>] == <span class="number">0x5A</span>) &amp;&amp; (rx_buffer[<span class="number">18</span>] == <span class="number">0xA5</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//rt_kprintf(&quot;recevice success\n&quot;);</span></span><br><span class="line">                <span class="comment">//判断指令类型，若不为0xFF，则是转矩控制指令,否则为状态查询指令</span></span><br><span class="line">                <span class="keyword">if</span> ((rx_buffer[<span class="number">1</span>] != <span class="number">0xFF</span>) &amp;&amp; (rx_buffer[<span class="number">17</span>] != <span class="number">0xFF</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    check_sum = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (check_index = <span class="number">1</span>; check_index &lt; <span class="number">17</span>; check_index++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        check_sum += rx_buffer[check_index];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((check_sum != rx_buffer[<span class="number">17</span>]) &amp;&amp; (rx_buffer[<span class="number">17</span>] != <span class="number">0x00</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        rt_kprintf(<span class="string">&quot;check_sum wrong\n&quot;</span>);</span><br><span class="line">                        rt_kprintf(<span class="string">&quot;%02x\n&quot;</span>, check_sum);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//rt_kprintf(&quot;check_sum right\n&quot;);</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* 向电机发送转矩电流控制数据 */</span></span><br><span class="line">                        can_tx_msg.ide = RT_CAN_STDID; <span class="comment">/* 标准格式 */</span></span><br><span class="line">                        can_tx_msg.rtr = RT_CAN_DTR; <span class="comment">/* 数据帧 */</span></span><br><span class="line">                        can_tx_msg.len = <span class="number">8</span>; <span class="comment">/* 数据长度为 8 */</span></span><br><span class="line">                        can_tx_msg.data[<span class="number">0</span>] = TORQUE_CURRENT_CMD;</span><br><span class="line">                        can_tx_msg.data[<span class="number">1</span>] = <span class="number">0x00</span>;</span><br><span class="line">                        can_tx_msg.data[<span class="number">2</span>] = <span class="number">0x00</span>;</span><br><span class="line">                        can_tx_msg.data[<span class="number">3</span>] = <span class="number">0x00</span>;</span><br><span class="line">                        can_tx_msg.data[<span class="number">6</span>] = <span class="number">0x00</span>;</span><br><span class="line">                        can_tx_msg.data[<span class="number">7</span>] = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* CAN向电机1发送数据 */</span></span><br><span class="line">                        can_tx_msg.id = MOTOR1_ID;</span><br><span class="line">                        can_tx_msg.data[<span class="number">4</span>] = rx_buffer[<span class="number">1</span>];</span><br><span class="line">                        can_tx_msg.data[<span class="number">5</span>] = rx_buffer[<span class="number">2</span>];</span><br><span class="line">                        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* CAN向电机2发送数据 */</span></span><br><span class="line">                        can_tx_msg.id = MOTOR2_ID;</span><br><span class="line">                        can_tx_msg.data[<span class="number">4</span>] = rx_buffer[<span class="number">3</span>];</span><br><span class="line">                        can_tx_msg.data[<span class="number">5</span>] = rx_buffer[<span class="number">4</span>];</span><br><span class="line">                        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* CAN向电机3发送数据 */</span></span><br><span class="line">                        can_tx_msg.id = MOTOR3_ID;</span><br><span class="line">                        can_tx_msg.data[<span class="number">4</span>] = rx_buffer[<span class="number">5</span>];</span><br><span class="line">                        can_tx_msg.data[<span class="number">5</span>] = rx_buffer[<span class="number">6</span>];</span><br><span class="line">                        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* CAN向电机4发送数据 */</span></span><br><span class="line">                        can_tx_msg.id = MOTOR4_ID;</span><br><span class="line">                        can_tx_msg.data[<span class="number">4</span>] = rx_buffer[<span class="number">7</span>];</span><br><span class="line">                        can_tx_msg.data[<span class="number">5</span>] = rx_buffer[<span class="number">8</span>];</span><br><span class="line">                        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* CAN向电机5发送数据 */</span></span><br><span class="line">                        can_tx_msg.id = MOTOR5_ID;</span><br><span class="line">                        can_tx_msg.data[<span class="number">4</span>] = rx_buffer[<span class="number">9</span>];</span><br><span class="line">                        can_tx_msg.data[<span class="number">5</span>] = rx_buffer[<span class="number">10</span>];</span><br><span class="line">                        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* CAN向电机6发送数据 */</span></span><br><span class="line">                        can_tx_msg.id = MOTOR6_ID;</span><br><span class="line">                        can_tx_msg.data[<span class="number">4</span>] = rx_buffer[<span class="number">11</span>];</span><br><span class="line">                        can_tx_msg.data[<span class="number">5</span>] = rx_buffer[<span class="number">12</span>];</span><br><span class="line">                        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* CAN向电机7发送数据 */</span></span><br><span class="line">                        can_tx_msg.id = MOTOR7_ID;</span><br><span class="line">                        can_tx_msg.data[<span class="number">4</span>] = rx_buffer[<span class="number">13</span>];</span><br><span class="line">                        can_tx_msg.data[<span class="number">5</span>] = rx_buffer[<span class="number">14</span>];</span><br><span class="line">                        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* CAN向电机8发送数据 */</span></span><br><span class="line">                        can_tx_msg.id = MOTOR8_ID;</span><br><span class="line">                        can_tx_msg.data[<span class="number">4</span>] = rx_buffer[<span class="number">15</span>];</span><br><span class="line">                        can_tx_msg.data[<span class="number">5</span>] = rx_buffer[<span class="number">16</span>];</span><br><span class="line">                        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line">                        <span class="keyword">for</span> (check_index = <span class="number">1</span>; check_index &lt; <span class="number">33</span>; check_index++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            serial_tx_buffer[<span class="number">33</span>] += serial_tx_buffer[check_index];</span><br><span class="line">                        &#125;</span><br><span class="line">                        rt_pin_write(RS485A_RE_PIN, PIN_HIGH);<span class="comment">/*使485处于发送模式*/</span></span><br><span class="line">                        rt_device_write(rs485_serial_device_handle, <span class="number">0</span>, serial_tx_buffer, <span class="keyword">sizeof</span>(serial_tx_buffer));</span><br><span class="line">                        rt_pin_write(RS485A_RE_PIN, PIN_LOW);<span class="comment">/*使485处于接收模式*/</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* 向电机发送状态查询指令 */</span></span><br><span class="line">                    can_tx_msg.ide = RT_CAN_STDID; <span class="comment">/* 标准格式 */</span></span><br><span class="line">                    can_tx_msg.rtr = RT_CAN_DTR; <span class="comment">/* 数据帧 */</span></span><br><span class="line">                    can_tx_msg.len = <span class="number">8</span>; <span class="comment">/* 数据长度为 8 */</span></span><br><span class="line">                    can_tx_msg.data[<span class="number">0</span>] = STATE_QUEST_CMD;<span class="comment">/* 指令类型为状态查询 */</span></span><br><span class="line">                    can_tx_msg.data[<span class="number">1</span>] = <span class="number">0x00</span>;</span><br><span class="line">                    can_tx_msg.data[<span class="number">2</span>] = <span class="number">0x00</span>;</span><br><span class="line">                    can_tx_msg.data[<span class="number">3</span>] = <span class="number">0x00</span>;</span><br><span class="line">                    can_tx_msg.data[<span class="number">4</span>] = <span class="number">0x00</span>;</span><br><span class="line">                    can_tx_msg.data[<span class="number">5</span>] = <span class="number">0x00</span>;</span><br><span class="line">                    can_tx_msg.data[<span class="number">6</span>] = <span class="number">0x00</span>;</span><br><span class="line">                    can_tx_msg.data[<span class="number">7</span>] = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* CAN向电机1发送数据 */</span></span><br><span class="line">                    can_tx_msg.id = MOTOR1_ID;</span><br><span class="line">                    <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                    size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* CAN向电机2发送数据 */</span></span><br><span class="line">                    can_tx_msg.id = MOTOR2_ID;</span><br><span class="line">                    <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                    size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* CAN向电机3发送数据 */</span></span><br><span class="line">                    can_tx_msg.id = MOTOR3_ID;</span><br><span class="line">                    <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                    size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* CAN向电机4发送数据 */</span></span><br><span class="line">                    can_tx_msg.id = MOTOR4_ID;</span><br><span class="line">                    <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                    size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* CAN向电机5发送数据 */</span></span><br><span class="line">                    can_tx_msg.id = MOTOR5_ID;</span><br><span class="line">                    <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                    size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* CAN向电机6发送数据 */</span></span><br><span class="line">                    can_tx_msg.id = MOTOR6_ID;</span><br><span class="line">                    <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                    size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* CAN向电机7发送数据 */</span></span><br><span class="line">                    can_tx_msg.id = MOTOR7_ID;</span><br><span class="line">                    <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                    size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* CAN向电机8发送数据 */</span></span><br><span class="line">                    can_tx_msg.id = MOTOR8_ID;</span><br><span class="line">                    <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                    size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//通过485向上位机发送数据</span></span><br><span class="line">                    <span class="keyword">for</span> (check_index = <span class="number">1</span>; check_index &lt; <span class="number">33</span>; check_index++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        serial_tx_buffer[<span class="number">33</span>] += serial_tx_buffer[check_index];</span><br><span class="line">                    &#125;</span><br><span class="line">                    rt_pin_write(RS485A_RE_PIN, PIN_HIGH);<span class="comment">/*使485处于发送模式*/</span></span><br><span class="line">                    rt_device_write(rs485_serial_device_handle, <span class="number">0</span>, serial_tx_buffer, <span class="keyword">sizeof</span>(serial_tx_buffer));</span><br><span class="line">                    rt_pin_write(RS485A_RE_PIN, PIN_LOW);<span class="comment">/*使485处于接收模式*/</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上述代码，完成了针对stm32的CAN驱动的配置与应用，完成了电机驱动板大部分需求，可以通过电机驱动板控制电机转矩电流并查询电机状态了，<strong>详细代码我均已开源至github</strong>。下一篇准备实现用两个按键中断向电机发送CAN指令控制电机启停的功能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/05/%E5%9F%BA%E4%BA%8ERT-Thread%E7%9A%84CAN%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E6%9D%BF%E8%AE%BE%E8%AE%A1%20%EF%BC%88%E4%BA%8C%EF%BC%89uart%E4%B8%B2%E5%8F%A3DMA%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fran Hawk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张竞豪的小岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/05/%E5%9F%BA%E4%BA%8ERT-Thread%E7%9A%84CAN%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E6%9D%BF%E8%AE%BE%E8%AE%A1%20%EF%BC%88%E4%BA%8C%EF%BC%89uart%E4%B8%B2%E5%8F%A3DMA%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">基于RT-Thread的CAN电机驱动板设计 （二）uart串口DMA的实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              <time title="Erstellt: 2021-06-05 19:50:43" itemprop="dateCreated datePublished" datetime="2021-06-05T19:50:43+08:00">2021-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2021-08-13 10:01:01" itemprop="dateModified" datetime="2021-08-13T10:01:01+08:00">2021-08-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在上一篇文章中完成了对项目的需求分析以及硬件电路的设计和制作。接下来就开始项目软件方面的实现。</p>
<ul>
<li>首先本章完成UART实现485通信的配置和调试，同时UART采用DMA方式传输，DMA控制器代替CPU完成数据传输工作，腾出时间给CPU，提高了CPU的使用的使用效率。完成PC上位机和电机驱动板的通讯。</li>
<li>然后在下一章完成rt-thread的CAN驱动的通讯与配置，完成CAN电机和电机驱动板的通讯。</li>
<li>最后实现按键中断，在中断中通过CAN发送电机启停信号完成电机启停控制</li>
</ul>
<h1 id="资料连接"><a href="#资料连接" class="headerlink" title="资料连接"></a>资料连接</h1><p>本项目的所有资料全部开源：</p>
<p><strong>硬件工程</strong>：<a target="_blank" rel="noopener" href="https://lceda.cn/FranHawk/485tocan_motor_controller">https://lceda.cn/FranHawk/485tocan_motor_controller</a><br><strong>软件工程</strong>：<a target="_blank" rel="noopener" href="https://github.com/FranHawk/RT-Thread-485toCAN">https://github.com/FranHawk/RT-Thread-485toCAN</a></p>
<h1 id="程序框架"><a href="#程序框架" class="headerlink" title="程序框架"></a>程序框架</h1><p><img src="https://img-blog.csdnimg.cn/20210607091848615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><ul>
<li>制作好的电机驱动板一块</li>
<li>USB转485模块一个，用来插在PC上实现485协议与电机驱动板通讯</li>
<li>rtthread studio开发环境</li>
<li>cubemx配置工具<br>硬件连接图如下所示，蓝色的就是USB转485模块<br><img src="https://img-blog.csdnimg.cn/20210604144019677.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70#pic_center"><h1 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h1><h2 id="创建RT-Thread工程"><a href="#创建RT-Thread工程" class="headerlink" title="创建RT-Thread工程"></a>创建RT-Thread工程</h2>打开rtthread studio，根据芯片型号新建工程，根据提示，需要将时钟源改为外部晶振</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210604163921272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>打开cubemx，根据芯片型号创建cubemx工程，高速时钟源选择外部晶振<br><img src="https://img-blog.csdnimg.cn/20210604164637490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>并按照如下图配置时钟树<br><img src="https://img-blog.csdnimg.cn/20210604164735246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>最后通过这个cubemx工程生成一个MDK5的工程，打开这个MDK5工程<br><img src="https://img-blog.csdnimg.cn/20210604164843460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>在main.c中找到时钟配置的代码如下，并且复制到rtthread studio的drv_clk.c文件的system_clock_config函数中去，覆盖掉原内容<br><img src="https://img-blog.csdnimg.cn/20210604165234299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>复制后的system_clock_config函数如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">system_clock_config</span><span class="params">(<span class="keyword">int</span> target_freq_Mhz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RCC_OscInitTypeDef RCC_OscInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">      RCC_ClkInitTypeDef RCC_ClkInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** Initializes the CPU, AHB and APB busses clocks</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;</span><br><span class="line">      RCC_OscInitStruct.HSEState = RCC_HSE_ON;</span><br><span class="line">      RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;</span><br><span class="line">      RCC_OscInitStruct.HSIState = RCC_HSI_ON;</span><br><span class="line">      RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;</span><br><span class="line">      RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;</span><br><span class="line">      RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;</span><br><span class="line">      <span class="keyword">if</span> (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK)</span><br><span class="line">      &#123;</span><br><span class="line">        Error_Handler();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/** Initializes the CPU, AHB and APB busses clocks</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK</span><br><span class="line">                                  |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;</span><br><span class="line">      RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;</span><br><span class="line">      RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;</span><br><span class="line">      RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;</span><br><span class="line">      RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)</span><br><span class="line">      &#123;</span><br><span class="line">        Error_Handler();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此rtthread studio工程创建完毕，并完成外部时钟源配置</p>
<h2 id="配置带DMA功能的UART"><a href="#配置带DMA功能的UART" class="headerlink" title="配置带DMA功能的UART"></a>配置带DMA功能的UART</h2><p>使用板子上的485A接口，根据电路图有<br><img src="https://img-blog.csdnimg.cn/20210604165628688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210604165708716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210604165745123.png"><br>485A芯片用的是UART3，同时由于485是一种半双工的协议，还有RE引脚控制收发，RE为低电平时为接收，高电平时为发送。<br>打开rtthread settings配置串口<br><img src="https://img-blog.csdnimg.cn/20210604170350627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/2021060417041238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>使能串口DMA模式，保存并关闭rtthread settings,打开board.h，根据注释的提示，输入UART3的引脚信息<br><img src="https://img-blog.csdnimg.cn/20210604170527241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>打开stm32f1xx_hal_conf.h，注释掉DMA的使能如下图<br><img src="https://img-blog.csdnimg.cn/20210605112506869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>保存并编译。</p>
<h2 id="指令定义"><a href="#指令定义" class="headerlink" title="指令定义"></a>指令定义</h2><p>根据实际需求，我们需要向CAN电机发送转矩电流指令和查询转矩电流和电机编码器位置的指令。我们要做的不是简单地将上位机的指令直接由485协议换成CAN协议转发到电机，而是通过自定义一套指令，对指令进行拆分和解码，然后再向电机发送相应的控制指令。<br>首先查看电机的数据手册。</p>
<h3 id="转矩电流控制指令"><a href="#转矩电流控制指令" class="headerlink" title="转矩电流控制指令"></a>转矩电流控制指令</h3><p><img src="https://img-blog.csdnimg.cn/20210605094724457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210605094748588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<h3 id="电机状态查询指令"><a href="#电机状态查询指令" class="headerlink" title="电机状态查询指令"></a>电机状态查询指令</h3><p><img src="https://img-blog.csdnimg.cn/20210605094828795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>发现他们的消息回复是一样的，因此收到两种消息我们可以按照同一种方式解码</p>
<h3 id="上位机向驱动板指令定义"><a href="#上位机向驱动板指令定义" class="headerlink" title="上位机向驱动板指令定义"></a>上位机向驱动板指令定义</h3><p>根据上面的指令，我们自定义了一套上位机向驱动板的指令<br>首先是转矩电流控制指令<br><img src="https://img-blog.csdnimg.cn/20210605095432342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>然后是状态查询指令<br><img src="https://img-blog.csdnimg.cn/20210605095609847.png"><br>最后电机驱动板收到电机上报的状态后，也需要通过解码最后拼接成一条指令传到上位机<br><img src="https://img-blog.csdnimg.cn/20210605100453285.png"><br>在博客中可能不太清楚，这个定义指令的文件我都会开源出来</p>
<h2 id="参考rtthread官网的UART设备的示例程序编写代码"><a href="#参考rtthread官网的UART设备的示例程序编写代码" class="headerlink" title="参考rtthread官网的UART设备的示例程序编写代码"></a>参考rtthread官网的UART设备的示例程序编写代码</h2><p><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/device/uart/uart">https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/device/uart/uart</a></p>
<p>首先定义引脚名字和设备名称</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* RS485A串口名称和收发控制引脚定义*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RS485A_UART_NAME       <span class="meta-string">&quot;uart3&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RS485A_RE_PIN GET_PIN(B,1)</span></span><br></pre></td></tr></table></figure>
<p>串口设置为DMA中断接收方式，DMA接收完成串口数据后调用<strong>完成接收中断</strong>，<strong>接收中断</strong>通过一个<strong>消息队列</strong>，向<strong>串口数据处理线程</strong>发送设备句柄和消息长度。<strong>串口数据处理线程</strong>接收到<strong>消息队列</strong>传过来的数据后完成后续的数据处理工作。这里借鉴了中断要快进快出的思想，<strong>接收中断</strong>中仅向<strong>消息队列</strong>发送消息，然后退出，<strong>串口数据处理线程</strong>完成剩余的数据处理任务，相当于是中断的底半部分。参考链接如下：<br><a target="_blank" rel="noopener" href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/interrupt/interrupt">https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/interrupt/interrupt</a><br>消息队列的消息定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 串口接收消息结构*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rs485_serial_rx_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">rt_device_t</span> dev;</span><br><span class="line">    <span class="keyword">rt_size_t</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>串口设备句柄，消息队列控制块，串口配置结构体定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 串口设备句柄 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">rt_device_t</span> rs485_serial_device_handle;</span><br><span class="line"><span class="comment">/* 消息队列控制块 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_messagequeue</span> <span class="title">rs485_serial_rx_mq</span>;</span></span><br><span class="line"><span class="comment">/* 串口配置结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">serial_configure</span> <span class="title">rs485_serial_config</span> =</span> RT_SERIAL_CONFIG_DEFAULT;</span><br></pre></td></tr></table></figure>
<p>485串口初始化配置以及数据处理线程初始化，波特率115200，8位数据位1位停止位，优先级设为6</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rs485串口接收数据线程初始化 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">rt_err_t</span> <span class="title">uart_dma_thread_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">rt_err_t</span> ret = RT_EOK;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> msg_pool[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化消息队列 */</span></span><br><span class="line">    rt_mq_init(&amp;rs485_serial_rx_mq, <span class="string">&quot;rx_mq&quot;</span>, msg_pool, <span class="comment">/* 存放消息的缓冲区 */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(struct rs485_serial_rx_msg), <span class="comment">/* 一条消息的最大长度 */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(msg_pool), <span class="comment">/* 存放消息的缓冲区大小 */</span></span><br><span class="line">    RT_IPC_FLAG_FIFO); <span class="comment">/* 如果有多个线程等待，按照先来先得到的方法分配消息 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 收发控制引脚使能并拉低 */</span></span><br><span class="line">    rt_pin_mode(RS485A_RE_PIN, PIN_MODE_OUTPUT);</span><br><span class="line">    rt_pin_write(RS485A_RE_PIN, PIN_LOW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查找串口设备 */</span></span><br><span class="line">    rs485_serial_device_handle = rt_device_find(RS485A_UART_NAME);</span><br><span class="line">    <span class="keyword">if</span> (!rs485_serial_device_handle)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;find %s failed!\n&quot;</span>, RS485A_UART_NAME);</span><br><span class="line">        <span class="keyword">return</span> RT_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 修改串口配置参数 */</span></span><br><span class="line">    rs485_serial_config.baud_rate = BAUD_RATE_115200;        <span class="comment">//修改波特率为 115200</span></span><br><span class="line">    rs485_serial_config.data_bits = DATA_BITS_8;           <span class="comment">//数据位 8</span></span><br><span class="line">    rs485_serial_config.stop_bits = STOP_BITS_1;           <span class="comment">//停止位 1</span></span><br><span class="line">    rs485_serial_config.bufsz = <span class="number">128</span>;                   <span class="comment">//修改缓冲区 buff size 为 128</span></span><br><span class="line">    rs485_serial_config.parity = PARITY_NONE;           <span class="comment">//无奇偶校验位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 控制串口设备。通过控制接口传入命令控制字，与控制参数 */</span></span><br><span class="line">    rt_device_control(rs485_serial_device_handle, RT_DEVICE_CTRL_CONFIG, &amp;rs485_serial_config);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 以 DMA接收及轮询发送方式打开串口设备 */</span></span><br><span class="line">    rt_device_open(rs485_serial_device_handle, RT_DEVICE_FLAG_DMA_RX);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置接收回调函数 */</span></span><br><span class="line">    rt_device_set_rx_indicate(rs485_serial_device_handle, uart_input);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建 serial 线程，优先级6 */</span></span><br><span class="line">    <span class="keyword">rt_thread_t</span> serial_thread_handle = rt_thread_create(<span class="string">&quot;rs485_serial&quot;</span>, rs485_serial_thread_entry, RT_NULL, <span class="number">2048</span>, <span class="number">6</span>,</span><br><span class="line">            <span class="number">10</span>);</span><br><span class="line">    <span class="comment">/* 创建成功则启动线程 */</span></span><br><span class="line">    <span class="keyword">if</span> (serial_thread_handle != RT_NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_thread_startup(serial_thread_handle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ret = RT_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面这个函数是DMA接收完成中断服务函数，本着快进快出的原则，中断函数仅将串口设备句柄和接收数据的长度发送到消息队列，数据处理线程从消息队列获取信息，完成剩下的数据处理工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 串口接收数据回调函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">rt_err_t</span> <span class="title">uart_input</span><span class="params">(<span class="keyword">rt_device_t</span> dev, <span class="keyword">rt_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rs485_serial_rx_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">rt_err_t</span> result;</span><br><span class="line">    msg.dev = dev;</span><br><span class="line">    msg.size = size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向消息队列发送消息 */</span></span><br><span class="line">    result = rt_mq_send(&amp;rs485_serial_rx_mq, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (result == -RT_EFULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 消息队列满 */</span></span><br><span class="line">        rt_kprintf(<span class="string">&quot;message queue full！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据处理线程根据上面定义的指令格式，对上位机发送过来的指令进行解码，首先判断帧头帧尾是否正确，然后判断指令类型，完成校验和的计算，最后分别向8个电机通过CAN发送相应格式的指令，最后将电机上报的状态向上位机发送。数据处理线程涉及到一些CAN的部分，这部分下一篇文章会讲，在本文中可以先忽略，重点在于<strong>接收并处理串口DMA接收的数据</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 串口处理接收数据线程入口 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rs485_serial_thread_entry</span><span class="params">(<span class="keyword">void</span> *parameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">rt_size_t</span> size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rs485_serial_rx_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_can_msg</span> <span class="title">can_tx_msg</span> =</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">rt_err_t</span> result;</span><br><span class="line">    <span class="keyword">rt_uint32_t</span> rx_length;</span><br><span class="line">    <span class="keyword">rt_uint8_t</span> check_sum, check_index;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> rx_buffer[RT_SERIAL_RB_BUFSZ + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_memset(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="comment">/* 从消息队列中读取消息*/</span></span><br><span class="line">        result = rt_mq_recv(&amp;rs485_serial_rx_mq, &amp;msg, <span class="keyword">sizeof</span>(msg), RT_WAITING_FOREVER);</span><br><span class="line">        <span class="keyword">if</span> (result == RT_EOK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//rt_kprintf(&quot;%d\n&quot;, msg.size);</span></span><br><span class="line">            <span class="comment">/* 从串口读取数据*/</span></span><br><span class="line"></span><br><span class="line">            rx_length = rt_device_read(msg.dev, <span class="number">0</span>, rx_buffer, msg.size);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ((rx_buffer[<span class="number">0</span>] == <span class="number">0x5A</span>) &amp;&amp; (rx_buffer[<span class="number">18</span>] == <span class="number">0xA5</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//rt_kprintf(&quot;recevice success\n&quot;);</span></span><br><span class="line">                <span class="comment">//判断指令类型，若不为0xFF，则是转矩控制指令,否则为状态查询指令</span></span><br><span class="line">                <span class="keyword">if</span> ((rx_buffer[<span class="number">1</span>] != <span class="number">0xFF</span>) &amp;&amp; (rx_buffer[<span class="number">17</span>] != <span class="number">0xFF</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    check_sum = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (check_index = <span class="number">1</span>; check_index &lt; <span class="number">17</span>; check_index++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        check_sum += rx_buffer[check_index];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((check_sum != rx_buffer[<span class="number">17</span>]) &amp;&amp; (rx_buffer[<span class="number">17</span>] != <span class="number">0x00</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        rt_kprintf(<span class="string">&quot;check_sum wrong\n&quot;</span>);</span><br><span class="line">                        rt_kprintf(<span class="string">&quot;%02x\n&quot;</span>, check_sum);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//rt_kprintf(&quot;check_sum right\n&quot;);</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* 向电机发送转矩电流控制数据 */</span></span><br><span class="line">                        can_tx_msg.ide = RT_CAN_STDID; <span class="comment">/* 标准格式 */</span></span><br><span class="line">                        can_tx_msg.rtr = RT_CAN_DTR; <span class="comment">/* 数据帧 */</span></span><br><span class="line">                        can_tx_msg.len = <span class="number">8</span>; <span class="comment">/* 数据长度为 8 */</span></span><br><span class="line">                        can_tx_msg.data[<span class="number">0</span>] = TORQUE_CURRENT_CMD;</span><br><span class="line">                        can_tx_msg.data[<span class="number">1</span>] = <span class="number">0x00</span>;</span><br><span class="line">                        can_tx_msg.data[<span class="number">2</span>] = <span class="number">0x00</span>;</span><br><span class="line">                        can_tx_msg.data[<span class="number">3</span>] = <span class="number">0x00</span>;</span><br><span class="line">                        can_tx_msg.data[<span class="number">6</span>] = <span class="number">0x00</span>;</span><br><span class="line">                        can_tx_msg.data[<span class="number">7</span>] = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* CAN向电机1发送数据 */</span></span><br><span class="line">                        can_tx_msg.id = MOTOR1_ID;</span><br><span class="line">                        can_tx_msg.data[<span class="number">4</span>] = rx_buffer[<span class="number">1</span>];</span><br><span class="line">                        can_tx_msg.data[<span class="number">5</span>] = rx_buffer[<span class="number">2</span>];</span><br><span class="line">                        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* CAN向电机2发送数据 */</span></span><br><span class="line">                        can_tx_msg.id = MOTOR2_ID;</span><br><span class="line">                        can_tx_msg.data[<span class="number">4</span>] = rx_buffer[<span class="number">3</span>];</span><br><span class="line">                        can_tx_msg.data[<span class="number">5</span>] = rx_buffer[<span class="number">4</span>];</span><br><span class="line">                        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* CAN向电机3发送数据 */</span></span><br><span class="line">                        can_tx_msg.id = MOTOR3_ID;</span><br><span class="line">                        can_tx_msg.data[<span class="number">4</span>] = rx_buffer[<span class="number">5</span>];</span><br><span class="line">                        can_tx_msg.data[<span class="number">5</span>] = rx_buffer[<span class="number">6</span>];</span><br><span class="line">                        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* CAN向电机4发送数据 */</span></span><br><span class="line">                        can_tx_msg.id = MOTOR4_ID;</span><br><span class="line">                        can_tx_msg.data[<span class="number">4</span>] = rx_buffer[<span class="number">7</span>];</span><br><span class="line">                        can_tx_msg.data[<span class="number">5</span>] = rx_buffer[<span class="number">8</span>];</span><br><span class="line">                        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* CAN向电机5发送数据 */</span></span><br><span class="line">                        can_tx_msg.id = MOTOR5_ID;</span><br><span class="line">                        can_tx_msg.data[<span class="number">4</span>] = rx_buffer[<span class="number">9</span>];</span><br><span class="line">                        can_tx_msg.data[<span class="number">5</span>] = rx_buffer[<span class="number">10</span>];</span><br><span class="line">                        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* CAN向电机6发送数据 */</span></span><br><span class="line">                        can_tx_msg.id = MOTOR6_ID;</span><br><span class="line">                        can_tx_msg.data[<span class="number">4</span>] = rx_buffer[<span class="number">11</span>];</span><br><span class="line">                        can_tx_msg.data[<span class="number">5</span>] = rx_buffer[<span class="number">12</span>];</span><br><span class="line">                        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* CAN向电机7发送数据 */</span></span><br><span class="line">                        can_tx_msg.id = MOTOR7_ID;</span><br><span class="line">                        can_tx_msg.data[<span class="number">4</span>] = rx_buffer[<span class="number">13</span>];</span><br><span class="line">                        can_tx_msg.data[<span class="number">5</span>] = rx_buffer[<span class="number">14</span>];</span><br><span class="line">                        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* CAN向电机8发送数据 */</span></span><br><span class="line">                        can_tx_msg.id = MOTOR8_ID;</span><br><span class="line">                        can_tx_msg.data[<span class="number">4</span>] = rx_buffer[<span class="number">15</span>];</span><br><span class="line">                        can_tx_msg.data[<span class="number">5</span>] = rx_buffer[<span class="number">16</span>];</span><br><span class="line">                        <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                        size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line">                        <span class="keyword">for</span> (check_index = <span class="number">1</span>; check_index &lt; <span class="number">33</span>; check_index++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            serial_tx_buffer[<span class="number">33</span>] += serial_tx_buffer[check_index];</span><br><span class="line">                        &#125;</span><br><span class="line">                        rt_pin_write(RS485A_RE_PIN, PIN_HIGH);<span class="comment">/*使485处于发送模式*/</span></span><br><span class="line">                        rt_device_write(rs485_serial_device_handle, <span class="number">0</span>, serial_tx_buffer, <span class="keyword">sizeof</span>(serial_tx_buffer));</span><br><span class="line">                        rt_pin_write(RS485A_RE_PIN, PIN_LOW);<span class="comment">/*使485处于接收模式*/</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* 向电机发送状态查询指令 */</span></span><br><span class="line">                    can_tx_msg.ide = RT_CAN_STDID; <span class="comment">/* 标准格式 */</span></span><br><span class="line">                    can_tx_msg.rtr = RT_CAN_DTR; <span class="comment">/* 数据帧 */</span></span><br><span class="line">                    can_tx_msg.len = <span class="number">8</span>; <span class="comment">/* 数据长度为 8 */</span></span><br><span class="line">                    can_tx_msg.data[<span class="number">0</span>] = STATE_QUEST_CMD;<span class="comment">/* 指令类型为状态查询 */</span></span><br><span class="line">                    can_tx_msg.data[<span class="number">1</span>] = <span class="number">0x00</span>;</span><br><span class="line">                    can_tx_msg.data[<span class="number">2</span>] = <span class="number">0x00</span>;</span><br><span class="line">                    can_tx_msg.data[<span class="number">3</span>] = <span class="number">0x00</span>;</span><br><span class="line">                    can_tx_msg.data[<span class="number">4</span>] = <span class="number">0x00</span>;</span><br><span class="line">                    can_tx_msg.data[<span class="number">5</span>] = <span class="number">0x00</span>;</span><br><span class="line">                    can_tx_msg.data[<span class="number">6</span>] = <span class="number">0x00</span>;</span><br><span class="line">                    can_tx_msg.data[<span class="number">7</span>] = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* CAN向电机1发送数据 */</span></span><br><span class="line">                    can_tx_msg.id = MOTOR1_ID;</span><br><span class="line">                    <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                    size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* CAN向电机2发送数据 */</span></span><br><span class="line">                    can_tx_msg.id = MOTOR2_ID;</span><br><span class="line">                    <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                    size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* CAN向电机3发送数据 */</span></span><br><span class="line">                    can_tx_msg.id = MOTOR3_ID;</span><br><span class="line">                    <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                    size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* CAN向电机4发送数据 */</span></span><br><span class="line">                    can_tx_msg.id = MOTOR4_ID;</span><br><span class="line">                    <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                    size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* CAN向电机5发送数据 */</span></span><br><span class="line">                    can_tx_msg.id = MOTOR5_ID;</span><br><span class="line">                    <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                    size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* CAN向电机6发送数据 */</span></span><br><span class="line">                    can_tx_msg.id = MOTOR6_ID;</span><br><span class="line">                    <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                    size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* CAN向电机7发送数据 */</span></span><br><span class="line">                    can_tx_msg.id = MOTOR7_ID;</span><br><span class="line">                    <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                    size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* CAN向电机8发送数据 */</span></span><br><span class="line">                    can_tx_msg.id = MOTOR8_ID;</span><br><span class="line">                    <span class="comment">/* 发送一帧 CAN 数据 */</span></span><br><span class="line">                    size = rt_device_write(can_dev, <span class="number">0</span>, &amp;can_tx_msg, <span class="keyword">sizeof</span>(can_tx_msg));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//通过485向上位机发送数据</span></span><br><span class="line">                    <span class="keyword">for</span> (check_index = <span class="number">1</span>; check_index &lt; <span class="number">33</span>; check_index++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        serial_tx_buffer[<span class="number">33</span>] += serial_tx_buffer[check_index];</span><br><span class="line">                    &#125;</span><br><span class="line">                    rt_pin_write(RS485A_RE_PIN, PIN_HIGH);<span class="comment">/*使485处于发送模式*/</span></span><br><span class="line">                    rt_device_write(rs485_serial_device_handle, <span class="number">0</span>, serial_tx_buffer, <span class="keyword">sizeof</span>(serial_tx_buffer));</span><br><span class="line">                    rt_pin_write(RS485A_RE_PIN, PIN_LOW);<span class="comment">/*使485处于接收模式*/</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BUG解决（很重要）"><a href="#BUG解决（很重要）" class="headerlink" title="BUG解决（很重要）"></a>BUG解决（很重要）</h2><p>在串口DMA接收的过程中发现一个现象，发送一个固定长度的指令，DMA中断会遇到拆包的问题，举例如下：<br>上位机发送数据：<br>0x5A    0x4C    0x04    0xB0    0x04    0x14    0x05    0x78    0x05    0xDC    0x05    0x40    0x06    0xA4    0x06    0x08    0x07    0x7A    0xA5<br>DMA会用两个中断接收数据，指令就被拆包了不能正确的译码：<br>第一次中断接收数据：0x5A    0x4C    0x04    0xB0    0x04    0x14    0x05    0x78    0x05    0xDC    0x05    0x40    0x06<br>第二次中断接收数据：0xA4    0x06    0x08    0x07    0x7A    0xA5</p>
<p>一直没能解决这个问题，最后在论坛中发现了答案，链接：<br><a target="_blank" rel="noopener" href="https://club.rt-thread.org/ask/article/307.html">https://club.rt-thread.org/ask/article/307.html</a><br><a target="_blank" rel="noopener" href="https://club.rt-thread.org/ask/question/427511.html">https://club.rt-thread.org/ask/question/427511.html</a><br>在drv_usart.c中，找到以下两个函数，分别是DMA接收完成和半完成函数，将dma_isr函数注释掉编译即可<br><img src="https://img-blog.csdnimg.cn/20210605102734599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文完成了基于rtthread的uart应用代码的编写，实现了电机驱动板和上位机通过485协议的通讯，主要是参照了rtthread官网的文档。下一篇文章实现电机驱动板和CAN电机通过CAN协议通讯，主要完成基于rtthread的CAN驱动的配置。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/04/%E5%9F%BA%E4%BA%8ERT-Thread%E7%9A%84CAN%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E6%9D%BF%E8%AE%BE%E8%AE%A1%20%EF%BC%88%E4%B8%80%EF%BC%89%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%B8%8E%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fran Hawk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张竞豪的小岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/04/%E5%9F%BA%E4%BA%8ERT-Thread%E7%9A%84CAN%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E6%9D%BF%E8%AE%BE%E8%AE%A1%20%EF%BC%88%E4%B8%80%EF%BC%89%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%B8%8E%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">基于RT-Thread的CAN电机驱动板设计 （一）需求分析与硬件设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              <time title="Erstellt: 2021-06-04 19:50:43" itemprop="dateCreated datePublished" datetime="2021-06-04T19:50:43+08:00">2021-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2021-08-13 10:01:01" itemprop="dateModified" datetime="2021-08-13T10:01:01+08:00">2021-08-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本项目依托实验室机器人比赛，需要设计一个电机驱动板，控制<strong>8个CAN协议的伺服电机</strong>。为了锻炼我对RT-Thread的使用能力同时加快开发进度，减少花费在驱动代码上的时间，电机驱动板采用了RT-Thread操作系统。</p>
<h1 id="资料连接"><a href="#资料连接" class="headerlink" title="资料连接"></a>资料连接</h1><p>本项目的所有资料全部开源：</p>
<p><strong>硬件工程</strong>：<a target="_blank" rel="noopener" href="https://lceda.cn/FranHawk/485tocan_motor_controller">https://lceda.cn/FranHawk/485tocan_motor_controller</a><br><strong>软件工程</strong>：<a target="_blank" rel="noopener" href="https://github.com/FranHawk/RT-Thread-485toCAN">https://github.com/FranHawk/RT-Thread-485toCAN</a></p>
<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><ul>
<li>PC上位机由串口通过485协议发送<strong>电机转矩电流指令</strong>到电机驱动板，电机驱动板对指令解码并通过CAN总线发送转矩控制指令</li>
<li>PC上位机由串口通过485协议发送<strong>状态查询指令</strong>到电机驱动板，电机驱动板对指令解码并通过CAN总线发送<strong>状态查询指令</strong>，电机通过CAN总线返回包括转矩电流和编码器位置在内的状态，由电机驱动板发送回上位机</li>
<li>电机驱动板为电机供电，每个电机最大电流1.5A，则总共需提供最大12A的电流<br><img src="https://img-blog.csdnimg.cn/2021060409532269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70#pic_center"></li>
</ul>
<h1 id="协议分析"><a href="#协议分析" class="headerlink" title="协议分析"></a>协议分析</h1><ul>
<li>CAN是物理层与链路层协议，一般微控制器(MCU)均带有CAN链路层外设，需要在硬件上对CAN物理层的支持</li>
<li>485是物理层协议，一般将UART作为链路层与微控制器(MCU)通讯，需在硬件上提供对485物理层的支持<h1 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h1><h2 id="硬件需求"><a href="#硬件需求" class="headerlink" title="硬件需求"></a>硬件需求</h2></li>
<li>控制：微控制器</li>
<li>通讯：485转UART芯片，CAN物理层芯片</li>
<li>调试：SWD烧写接口，复位按键，晶振，调试串口，LED<em>2，按键</em>2</li>
<li>电源：直流12V输入，提供3.3V，5V，12V供电。12V需满足电机最大电流要求。</li>
<li>接口：CAN电机接口x8，485接口x2，12V电源接口</li>
</ul>
<h2 id="硬件选型"><a href="#硬件选型" class="headerlink" title="硬件选型"></a>硬件选型</h2><h3 id="伺服电机"><a href="#伺服电机" class="headerlink" title="伺服电机"></a>伺服电机</h3><p><img src="https://img-blog.csdnimg.cn/20210604101117980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<p>采用光毓机电的<strong>RMDL伺服电机</strong>，RMD-L 伺服电机是一款高集成度的动力输出模组。集成高性能 FOC 驱动器，高功率密度无刷电机，高精度绝对位置编码器三大功能部件。突破传统分布式设计，使得终端产品结构设计更加简洁，产品内部走线更加便捷，整机性能更稳定。</p>
<h3 id="MCU"><a href="#MCU" class="headerlink" title="MCU"></a>MCU</h3><p><strong>STM32F103RET6</strong><br>由于开发时间比较短，我采用了我最常用的STM32F103RET6，它拥有一个CAN控制器，64kRAM，256kROM，满足需求，实际上RAM用不到这么大，毕竟现在芯片这么贵，其实完全可以采用相同功能但是RAM更小更便宜的芯片</p>
<h3 id="485"><a href="#485" class="headerlink" title="485"></a>485</h3><p><strong>SP3485</strong><br>参照了正点原子战舰开发板上的设计</p>
<h3 id="CAN"><a href="#CAN" class="headerlink" title="CAN"></a>CAN</h3><p><strong>TJA1050</strong><br>参照了正点原子战舰开发板上的设计,5V供电</p>
<h3 id="12V供电"><a href="#12V供电" class="headerlink" title="12V供电"></a>12V供电</h3><p>采用程控电源直接给电机驱动板提供12V供电，但是要保证电机驱动板可以通过足够大的电流，预计在PCB上采用开窗的方式加大电流承载量。</p>
<h3 id="5V-3-3V供电"><a href="#5V-3-3V供电" class="headerlink" title="5V,3.3V供电"></a>5V,3.3V供电</h3><ul>
<li><strong>TPS5430</strong>开关电源将12V降至7.3V保证供电效率</li>
<li><strong>AMS1117-5.0</strong>将7.3V降至5V</li>
<li><strong>AMS1117-3.3</strong>将5V降至3.3V</li>
</ul>
<h2 id="硬件整体结构"><a href="#硬件整体结构" class="headerlink" title="硬件整体结构"></a>硬件整体结构</h2><p><img src="https://img-blog.csdnimg.cn/20210604113617491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70#pic_center"><br>采用了两个SP3485芯片，其实一片就够用了，为了提高硬件的可扩展性，又另外加了一片</p>
<h2 id="硬件设计流程"><a href="#硬件设计流程" class="headerlink" title="硬件设计流程"></a>硬件设计流程</h2><p>采用免费的EDA软件<strong>立创EDA</strong>，可以直接从立创商城导入封装，同时可以采用浏览器编辑器，全部云端化处理，免去下载软件的麻烦。<br>完整硬件工程链接如下<br><a target="_blank" rel="noopener" href="https://oshwhub.com/FranHawk/485tocan_motor_controller">https://oshwhub.com/FranHawk/485tocan_motor_controller</a><br>接下来展示各个硬件部分的原理图。</p>
<h3 id="STM32主控部分"><a href="#STM32主控部分" class="headerlink" title="STM32主控部分"></a>STM32主控部分</h3><p><img src="https://img-blog.csdnimg.cn/20210604114546562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210604114610832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<h3 id="STM32调试部分"><a href="#STM32调试部分" class="headerlink" title="STM32调试部分"></a>STM32调试部分</h3><p><img src="https://img-blog.csdnimg.cn/20210604114653723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<h3 id="7-3V开关电源部分"><a href="#7-3V开关电源部分" class="headerlink" title="7.3V开关电源部分"></a>7.3V开关电源部分</h3><p><img src="https://img-blog.csdnimg.cn/20210604114744386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210604115400387.png"></p>
<ul>
<li>我参照了数据手册的参考设计，数据手册可以在立创商城上找。</li>
<li>其中R1，R2的计算公式如上，R1为10k，R2为2k，计算得到输出电压为7.3V。</li>
<li>这里设计的时候我设计出现了一个问题，板子到了后发现7.3V电压无法正常输出，通过查看数据手册发现ENA浮空就好了。<br><img src="https://img-blog.csdnimg.cn/20210604115615139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><h3 id="5V电源部分"><a href="#5V电源部分" class="headerlink" title="5V电源部分"></a>5V电源部分</h3><img src="https://img-blog.csdnimg.cn/20210604132526989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><h3 id="3-3V电源部分"><a href="#3-3V电源部分" class="headerlink" title="3.3V电源部分"></a>3.3V电源部分</h3><img src="https://img-blog.csdnimg.cn/20210604132603237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><h3 id="485电路部分"><a href="#485电路部分" class="headerlink" title="485电路部分"></a>485电路部分</h3><img src="https://img-blog.csdnimg.cn/20210604132744121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/2021060413280728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><h3 id="CAN电路部分"><a href="#CAN电路部分" class="headerlink" title="CAN电路部分"></a>CAN电路部分</h3><img src="https://img-blog.csdnimg.cn/20210604132852650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><h3 id="12V及CAN接口电路部分"><a href="#12V及CAN接口电路部分" class="headerlink" title="12V及CAN接口电路部分"></a>12V及CAN接口电路部分</h3><img src="https://img-blog.csdnimg.cn/20210604133050957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210604133121655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><h3 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h3><img src="https://img-blog.csdnimg.cn/20210604133322708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></li>
</ul>
<h2 id="硬件制作流程"><a href="#硬件制作流程" class="headerlink" title="硬件制作流程"></a>硬件制作流程</h2><p>采用嘉立创的PCB制版和SMT贴片，贴片的时候的BOM表和有极性的芯片贴片方向一定要仔细调整。从投板，贴片，到收到货总共花费5天时间。最终成品图如下。</p>
<h3 id="正面图"><a href="#正面图" class="headerlink" title="正面图"></a>正面图</h3><p><img src="https://img-blog.csdnimg.cn/2021060413351316.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h3 id="背面图"><a href="#背面图" class="headerlink" title="背面图"></a>背面图</h3><p><img src="https://img-blog.csdnimg.cn/20210604133536599.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70#pic_center"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/05/RISCV%20%E5%90%91%E9%87%8F%E6%8C%87%E4%BB%A4%E9%9B%86%E5%92%8CNICE%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fran Hawk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张竞豪的小岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/05/RISCV%20%E5%90%91%E9%87%8F%E6%8C%87%E4%BB%A4%E9%9B%86%E5%92%8CNICE%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">RISCV 向量指令集和NICE接口学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              <time title="Erstellt: 2021-04-05 19:50:43" itemprop="dateCreated datePublished" datetime="2021-04-05T19:50:43+08:00">2021-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2021-08-13 10:01:01" itemprop="dateModified" datetime="2021-08-13T10:01:01+08:00">2021-08-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文档链接 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42487906/article/details/115437890">https://blog.csdn.net/weixin_42487906/article/details/115437890</a></p>
<h1 id="RISCV向量指令集学习"><a href="#RISCV向量指令集学习" class="headerlink" title="RISCV向量指令集学习"></a>RISCV向量指令集学习</h1><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a target="_blank" rel="noopener" href="https://github.com/riscv/riscv-v-spec">https://github.com/riscv/riscv-v-spec</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39815222/article/details/109570539">RSIC-V——指令集spec阅读笔记——向量扩展0.9</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/140772040">RISC-V Vector Extension学习笔记</a></p>
<h3 id="向量指令集用例"><a href="#向量指令集用例" class="headerlink" title="向量指令集用例"></a>向量指令集用例</h3><p>可以对照下面的说明来看这个例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">    .balign <span class="number">4</span></span><br><span class="line">    .global vvaddint32</span><br><span class="line">    <span class="meta"># vector-vector add routine of 32-bit integers</span></span><br><span class="line">    <span class="meta"># void vvaddint32(size_t n, const int*x, const int*y, int*z)</span></span><br><span class="line">    # &#123; <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;n; i++) &#123; z[i]=x[i]+y[i]; &#125; &#125;</span><br><span class="line">    #</span><br><span class="line">    # a0 = n, a1 = x, a2 = y, a3 = z</span><br><span class="line">    # Non-<span class="built_in">vector</span> instructions are indented</span><br><span class="line">vvaddint32:</span><br><span class="line">    vsetvli t0, a0, e32, ta,ma  # Set <span class="built_in">vector</span> length based on <span class="number">32</span>-bit vectors</span><br><span class="line">    vle32.v v0, (a1)         # Get first <span class="built_in">vector</span></span><br><span class="line">      sub a0, a0, t0         # Decrement number done</span><br><span class="line">      slli t0, t0, <span class="number">2</span>         # Multiply number done by <span class="number">4</span> bytes</span><br><span class="line">      add a1, a1, t0         # Bump pointer</span><br><span class="line">    vle32.v v1, (a2)         # Get second <span class="built_in">vector</span></span><br><span class="line">      add a2, a2, t0         # Bump pointer</span><br><span class="line">    vadd.vv v2, v0, v1       # Sum vectors</span><br><span class="line">    vse32.v v2, (a3)         # Store result</span><br><span class="line">      add a3, a3, t0         # Bump pointer</span><br><span class="line">      bnez a0, vvaddint32    # Loop back</span><br><span class="line">      ret                    # Finished</span><br></pre></td></tr></table></figure>

<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>ELEN</td>
<td>向量中单个元素的最大长度，bit为单位，要求ELEN&gt;=8，且为2的幂</td>
</tr>
<tr>
<td>VLEN</td>
<td>向量寄存器的位数，bit为单位，要求VLEN ≥ ELEN，并且必须是2的幂</td>
</tr>
<tr>
<td>SLEN</td>
<td>分段距离（The striping distance in bits），要求必须为VLEN ≥ SLEN ≥ 32，并且必须为2的幂，这个暂时没懂</td>
</tr>
<tr>
<td>SEW</td>
<td>标准元素宽度，以bit为单位，指向量中一个元素占向量寄存器中的位数</td>
</tr>
<tr>
<td>LMUL</td>
<td>向量寄存器分组数</td>
</tr>
<tr>
<td>寄存器定义</td>
<td></td>
</tr>
<tr>
<td>v0-v31</td>
<td>向量数据寄存器，共32个，固定位宽为VLEN位</td>
</tr>
<tr>
<td>vtype</td>
<td>向量数据类型寄存器，并且只能通过vsetvl{i}指令进行更新，向量类型还决定了每个向量寄存器中元素的排布，以及如何对多个向量寄存器进行分组。</td>
</tr>
<tr>
<td>vsew[2：0]</td>
<td>变化的标准元素宽度（SEW, standard element width）值通过vsew中的值设置。默认情况下，向量寄存器被视为分成 VLEN / SEW 个标准宽度元素。</td>
</tr>
<tr>
<td>vlmul[2：0 ]</td>
<td>向量寄存器分组，分成一组的多个向量寄存器可以当作一个操作数来用，用来存放一个向量，该值也可以是小数，用来等效增加向量数据寄存器的数量</td>
</tr>
<tr>
<td>VLMAX</td>
<td>VLMAX = LMUL * VLEN / SEW，</td>
</tr>
<tr>
<td>vta和vma</td>
<td>这两位元素值在执行向量指令期间分别修改了目标尾部元素（Tail Elements）和非活跃的掩码元素（Inactive masked-off Elements）的行为。</td>
</tr>
<tr>
<td>vill</td>
<td>vill位用于编码先前的vsetvl{i} 指令试图向vtype写入不支持的值</td>
</tr>
<tr>
<td>vl</td>
<td>向量长度寄存器，以存放向量总共有多少个元素，只能通过vsetvli和vsetvl指令进行更新。</td>
</tr>
<tr>
<td>vlen</td>
<td>向量寄存器长度寄存器，是一个常数，保存值 VLEN / 8，即向量寄存器长度（以字节为单位）。</td>
</tr>
<tr>
<td>vstart</td>
<td>vstart是一个可读可写的CSR寄存器，指定向量指令要执行的第一个元素的索引。每个向量指令执行完后，该寄存器清零。</td>
</tr>
<tr>
<td>vcsr</td>
<td>向量控制和状态寄存器vcsr，保存定点舍入的方式和饱和状态</td>
</tr>
<tr>
<td><img src="https://img-blog.csdnimg.cn/20210405091135873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></td>
<td></td>
</tr>
<tr>
<td><img src="https://img-blog.csdnimg.cn/20210405091149965.png"></td>
<td></td>
</tr>
</tbody></table>
<h3 id="向量元素到向量寄存器的映射"><a href="#向量元素到向量寄存器的映射" class="headerlink" title="向量元素到向量寄存器的映射"></a>向量元素到向量寄存器的映射</h3><p>根据当前的 SEW 和 LMUL 设置以及 ELEN，VLEN 和 SLEN 的值，怎么将不同宽度的元素存放到矢量寄存器的字节中。并且使用最少位数的最低有效字节将元素放到每个向量寄存器中。<br>当 VLEN=SLEN ， LMUL=1 时，从向量寄存器的最低有效位到最高有效位依次对元素进行简单排布。当 LMUL &lt;1 时，仅使用向量寄存器中的第一个 LMUL * VLEN / SEW 元素。 向量寄存器中的剩余空间被视为尾部的一部分。</p>
<p><img src="https://img-blog.csdnimg.cn/20210405091302524.png"><br><img src="https://img-blog.csdnimg.cn/20210405091307804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>VLEN = SLEN 且 LMUL &gt; 1时, 将向量寄存器分组后，根据向量寄存器组中的向量寄存器来划分组中的元素。当 SLEN = VLEN 时，按元素顺序将其放在组中的每个向量寄存器中，填满一个向量寄存器后，便移至组中下一个编号最高的向量寄存器。</p>
<p><img src="https://img-blog.csdnimg.cn/20210405091326615.png"><br><img src="https://img-blog.csdnimg.cn/2021040509133320.png"><br>向量 ISA 的设计目的是支持混合宽度操作，并且不需要大量显式的额外的重排指令，也不需要大量额外的数据路径（datapath）布线。在对不同精度值的向量进行操作时，推荐的做法是动态修改 vtype 值，从而使得 SEW/LMUL 为常量（因此 VLMAX 常量）。向量寄存器分组因子（LMUL）按相关元素大小增加，这样每个向量寄存器组可以保存相同数量的向量元素（本例中 VLMAX=16 ），从而简化 stripmining 代码。下表列出了执行混合宽度操作的循环的每个可能的 SEW / LMUL 操作点。 每列代表一个恒定的 SEW / LMUL 操作点。 表中列出的内容是 LMUL 值，该值生成该列的 SEW / LMUL 值。 在同一列中， LMUL 的值不同，但 VLMAX 值相同。(可以保证每个向量寄存器组中的向量元素数量相同)<br><img src="https://img-blog.csdnimg.cn/202104050913551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210405091359401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<h3 id="配置寄存器操作指令"><a href="#配置寄存器操作指令" class="headerlink" title="配置寄存器操作指令"></a>配置寄存器操作指令</h3><p><strong>vsetvli/vsetvl</strong></p>
<h4 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vsetvli rd, rs1, vtypei <span class="meta"># rd = new vl, rs1 = AVL, vtypei = new vtype setting</span></span><br><span class="line">vsetvl  rd, rs1, rs2    <span class="meta"># rd = new vl, rs1 = AVL, rs2 = new vtype value</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210405093046399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>指令根据其参数设置 vtype 和 vl CSRs，并将 vl 的新值写入 rd。<br>两个指令的区别：vtypei是个立即数，rs2是个寄存器<br>AVL=应用程序向量长度</p>
<p>vsetvl{i}指令首先根据 vtype 参数，设定 VLMAX ，然后设置vl服从以下约束：</p>
<ul>
<li>如果 AVL ≤ VLMAX ，则 vl = AVL</li>
<li>如果 AVL &lt; (2 * VLMAX)，则ceil(AVL / 2) ≤ vl ≤ VLMAX</li>
<li>如果 AVL ≥ (2 * VLMAX)，则 vl = VLMAX</li>
<li>如果输入相同的 AVL 和 VLMAX 值，则任何实现中，v1 都是确定的<br>满足之前提及的规则：<br>如果 AVL = 0，则 vl = 0<br>如果 AVL &gt; 0，vl &gt; 0<br>vl ≤ VLMAX<br>vl ≤ AVL<br>从 vl 中读取的值（用作 vsetvl{i} 的 AVL 参数时）会在 vl 中产生相同的值，前提是所得的 VLMAX 等于读取vl时的 VLMAX 值<br><img src="https://img-blog.csdnimg.cn/20210405092012852.png"><br><img src="https://img-blog.csdnimg.cn/20210405092017271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><h3 id="向量操作指令中的掩码"><a href="#向量操作指令中的掩码" class="headerlink" title="向量操作指令中的掩码"></a>向量操作指令中的掩码</h3></li>
</ul>
<p><strong>掩码vm</strong><br>在指令中占一位，使用v0寄存器存放掩码值，vm为1时不启动掩码，vm为0时，当v0的相应位为1，目标向量寄存器写入相应的值<br><img src="https://img-blog.csdnimg.cn/2021040509214397.png"></p>
<p>掩码向量的加载操作不会更新目标向量寄存器组中的非活跃元素。掩码向量的存储操作只更新内存中的活跃元素。</p>
<h3 id="向量加载和存储指令（访存）"><a href="#向量加载和存储指令（访存）" class="headerlink" title="向量加载和存储指令（访存）"></a>向量加载和存储指令（访存）</h3><p><img src="https://img-blog.csdnimg.cn/2021040509291595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<h4 id="mop-访存时选择访存模式"><a href="#mop-访存时选择访存模式" class="headerlink" title="mop 访存时选择访存模式"></a>mop 访存时选择访存模式</h4><p><img src="https://img-blog.csdnimg.cn/20210405092427339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>支持连续访存，跨步访存和按索引访存</p>
<h4 id="lumop-sumop"><a href="#lumop-sumop" class="headerlink" title="lumop/sumop"></a>lumop/sumop</h4><p>还没搞懂是做什么用的 fault only first似乎可以简化循环操作<br><img src="https://img-blog.csdnimg.cn/20210405092653576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<h4 id="向量加载-存储的宽度编码"><a href="#向量加载-存储的宽度编码" class="headerlink" title="向量加载/存储的宽度编码"></a>向量加载/存储的宽度编码</h4><ul>
<li>Mem bits（内存位）是内存中访问的每个元素的大小。</li>
<li>Reg bits（寄存器位）是寄存器中访问的每个元素的大小。<br><img src="https://img-blog.csdnimg.cn/20210405092847625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></li>
</ul>
<h4 id="向量单步幅跨步（Unit-Stride）指令"><a href="#向量单步幅跨步（Unit-Stride）指令" class="headerlink" title="向量单步幅跨步（Unit-Stride）指令"></a>向量单步幅跨步（Unit-Stride）指令</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#vd destination, rs1 base address, vm is mask encoding (v0.t or <span class="meta-string">&lt;missing&gt;</span>)</span></span><br><span class="line">    vle32.v  vd, (rs1), vm # <span class="number">32</span>-bit loads</span><br></pre></td></tr></table></figure>

<p>l代表load，e32代表向量元素长32</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#vs3 store data, rs1 base address, <span class="function">vm is mask <span class="title">encoding</span> <span class="params">(v0.t <span class="keyword">or</span> &lt;missing&gt;)</span></span></span><br><span class="line"><span class="function">    vse64.v  vs3, <span class="params">(rs1)</span>, vm  # 64-bit stores</span></span><br></pre></td></tr></table></figure>

<p>s代表save</p>
<h4 id="向量跨步-Strided-指令"><a href="#向量跨步-Strided-指令" class="headerlink" title="向量跨步(Strided)指令"></a>向量跨步(Strided)指令</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># vd destination, rs1 base address, rs2 byte stride</span></span><br><span class="line">    vlse8.v  vd, (rs1), rs2, vm  # Load bytes separated by stride</span><br></pre></td></tr></table></figure>

<p>vls中l代表load，s代表stride，rs2存放跨步值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># vs3 store data, rs1 base address, rs2 byte stride</span><br><span class="line">    vsse128.v vs3, (rs1), rs2, vm  # Store <span class="number">128b</span> values separated by stride.</span><br></pre></td></tr></table></figure>

<p>vsse128中，第一个s是save，第二个是stride</p>
<h4 id="向量索引（indexed）指令"><a href="#向量索引（indexed）指令" class="headerlink" title="向量索引（indexed）指令"></a>向量索引（indexed）指令</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># vd destination, rs1 base address, vs2 indices</span></span><br><span class="line">    vlxei16.v  vd, (rs1), vs2, vm  # vs2 data EEW = SEW, indices EEW = <span class="number">16b</span></span><br></pre></td></tr></table></figure>

<p>有序加载，vs2存放索引，vs2中元素大小为16bit</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Vector unordered-indexed store instructions</span><br><span class="line">    vsuxei64.v vs3, (rs1), vs2, vm # SEW data, <span class="number">64b</span> indices</span><br></pre></td></tr></table></figure>

<p>无序存储，vs2中元素大小为64bit</p>
<h3 id="向量原子操作"><a href="#向量原子操作" class="headerlink" title="向量原子操作"></a>向量原子操作</h3><p>原子操作指令 暂时用不到</p>
<h3 id="向量计算指令"><a href="#向量计算指令" class="headerlink" title="向量计算指令"></a>向量计算指令</h3><p>向量的算术指令使用与 OP-FP 相邻的新的主要操作码1010111。 funct3 字段的三位用于定义向量指令的子类。<br><img src="https://img-blog.csdnimg.cn/2021040509521097.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br>向量与标量之间的运算可以采取三种可能的形式，但无论采取哪种形式，都要从 vs2 指定的向量寄存器组中获取一个操作数向量，并从三个替代源之一获取第二个标量源操作数。</p>
<ul>
<li>对于整数运算，标量可以是编码在 rs1 字段中5位立即数。该值通过符号扩展或加零扩展到SEW 位。</li>
<li>对于整数运算，可以从rs1 指定的标量寄存器x中提取标量。如果 XLEN &gt; SEW，则使用x的最低有效SEW位。如果 XLEN &lt; SEW，则x 寄存器的值通过符号扩展到 SEW 位。</li>
<li>对于浮点运算，可以从标量寄存器f中获取标量。如果 FLEN&gt; SEW，则检查f寄存器中的值是否为有效的 NaN-boxed 值，如果是，则使用f寄存器的最低有效SEW位，否则将使用规范的 NaN 值。如果执行向量指令时，任何浮点向量操作数的 EEW 都不是支持的浮点类型宽度（包括 FLEN &lt;SEW 时），则会引发非法指令异常。<h4 id="向量算术指令在vm-字段下被掩码。"><a href="#向量算术指令在vm-字段下被掩码。" class="headerlink" title="向量算术指令在vm 字段下被掩码。"></a>向量算术指令在vm 字段下被掩码。</h4></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Operations returning <span class="built_in">vector</span> results, <span class="function">masked by <span class="title">vm</span> <span class="params">(v0.t, &lt;nothing&gt;)</span></span></span><br><span class="line"><span class="function">vop.vv  vd, vs2, vs1, vm  <span class="meta"># integer vector-vector      vd[i] = vs2[i] op vs1[i]</span></span></span><br><span class="line"><span class="function">vop.vx  vd, vs2, rs1, vm  <span class="meta"># integer vector-scalar      vd[i] = vs2[i] op x[rs1]</span></span></span><br><span class="line"><span class="function">vop.vi  vd, vs2, imm, vm  <span class="meta"># integer vector-immediate   vd[i] = vs2[i] op imm</span></span></span><br></pre></td></tr></table></figure>
<h4 id="浮点指令"><a href="#浮点指令" class="headerlink" title="浮点指令"></a>浮点指令</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vfop.vv  vd, vs2, vs1, vm # FP <span class="built_in">vector</span>-<span class="built_in">vector</span> operation vd[i] = vs2[i] fop vs1[i]</span><br><span class="line">vfop.vf  vd, vs2, rs1, vm # FP <span class="built_in">vector</span>-scalar operation vd[i] = vs2[i] fop f[rs1]<span class="number">4</span></span><br></pre></td></tr></table></figure>
<h4 id="不同的指令格式"><a href="#不同的指令格式" class="headerlink" title="不同的指令格式"></a>不同的指令格式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Integer operations overwriting sum input</span><br><span class="line">vop.vv vd, vs1, vs2, vm  <span class="meta"># vd[i] = vs1[i] * vs2[i] + vd[i]</span></span><br><span class="line">vop.vx vd, rs1, vs2, vm  <span class="meta"># vd[i] = x[rs1] * vs2[i] + vd[i]</span></span><br><span class="line"></span><br><span class="line"># Integer operations overwriting product input</span><br><span class="line">vop.vv vd, vs1, vs2, vm  <span class="meta"># vd[i] = vs1[i] * vd[i] + vs2[i]</span></span><br><span class="line">vop.vx vd, rs1, vs2, vm  <span class="meta"># vd[i] = x[rs1] * vd[i] + vs2[i]</span></span><br></pre></td></tr></table></figure>

<p><strong>从指令上看没有什么区别，怎么区分二者呢</strong><br><em>通过vop的不同来区分</em></p>
<h4 id="Widening向量算术指令"><a href="#Widening向量算术指令" class="headerlink" title="Widening向量算术指令"></a>Widening向量算术指令</h4><p>一些矢量算术指令被定义为加宽（widening） 操作，其中 EEW = 2 * SEW ，EMUL = 2 * LMUL。<br>第一个操作数可以是单宽度或双宽度。这些通常在操作码上具有前缀 vw<em>，或对于矢量浮点运算具有前缀 vfw</em>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Double-width result, two single-width sources: <span class="number">2</span>*SEW = SEW op SEW</span><br><span class="line">vwop.vv  vd, vs2, vs1, vm  <span class="meta"># integer vector-vector      vd[i] = vs2[i] op vs1[i]</span></span><br><span class="line">vwop.vx  vd, vs2, rs1, vm  <span class="meta"># integer vector-scalar      vd[i] = vs2[i] op x[rs1]</span></span><br></pre></td></tr></table></figure>

<p>结果为双宽度，两个源操作数均为单宽度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Double-width result, first source <span class="keyword">double</span>-width, second source single-width: <span class="number">2</span>*SEW = <span class="number">2</span>*SEW op SEW</span><br><span class="line">vwop.wv  vd, vs2, vs1, vm  <span class="meta"># integer vector-vector      vd[i] = vs2[i] op vs1[i]</span></span><br><span class="line">vwop.wx  vd, vs2, rs1, vm  <span class="meta"># integer vector-scalar      vd[i] = vs2[i] op x[rs1]</span></span><br></pre></td></tr></table></figure>

<p>结果为双宽度，源操作数1为双宽度，源操作数2为单宽度</p>
<h4 id="Narrowing向量算术指令"><a href="#Narrowing向量算术指令" class="headerlink" title="Narrowing向量算术指令"></a>Narrowing向量算术指令</h4><p><strong>和加宽指令类似</strong><br>这些指令将 EEW/EMUL = 2 * SEW / 2 * LMUL 的向量寄存器组转换为具有当前 LMUL/SEW 向量/元素的向量寄存器组。<br>如果 EEW&gt; ELEN 或 EMUL&gt; 8，则会引发非法指令异常。</p>
<h4 id="向量单宽度加减"><a href="#向量单宽度加减" class="headerlink" title="向量单宽度加减"></a>向量单宽度加减</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Integer adds.</span><br><span class="line">vadd.vv vd, vs2, vs1, vm   # Vector-<span class="built_in">vector</span></span><br><span class="line">vadd.vx vd, vs2, rs1, vm   <span class="meta"># vector-scalar</span></span><br><span class="line">vadd.vi vd, vs2, imm, vm   <span class="meta"># vector-immediate</span></span><br><span class="line"></span><br><span class="line"># Integer subtract</span><br><span class="line">vsub.vv vd, vs2, vs1, vm   # Vector-<span class="built_in">vector</span></span><br><span class="line">vsub.vx vd, vs2, rs1, vm   <span class="meta"># vector-scalar</span></span><br><span class="line"></span><br><span class="line"># Integer reverse subtract</span><br><span class="line">vrsub.vx vd, vs2, rs1, vm   <span class="meta"># vd[i] = rs1 - vs2[i]</span></span><br><span class="line">vrsub.vi vd, vs2, imm, vm   <span class="meta"># vd[i] = imm - vs2[i]</span></span><br></pre></td></tr></table></figure>
<h4 id="向量结果加宽加减，包括有符号数和无符号数"><a href="#向量结果加宽加减，包括有符号数和无符号数" class="headerlink" title="向量结果加宽加减，包括有符号数和无符号数"></a>向量结果加宽加减，包括有符号数和无符号数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Widening <span class="keyword">unsigned</span> integer add/subtract, <span class="number">2</span>*SEW = SEW +/- SEW</span><br><span class="line">vwaddu.vv  vd, vs2, vs1, vm  <span class="meta"># vector-vector</span></span><br><span class="line">vwaddu.vx  vd, vs2, rs1, vm  <span class="meta"># vector-scalar</span></span><br><span class="line">vwsubu.vv  vd, vs2, vs1, vm  <span class="meta"># vector-vector</span></span><br><span class="line">vwsubu.vx  vd, vs2, rs1, vm  <span class="meta"># vector-scalar</span></span><br><span class="line"></span><br><span class="line"># Widening <span class="keyword">signed</span> integer add/subtract, <span class="number">2</span>*SEW = SEW +/- SEW</span><br><span class="line">vwadd.vv  vd, vs2, vs1, vm  <span class="meta"># vector-vector</span></span><br><span class="line">vwadd.vx  vd, vs2, rs1, vm  <span class="meta"># vector-scalar</span></span><br><span class="line">vwsub.vv  vd, vs2, vs1, vm  <span class="meta"># vector-vector</span></span><br><span class="line">vwsub.vx  vd, vs2, rs1, vm  <span class="meta"># vector-scalar</span></span><br><span class="line"></span><br><span class="line"># Widening <span class="keyword">unsigned</span> integer add/subtract, <span class="number">2</span>*SEW = <span class="number">2</span>*SEW +/- SEW</span><br><span class="line">vwaddu.wv  vd, vs2, vs1, vm  <span class="meta"># vector-vector</span></span><br><span class="line">vwaddu.wx  vd, vs2, rs1, vm  <span class="meta"># vector-scalar</span></span><br><span class="line">vwsubu.wv  vd, vs2, vs1, vm  <span class="meta"># vector-vector</span></span><br><span class="line">vwsubu.wx  vd, vs2, rs1, vm  <span class="meta"># vector-scalar</span></span><br><span class="line"></span><br><span class="line"># Widening <span class="keyword">signed</span> integer add/subtract, <span class="number">2</span>*SEW = <span class="number">2</span>*SEW +/- SEW</span><br><span class="line">vwadd.wv  vd, vs2, vs1, vm  <span class="meta"># vector-vector</span></span><br><span class="line">vwadd.wx  vd, vs2, rs1, vm  <span class="meta"># vector-scalar</span></span><br><span class="line">vwsub.wv  vd, vs2, vs1, vm  <span class="meta"># vector-vector</span></span><br><span class="line">vwsub.wx  vd, vs2, rs1, vm  <span class="meta"># vector-scalar</span></span><br></pre></td></tr></table></figure>
<h4 id="向量有，无符号数元素位数扩展"><a href="#向量有，无符号数元素位数扩展" class="headerlink" title="向量有，无符号数元素位数扩展"></a>向量有，无符号数元素位数扩展</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vzext.vf2 vd, vs2, vm  # Zero-extend SEW/<span class="number">2</span> source to SEW destination</span><br><span class="line">vsext.vf2 vd, vs2, vm  # Sign-extend SEW/<span class="number">2</span> source to SEW destination</span><br><span class="line">vzext.vf4 vd, vs2, vm  # Zero-extend SEW/<span class="number">4</span> source to SEW destination</span><br><span class="line">vsext.vf4 vd, vs2, vm  # Sign-extend SEW/<span class="number">4</span> source to SEW destination</span><br><span class="line">vzext.vf8 vd, vs2, vm  # Zero-extend SEW/<span class="number">8</span> source to SEW destination</span><br><span class="line">vsext.vf8 vd, vs2, vm  # Sign-extend SEW/<span class="number">8</span> source to SEW destination</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="带进位借位加减法"><a href="#带进位借位加减法" class="headerlink" title="带进位借位加减法"></a>带进位借位加减法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Produce sum with carry.</span><br><span class="line"></span><br><span class="line"> <span class="meta"># vd[i] = vs2[i] + vs1[i] + v0.mask[i]</span></span><br><span class="line"> vadc.vvm   vd, vs2, vs1, v0  # Vector-<span class="built_in">vector</span></span><br><span class="line"></span><br><span class="line"> <span class="meta"># vd[i] = vs2[i] + x[rs1] + v0.mask[i]</span></span><br><span class="line"> vadc.vxm   vd, vs2, rs1, v0  # Vector-scalar</span><br><span class="line"></span><br><span class="line"> <span class="meta"># vd[i] = vs2[i] + imm + v0.mask[i]</span></span><br><span class="line"> vadc.vim   vd, vs2, imm, v0  # Vector-immediate</span><br><span class="line"></span><br><span class="line"># Produce difference with borrow.</span><br><span class="line"></span><br><span class="line"> <span class="meta"># vd[i] = vs2[i] - vs1[i] - v0.mask[i]</span></span><br><span class="line"> vsbc.vvm   vd, vs2, vs1, v0  # Vector-<span class="built_in">vector</span></span><br><span class="line"></span><br><span class="line"> <span class="meta"># vd[i] = vs2[i] - x[rs1] - v0.mask[i]</span></span><br><span class="line"> vsbc.vxm   vd, vs2, rs1, v0  # Vector-scalar</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="位逻辑指令"><a href="#位逻辑指令" class="headerlink" title="位逻辑指令"></a>位逻辑指令</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Bitwise logical operations.</span><br><span class="line">vand.vv vd, vs2, vs1, vm   # Vector-<span class="built_in">vector</span></span><br><span class="line">vand.vx vd, vs2, rs1, vm   <span class="meta"># vector-scalar</span></span><br><span class="line">vand.vi vd, vs2, imm, vm   <span class="meta"># vector-immediate</span></span><br><span class="line"></span><br><span class="line">vor.vv vd, vs2, vs1, vm    # Vector-<span class="built_in">vector</span></span><br><span class="line">vor.vx vd, vs2, rs1, vm    <span class="meta"># vector-scalar</span></span><br><span class="line">vor.vi vd, vs2, imm, vm    <span class="meta"># vector-immediate</span></span><br><span class="line"></span><br><span class="line">vxor.vv vd, vs2, vs1, vm    # Vector-<span class="built_in">vector</span></span><br><span class="line">vxor.vx vd, vs2, rs1, vm    <span class="meta"># vector-scalar</span></span><br><span class="line">vxor.vi vd, vs2, imm, vm    <span class="meta"># vector-immediate</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="单宽度位移指令，逻辑左移，逻辑和算数右移"><a href="#单宽度位移指令，逻辑左移，逻辑和算数右移" class="headerlink" title="单宽度位移指令，逻辑左移，逻辑和算数右移"></a>单宽度位移指令，逻辑左移，逻辑和算数右移</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Bit shift operations</span><br><span class="line">vsll.vv vd, vs2, vs1, vm   # Vector-<span class="built_in">vector</span></span><br><span class="line">vsll.vx vd, vs2, rs1, vm   <span class="meta"># vector-scalar</span></span><br><span class="line">vsll.vi vd, vs2, uimm, vm   <span class="meta"># vector-immediate</span></span><br><span class="line"></span><br><span class="line">vsrl.vv vd, vs2, vs1, vm   # Vector-<span class="built_in">vector</span></span><br><span class="line">vsrl.vx vd, vs2, rs1, vm   <span class="meta"># vector-scalar</span></span><br><span class="line">vsrl.vi vd, vs2, uimm, vm   <span class="meta"># vector-immediate</span></span><br><span class="line"></span><br><span class="line">vsra.vv vd, vs2, vs1, vm   # Vector-<span class="built_in">vector</span></span><br><span class="line">vsra.vx vd, vs2, rs1, vm   <span class="meta"># vector-scalar</span></span><br><span class="line">vsra.vi vd, vs2, uimm, vm   <span class="meta"># vector-immediate</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="向量比较指令，符号左右两边分别是vs2和vs1"><a href="#向量比较指令，符号左右两边分别是vs2和vs1" class="headerlink" title="向量比较指令，符号左右两边分别是vs2和vs1"></a>向量比较指令，符号左右两边分别是vs2和vs1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># Set <span class="keyword">if</span> equal</span><br><span class="line">vmseq.vv vd, vs2, vs1, vm  # Vector-<span class="built_in">vector</span></span><br><span class="line">vmseq.vx vd, vs2, rs1, vm  <span class="meta"># vector-scalar</span></span><br><span class="line">vmseq.vi vd, vs2, imm, vm  <span class="meta"># vector-immediate</span></span><br><span class="line"></span><br><span class="line"># Set <span class="keyword">if</span> <span class="keyword">not</span> equal</span><br><span class="line">vmsne.vv vd, vs2, vs1, vm  # Vector-<span class="built_in">vector</span></span><br><span class="line">vmsne.vx vd, vs2, rs1, vm  <span class="meta"># vector-scalar</span></span><br><span class="line">vmsne.vi vd, vs2, imm, vm  <span class="meta"># vector-immediate</span></span><br><span class="line"></span><br><span class="line"># Set <span class="keyword">if</span> less than, <span class="keyword">unsigned</span></span><br><span class="line">vmsltu.vv vd, vs2, vs1, vm  # Vector-<span class="built_in">vector</span></span><br><span class="line">vmsltu.vx vd, vs2, rs1, vm  # Vector-scalar</span><br><span class="line"></span><br><span class="line"># Set <span class="keyword">if</span> less than, <span class="keyword">signed</span></span><br><span class="line">vmslt.vv vd, vs2, vs1, vm  # Vector-<span class="built_in">vector</span></span><br><span class="line">vmslt.vx vd, vs2, rs1, vm  <span class="meta"># vector-scalar</span></span><br><span class="line"></span><br><span class="line"># Set <span class="keyword">if</span> less than <span class="keyword">or</span> equal, <span class="keyword">unsigned</span></span><br><span class="line">vmsleu.vv vd, vs2, vs1, vm   # Vector-<span class="built_in">vector</span></span><br><span class="line">vmsleu.vx vd, vs2, rs1, vm   <span class="meta"># vector-scalar</span></span><br><span class="line">vmsleu.vi vd, vs2, imm, vm   # Vector-immediate</span><br><span class="line"></span><br><span class="line"># Set <span class="keyword">if</span> less than <span class="keyword">or</span> equal, <span class="keyword">signed</span></span><br><span class="line">vmsle.vv vd, vs2, vs1, vm  # Vector-<span class="built_in">vector</span></span><br><span class="line">vmsle.vx vd, vs2, rs1, vm  <span class="meta"># vector-scalar</span></span><br><span class="line">vmsle.vi vd, vs2, imm, vm  <span class="meta"># vector-immediate</span></span><br><span class="line"></span><br><span class="line"># Set <span class="keyword">if</span> greater than, <span class="keyword">unsigned</span></span><br><span class="line">vmsgtu.vx vd, vs2, rs1, vm   # Vector-scalar</span><br><span class="line">vmsgtu.vi vd, vs2, imm, vm   # Vector-immediate</span><br><span class="line"></span><br><span class="line"># Set <span class="keyword">if</span> greater than, <span class="keyword">signed</span></span><br><span class="line">vmsgt.vx vd, vs2, rs1, vm    # Vector-scalar</span><br><span class="line">vmsgt.vi vd, vs2, imm, vm    # Vector-immediate</span><br><span class="line"></span><br><span class="line"># Following two instructions are <span class="keyword">not</span> provided directly</span><br><span class="line"># Set <span class="keyword">if</span> greater than <span class="keyword">or</span> equal, <span class="keyword">unsigned</span></span><br><span class="line"><span class="meta"># vmsgeu.vx vd, vs2, rs1, vm    # Vector-scalar</span></span><br><span class="line"># Set <span class="keyword">if</span> greater than <span class="keyword">or</span> equal, <span class="keyword">signed</span></span><br><span class="line"><span class="meta"># vmsge.vx vd, vs2, rs1, vm    # Vector-scalar</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="向量找最大最小指令，最大-小结果放入vd中"><a href="#向量找最大最小指令，最大-小结果放入vd中" class="headerlink" title="向量找最大最小指令，最大/小结果放入vd中"></a>向量找最大最小指令，最大/小结果放入vd中</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Unsigned minimum</span><br><span class="line">vminu.vv vd, vs2, vs1, vm   # Vector-<span class="built_in">vector</span></span><br><span class="line">vminu.vx vd, vs2, rs1, vm   <span class="meta"># vector-scalar</span></span><br><span class="line"></span><br><span class="line"># Signed minimum</span><br><span class="line">vmin.vv vd, vs2, vs1, vm   # Vector-<span class="built_in">vector</span></span><br><span class="line">vmin.vx vd, vs2, rs1, vm   <span class="meta"># vector-scalar</span></span><br><span class="line"></span><br><span class="line"># Unsigned maximum</span><br><span class="line">vmaxu.vv vd, vs2, vs1, vm   # Vector-<span class="built_in">vector</span></span><br><span class="line">vmaxu.vx vd, vs2, rs1, vm   <span class="meta"># vector-scalar</span></span><br><span class="line"></span><br><span class="line"># Signed maximum</span><br><span class="line">vmax.vv vd, vs2, vs1, vm   # Vector-<span class="built_in">vector</span></span><br><span class="line">vmax.vx vd, vs2, rs1, vm   <span class="meta"># vector-scalar</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="向量单宽度整数乘法指​​令"><a href="#向量单宽度整数乘法指​​令" class="headerlink" title="向量单宽度整数乘法指​​令"></a>向量单宽度整数乘法指​​令</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Signed multiply, returning low bits of product</span><br><span class="line">vmul.vv vd, vs2, vs1, vm   # Vector-<span class="built_in">vector</span></span><br><span class="line">vmul.vx vd, vs2, rs1, vm   <span class="meta"># vector-scalar</span></span><br><span class="line"></span><br><span class="line"># Signed multiply, returning high bits of product</span><br><span class="line">vmulh.vv vd, vs2, vs1, vm   # Vector-<span class="built_in">vector</span></span><br><span class="line">vmulh.vx vd, vs2, rs1, vm   <span class="meta"># vector-scalar</span></span><br><span class="line"></span><br><span class="line"># Unsigned multiply, returning high bits of product</span><br><span class="line">vmulhu.vv vd, vs2, vs1, vm   # Vector-<span class="built_in">vector</span></span><br><span class="line">vmulhu.vx vd, vs2, rs1, vm   <span class="meta"># vector-scalar</span></span><br><span class="line"></span><br><span class="line"># Signed(vs2)-Unsigned multiply, returning high bits of product</span><br><span class="line">vmulhsu.vv vd, vs2, vs1, vm   # Vector-<span class="built_in">vector</span></span><br><span class="line">vmulhsu.vx vd, vs2, rs1, vm   <span class="meta"># vector-scalar</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="向量单宽度整数除法及求余数指​​令"><a href="#向量单宽度整数除法及求余数指​​令" class="headerlink" title="向量单宽度整数除法及求余数指​​令"></a>向量单宽度整数除法及求余数指​​令</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Unsigned divide.</span><br><span class="line">   vdivu.vv vd, vs2, vs1, vm   # Vector-<span class="built_in">vector</span></span><br><span class="line">   vdivu.vx vd, vs2, rs1, vm   <span class="meta"># vector-scalar</span></span><br><span class="line"></span><br><span class="line">   # Signed divide</span><br><span class="line">   vdiv.vv vd, vs2, vs1, vm   # Vector-<span class="built_in">vector</span></span><br><span class="line">   vdiv.vx vd, vs2, rs1, vm   <span class="meta"># vector-scalar</span></span><br><span class="line"></span><br><span class="line">   # Unsigned remainder</span><br><span class="line">   vremu.vv vd, vs2, vs1, vm   # Vector-<span class="built_in">vector</span></span><br><span class="line">   vremu.vx vd, vs2, rs1, vm   <span class="meta"># vector-scalar</span></span><br><span class="line"></span><br><span class="line">   # Signed remainder</span><br><span class="line">   vrem.vv vd, vs2, vs1, vm   # Vector-<span class="built_in">vector</span></span><br><span class="line">   vrem.vx vd, vs2, rs1, vm   <span class="meta"># vector-scalar</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="向量结果双宽度整数乘法指​​令"><a href="#向量结果双宽度整数乘法指​​令" class="headerlink" title="向量结果双宽度整数乘法指​​令"></a>向量结果双宽度整数乘法指​​令</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Widening <span class="keyword">signed</span>-integer multiply</span><br><span class="line">vwmul.vv  vd, vs2, vs1, vm <span class="meta"># vector-vector</span></span><br><span class="line">vwmul.vx  vd, vs2, rs1, vm <span class="meta"># vector-scalar</span></span><br><span class="line"></span><br><span class="line"># Widening <span class="keyword">unsigned</span>-integer multiply</span><br><span class="line">vwmulu.vv vd, vs2, vs1, vm <span class="meta"># vector-vector</span></span><br><span class="line">vwmulu.vx vd, vs2, rs1, vm <span class="meta"># vector-scalar</span></span><br><span class="line"></span><br><span class="line"># Widening <span class="keyword">signed</span>-<span class="keyword">unsigned</span> integer multiply</span><br><span class="line">vwmulsu.vv vd, vs2, vs1, vm <span class="meta"># vector-vector</span></span><br><span class="line">vwmulsu.vx vd, vs2, rs1, vm <span class="meta"># vector-scalar</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="向量单宽度整数乘加指令"><a href="#向量单宽度整数乘加指令" class="headerlink" title="向量单宽度整数乘加指令"></a>向量单宽度整数乘加指令</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Integer multiply-add, overwrite addend</span><br><span class="line">vmacc.vv vd, vs1, vs2, vm    <span class="meta"># vd[i] = +(vs1[i] * vs2[i]) + vd[i]</span></span><br><span class="line">vmacc.vx vd, rs1, vs2, vm    <span class="meta"># vd[i] = +(x[rs1] * vs2[i]) + vd[i]</span></span><br><span class="line"></span><br><span class="line"># Integer multiply-sub, overwrite minuend</span><br><span class="line">vnmsac.vv vd, vs1, vs2, vm    <span class="meta"># vd[i] = -(vs1[i] * vs2[i]) + vd[i]</span></span><br><span class="line">vnmsac.vx vd, rs1, vs2, vm    <span class="meta"># vd[i] = -(x[rs1] * vs2[i]) + vd[i]</span></span><br><span class="line"></span><br><span class="line"># Integer multiply-add, overwrite multiplicand</span><br><span class="line">vmadd.vv vd, vs1, vs2, vm    <span class="meta"># vd[i] = (vs1[i] * vd[i]) + vs2[i]</span></span><br><span class="line">vmadd.vx vd, rs1, vs2, vm    <span class="meta"># vd[i] = (x[rs1] * vd[i]) + vs2[i]</span></span><br><span class="line"></span><br><span class="line"># Integer multiply-sub, overwrite multiplicand</span><br><span class="line">vnmsub.vv vd, vs1, vs2, vm    <span class="meta"># vd[i] = -(vs1[i] * vd[i]) + vs2[i]</span></span><br><span class="line">vnmsub.vx vd, rs1, vs2, vm    <span class="meta"># vd[i] = -(x[rs1] * vd[i]) + vs2[i]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="向量加宽整数乘加指令"><a href="#向量加宽整数乘加指令" class="headerlink" title="向量加宽整数乘加指令"></a>向量加宽整数乘加指令</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Widening <span class="keyword">unsigned</span>-integer multiply-add, overwrite addend</span><br><span class="line">vwmaccu.vv vd, vs1, vs2, vm    <span class="meta"># vd[i] = +(vs1[i] * vs2[i]) + vd[i]</span></span><br><span class="line">vwmaccu.vx vd, rs1, vs2, vm    <span class="meta"># vd[i] = +(x[rs1] * vs2[i]) + vd[i]</span></span><br><span class="line"></span><br><span class="line"># Widening <span class="keyword">signed</span>-integer multiply-add, overwrite addend</span><br><span class="line">vwmacc.vv vd, vs1, vs2, vm    <span class="meta"># vd[i] = +(vs1[i] * vs2[i]) + vd[i]</span></span><br><span class="line">vwmacc.vx vd, rs1, vs2, vm    <span class="meta"># vd[i] = +(x[rs1] * vs2[i]) + vd[i]</span></span><br><span class="line"></span><br><span class="line"># Widening <span class="keyword">signed</span>-<span class="keyword">unsigned</span>-integer multiply-add, overwrite addend</span><br><span class="line">vwmaccsu.vv vd, vs1, vs2, vm  <span class="meta"># vd[i] = +(signed(vs1[i]) * unsigned(vs2[i])) + vd[i]</span></span><br><span class="line">vwmaccsu.vx vd, rs1, vs2, vm  <span class="meta"># vd[i] = +(signed(x[rs1]) * unsigned(vs2[i])) + vd[i]</span></span><br><span class="line"></span><br><span class="line"># Widening <span class="keyword">unsigned</span>-<span class="keyword">signed</span>-integer multiply-add, overwrite addend</span><br><span class="line">vwmaccus.vx vd, rs1, vs2, vm  <span class="meta"># vd[i] = +(unsigned(x[rs1]) * signed(vs2[i])) + vd[i]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="向量整数合并指令"><a href="#向量整数合并指令" class="headerlink" title="向量整数合并指令"></a>向量整数合并指令</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vmerge.vvm vd, vs2, vs1, v0  <span class="meta"># vd[i] = v0.mask[i] ? vs1[i] : vs2[i]</span></span><br><span class="line">vmerge.vxm vd, vs2, rs1, v0  <span class="meta"># vd[i] = v0.mask[i] ? x[rs1] : vs2[i]</span></span><br><span class="line">vmerge.vim vd, vs2, imm, v0  <span class="meta"># vd[i] = v0.mask[i] ? imm    : vs2[i]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="向量整数移动指令"><a href="#向量整数移动指令" class="headerlink" title="向量整数移动指令"></a>向量整数移动指令</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vmv.v.v vd, vs1 <span class="meta"># vd[i] = vs1[i]</span></span><br><span class="line">vmv.v.x vd, rs1 <span class="meta"># vd[i] = rs1</span></span><br><span class="line">vmv.v.i vd, imm <span class="meta"># vd[i] = imm</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="整数标量移动指令"><a href="#整数标量移动指令" class="headerlink" title="整数标量移动指令"></a>整数标量移动指令</h4><p>整数标量读/写指令在标量x寄存器和向量寄存器的元素0之间传输单个值。指令忽略LMUL和向量寄存器组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vmv.xs rd，vs2＃x [rd] = vs2 [<span class="number">0</span>]（vs1 = <span class="number">0</span>）</span><br><span class="line">vmv.sx vd，rs1＃vd [<span class="number">0</span>] = x [rs1]（vs2 = <span class="number">0</span>）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ol>
<li>向量的加载和存储，支持跨步，按索引范存（访存操作</li>
<li>向量单个元素位宽可指定（8bit，32bit)/可能支持向量寄存器分组</li>
<li>向量之间/向量和常数的加减乘除运算</li>
<li>向量之间/向量和常数的比较运算</li>
<li>向量自身所有元素求和</li>
<li>向量元素的位逻辑运算</li>
<li>求向量中，向量元素的最大最小值</li>
</ol>
<h4 id="RISCV指令格式"><a href="#RISCV指令格式" class="headerlink" title="RISCV指令格式"></a>RISCV指令格式</h4><p><img src="https://img-blog.csdnimg.cn/20210405185250929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210405185317370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></p>
<ul>
<li>给用户自定义的指令操作码为Custom-0, Custom-1, Custom-2, Custom-3</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wire opcode_custom0 = (opcode == <span class="number">7&#x27;b</span>0001011); </span><br><span class="line">wire opcode_custom1 = (opcode == <span class="number">7&#x27;b</span>0101011); </span><br><span class="line">wire opcode_custom2 = (opcode == <span class="number">7&#x27;b</span>1011011); </span><br><span class="line">wire opcode_custom3 = (opcode == <span class="number">7&#x27;b</span>1111011);</span><br></pre></td></tr></table></figure>
<ul>
<li>操作码如上，操作码定义为Custom-0, Custom-1, Custom-2, Custom-3，其余部分可仿照向量指令集，指令集主要由func3和func7区分</li>
<li>根据NICE示例代码可知，指令格式可为任意种类指令格式，但是文档中给出，指令格式仅使用R格式指令<br><img src="https://img-blog.csdnimg.cn/2021040518563613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ4NzkwNg==,size_16,color_FFFFFF,t_70"></li>
</ul>
<h4 id="指令预设"><a href="#指令预设" class="headerlink" title="指令预设"></a>指令预设</h4><h5 id="访存指令"><a href="#访存指令" class="headerlink" title="访存指令"></a>访存指令</h5><p>向量的加载和存储，支持跨步，按索引范存（访存操作<br>占用一个custom操作数，custom1</p>
<ol>
<li>5bit保存要加载/存储的内存地址的寄存器编号</li>
<li>5bit保存若跨步访存的步长所在的寄存器编号/或按索引访存所存放索引的向量寄存器地址</li>
<li>5bit保存要存或取数据的向量寄存器的编号</li>
<li>2bit编码向量元素宽度</li>
<li>2bit编码采用连续访存还是跨步访存还是索引范存</li>
<li>1bit编码读操作还是写操作<br>按上述要求，采用R指令，1.2.3分给rs1，rs2，rs3，456分给func7</li>
</ol>
<h5 id="3-4-5-6"><a href="#3-4-5-6" class="headerlink" title="3.4.5.6."></a>3.4.5.6.</h5><p>也可采用R型指令，可分给custom2.3.4，具体指令类型由fun7指定（待定</p>
<h1 id="NICE接口学习"><a href="#NICE接口学习" class="headerlink" title="NICE接口学习"></a>NICE接口学习</h1><p>NICE接口官方给出了较详细的文档说明<br>芯来官方资料汇总 <a target="_blank" rel="noopener" href="https://www.rvmcu.com/community-topic-id-340.html">https://www.rvmcu.com/community-topic-id-340.html</a><br>官方文档说明 <a target="_blank" rel="noopener" href="https://doc.nucleisys.com/hbirdv2/core/core.html#nice">https://doc.nucleisys.com/hbirdv2/core/core.html#nice</a><br>nice协处理器实现示例 <a target="_blank" rel="noopener" href="https://github.com/riscv-mcu/e203_hbirdv2/tree/master/rtl/e203/subsys">https://github.com/riscv-mcu/e203_hbirdv2/tree/master/rtl/e203/subsys</a><br>协处理器使用示例 <a target="_blank" rel="noopener" href="https://github.com/Nuclei-Software/nuclei-board-labs/tree/master/e203_hbirdv2/common">https://github.com/Nuclei-Software/nuclei-board-labs/tree/master/e203_hbirdv2/common</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/09/RT-Thread%20ART-PI%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AFTP%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fran Hawk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张竞豪的小岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/09/RT-Thread%20ART-PI%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AFTP%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">RT-Thread ART-PI 学习笔记：FTP功能和RTTstudio Git插件使用和配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              <time title="Erstellt: 2021-02-09 19:50:43" itemprop="dateCreated datePublished" datetime="2021-02-09T19:50:43+08:00">2021-02-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2021-08-16 22:19:39" itemprop="dateModified" datetime="2021-08-16T22:19:39+08:00">2021-08-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在之前的学习中，初步掌握了对文件系统的使用和配置，并将AP6126作为WiFi网卡上网。SD卡和flash作为文件的存储载体，若想向其中置入文件，SD卡通常采用读卡器的方式向其中置入文件，而flash需要通过更为复杂些烧写算法才能向flash里置入文件。rtthread提供了FTP服务器功能的软件包，可以在嵌入式平台上开启一个FTP服务器，电脑端通过网络和FTP工具向板子上已经挂载到文件系统的SD卡和flash上烧写文件。</p>
<p>同时本文还将记录RT-Thread Git工具的使用</p>
<p>在实验过程中也借鉴了不少大佬博客里的操作，在这里感谢他们的分享</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a target="_blank" rel="noopener" href="https://club.rt-thread.org/ask/article/2429.html">Art_Pi学习笔记3：学习驱动wifi模块AP6212</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_31039061/article/details/109923612">【STM32H750】玩转ART-Pi（六）——添加FTP服务器</a></p>
<h1 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h1><p>本文演示代码：<a target="_blank" rel="noopener" href="https://download.csdn.net/download/weixin_42487906/21110783?spm=1001.2014.3001.5503">https://download.csdn.net/download/weixin_42487906/21110783?spm=1001.2014.3001.5503</a></p>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul>
<li>RT-Thread Studio 2.1.1：一站式的 RT-Thread 开发工具，通过简单易用的图形化配置系统以及丰富的软件包和组件资源，让物联网开发变得简单和高效。<a target="_blank" rel="noopener" href="https://www.rt-thread.org/page/studio.html">官网链接</a></li>
<li>Xshell或类似的串口调试工具</li>
<li>Xftp或teamView等电脑端ftp工具</li>
</ul>
<h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul>
<li>RT-Thread 推出的ART-PI STM32H750开发板</li>
</ul>
<h1 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>创建基于开发板的项目，BSP版本为1.2.1，基于art-pi-wifi示例创建项目，这样就不用手动配置wifi模块了，并且示例项目带自动重连功能</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815104631082.png" alt="image-20210815104631082" style="zoom: 67%;" />



<p>编译进开发板后串口持续显示没有找到wifi，并且阻碍finsh的输入，下面分析原因</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815105606468.png" alt="image-20210815105606468" style="zoom:50%;" />

<p>这块开发板我再其他地方使用过，链接的是当时那个地方的wifi，wifi帐号和密码已经被记录在flash里面，为了重新链接我现在位置的wifi，我使用另外一个串口输入输出不冲突的串口终端链接新的wifi如下图</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815110422975.png" alt="image-20210815110422975" style="zoom:50%;" />

<p>新的wifi链接成功</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815110542657.png" alt="image-20210815110542657" style="zoom:50%;" />

<h2 id="配置文件系统"><a href="#配置文件系统" class="headerlink" title="配置文件系统"></a>配置文件系统</h2><p>使能sdcard和flash文件系统</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815165428028.png" alt="image-20210815165428028" style="zoom: 67%;" />

<p>软件包中多出了littlefs这个文件系统，他是用来挂载板子上16MB的NOR Flash的其中一个分区的</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815110644084.png" alt="image-20210815110644084" style="zoom:50%;" />

<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815111054164.png" alt="image-20210815111054164"></p>
<p>16MB的NOR FLASH分区如下图，其中easyflash也管理着其中的一个分区，可以用来保存wifi密码等一些参数</p>
<p>而fliesystem分区就是被littlefs文件系统管理，最后将这个分区挂载到\flash这个文件夹中</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815112003545.png" alt="image-20210815112003545" style="zoom:50%;" />

<p>编译并烧写程序</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815111910839.png" alt="image-20210815111910839" style="zoom: 50%;" />

<p>mount to ‘/flash’ success，现在是没插sd卡，虽然ls发现根文件系统中有两个目录，但是只有flash实现了挂载，没有插sd卡所以sdcard是不能用的</p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815112146462.png" alt="image-20210815112146462"></p>
<p>若sd卡插上了串口终端会显示上面的信息</p>
<h2 id="配置FTP服务器"><a href="#配置FTP服务器" class="headerlink" title="配置FTP服务器"></a>配置FTP服务器</h2><p>使能FTP Library</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815112658540.png" alt="image-20210815112658540" style="zoom: 67%;" />

<p><a target="_blank" rel="noopener" href="https://github.com/loogg/agile_ftp">FTP库 github仓库</a></p>
<p>使用说明如下图</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815112539915.png" alt="image-20210815112539915" style="zoom:50%;" />

<p>根据使用说明，在mian.c中添加如下代码</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815114013583.png" alt="image-20210815114013583" style="zoom: 67%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ftp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ART_PI_USING_FTP_LIB</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftp_server</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ftp_init(<span class="number">2048</span>,<span class="number">27</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MSH_CMD_EXPORT(ftp_server,start ftp server)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>编译并烧写进板子</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815114128568.png" alt="image-20210815114128568" style="zoom:50%;" />

<p>命令行输入ftp_server启动FTP服务器，看到板子连上wifi，ip地址为192.168.1.103</p>
<h2 id="电脑端连接FTP服务器"><a href="#电脑端连接FTP服务器" class="headerlink" title="电脑端连接FTP服务器"></a>电脑端连接FTP服务器</h2><p>电脑和开发板连接同一个wifi</p>
<p>打开xftp或者类似的ftp工具，输入开发板的ip地址，输入用户名，密码，默认都是loogg</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815114646375.png" alt="image-20210815114646375" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815114916400.png" alt="image-20210815114916400" style="zoom:50%;" />

<p><strong>记得不要勾选 使用被动模式</strong>，点击连接，就可以访问开发板上的文件系统了，可以相互传输文件</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815115020326.png" alt="image-20210815115020326" style="zoom:50%;" />

<h2 id="RT-Thread-Git工具的使用"><a href="#RT-Thread-Git工具的使用" class="headerlink" title="RT-Thread Git工具的使用"></a>RT-Thread Git工具的使用</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Mculover666/article/details/104427445?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162900356016780261970807%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=162900356016780261970807&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-2-104427445.pc_v2_rank_blog_default&utm_term=git&spm=1018.2226.3001.4450">参考博客</a></p>
<p>git工具可以便捷地向管理软件版本，这里记录git工具的使用过程</p>
<p>在工程右键打开小组，选择共享项目</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815130003495.png" alt="image-20210815130003495" style="zoom:50%;" />

<p>创建代码仓库</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815130318846.png" alt="image-20210815130318846" style="zoom:50%;" />

<p>然后点击完成，这时候小组下就出现了git的相关操作</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815130536632.png" alt="image-20210815130536632" style="zoom:50%;" />

<p>点击提交</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815130725588.png" alt="image-20210815130725588" style="zoom:50%;" />

<p>输入落实消息，点击commit提交到本地仓库，若配置了远程仓库如github，可以点击commit and push 提交到远端仓库</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815130953140.png" alt="image-20210815130953140" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815131501662.png" alt="image-20210815131501662" style="zoom:50%;" />

<p>在Show in history中可以看到提交记录</p>
<p>在github上创建一个代码仓库，clone这个仓库的git地址</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815132054813.png" alt="image-20210815132054813" style="zoom:50%;" />

<p>在rtt studio的git 存储库右键远程仓库，点击create remote</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815132125822.png" alt="image-20210815132125822" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815132144117.png" alt="image-20210815132144117" style="zoom:50%;" />

<p>将github仓库地址复制进去，要注意最近github不再允许采用邮箱和密码的方式访问，要申请一个token或ssl密钥，这个要各位再去查下该怎么操作</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815132256369.png" alt="image-20210815132256369" style="zoom:50%;" />

<p>设置完成后点击保存，完成与远程仓库的连接</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815132330901.png" alt="image-20210815132330901" style="zoom:50%;" />

<p>可以看到已经创建成功</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815132406728.png" alt="image-20210815132406728" style="zoom:67%;" />

<p>在小组中点击push，代码上传到github上</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815132434153.png" alt="image-20210815132434153" style="zoom:67%;" />

<p>点击Preview</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815132505838.png" alt="image-20210815132505838" style="zoom:67%;" />

<p>点击推送</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815132529075.png" alt="image-20210815132529075" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815145212408.png" alt="image-20210815145212408" style="zoom:50%;" />

<p>完成后进入github可以看到已经上传成功</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/09/RT-Thread%20ART-PI%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9ATouchGFX%E4%BB%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fran Hawk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张竞豪的小岛">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/09/RT-Thread%20ART-PI%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9ATouchGFX%E4%BB%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87/" class="post-title-link" itemprop="url">RT-Thread ART-PI 学习笔记：TouchGFX通过文件系统读取图片</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              <time title="Erstellt: 2021-02-09 19:50:43" itemprop="dateCreated datePublished" datetime="2021-02-09T19:50:43+08:00">2021-02-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2021-08-16 22:21:18" itemprop="dateModified" datetime="2021-08-16T22:21:18+08:00">2021-08-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>TouchGFX界面中可能会存在占用空间比较大的图片资源，在默认情况下，图片资源会随着其他只读数据一起放入芯片的已经经过内存映射的闪存中，系统可以直接通过地址访问到图片</p>
<p>这个机制虽然对art-pi没什么影响，因为art-pi的只读段放在片外空间比较大的8M NOR FLASH里，空间还算大。而且这块FLASH因为是NOR FLASH，经过内存映射，也可以通过地址直接访问指令和数据，和片内ROM的访问方式一样了。这就是是常说的代码(.text段)在片外flash上运行</p>
<p>但是对于ROM空间比较小的单片机，还没有外挂flash，内部空间捉襟见肘，就需要考虑采用把图片放入sd卡等非内存映射的闪存中以节省空间</p>
<p>TouchGFX提供了一种位图缓存机制，允许把图片放入sd卡等非内存映射的缓存中，系统上电时将部分或全部图片放在位于RAM的位图缓存中</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_31039061/article/details/109763842">【STM32H750】玩转ART-Pi（七）——TouchGFX从文件系统中读取图片</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_31039061/article/details/108638097">【STM32H750】玩转ART-Pi（三）——如何在ART-PI上创建TouchGFX工程</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lzs940320/article/details/112437259">14.RT-thread项目实战–TouchGFx界面效果优化</a></p>
<p>上面两篇博客用的方法都是依据touchgfx官方文档的步骤，我觉得可以主要参考官方文档，上面两篇博客描述的步骤已经很详细了，但是还是有一点不足之处，这个我在后面会提到</p>
<p><a target="_blank" rel="noopener" href="https://support.touchgfx.com/4.16/docs/development/scenarios/using-non-memory-mapped-flash">使用非内存映射闪存存储图像</a></p>
<p><a target="_blank" rel="noopener" href="https://support.touchgfx.com/4.16/docs/development/ui-development/touchgfx-engine-features/caching-bitmaps">缓存位图</a></p>
<p>上面两篇是官方文档，教的过程已经比较详细了，实践时只用稍作改动，下面我的操作都是按照官方文档来的</p>
<h1 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h1><p>本文演示代码<a target="_blank" rel="noopener" href="https://download.csdn.net/download/weixin_42487906/21110777?spm=1001.2014.3001.5503">https://download.csdn.net/download/weixin_42487906/21110777?spm=1001.2014.3001.5503</a></p>
<p>一定要在sd卡或者16M nor flash里面有相应图片的二进制bin文件这个工程才可以正常运行，如何操作见我的这篇博客</p>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul>
<li>RT-Thread Studio 2.1.1：一站式的 RT-Thread 开发工具，通过简单易用的图形化配置系统以及丰富的软件包和组件资源，让物联网开发变得简单和高效。<a target="_blank" rel="noopener" href="https://www.rt-thread.org/page/studio.html">官网链接</a></li>
<li>touchgfx designer 4.16：touchgfx 界面设计工具，去官网上下载就可以了,版本不能低于4.15 <a target="_blank" rel="noopener" href="https://www.st.com/zh/development-tools/touchgfxdesigner.html">官网链接</a></li>
</ul>
<h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul>
<li>RT-Thread 推出的ART-PI STM32H750开发板</li>
<li>正点原子 800*480 4.3寸 RGBLCD屏，搭载GT9147触摸芯片</li>
</ul>
<p><strong>在进行本篇操作之前必须配置文件系统，wifi功能和ftp服务器，并且使能touchgfx库，这几个操作在我之前的学习笔记中都有讲</strong></p>
<p><strong>同时我使用1.10版本的BSP，最新的1.21版本在配置touchgfx后会报错不知道问题出在哪里</strong></p>
<h1 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h1><p>在配置完touchgfx图形库后，用touchgfx designer 打开art_pi.touchgfx</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815182832479.png" alt="image-20210815182832479" style="zoom: 67%;" />

<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815184154449.png" alt="image-20210815184154449"></p>
<p>可以看到默认工程中有几张png格式的位图资源，下面我们就把他们转移到sd卡或者flash里面去</p>
<p>首先根据官方文档修改连接器脚本</p>
<p>默认情况下，TouchGFX中的所有位图都放入ExtFlashSection中，标准的链接描述文件（此处为GCC）将其他只读数据一起放入闪存。</p>
<p>下面我们把数据放在0x9A000000的ExtFlashSection中</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815184100882.png" alt="image-20210815184100882" style="zoom: 67%;" />

<p>根据官方文档，打开link.lds连接脚本，添加一块名为USB的存储区域，可读可写可执行</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815184306491.png" alt="image-20210815184306491" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815184459354.png" alt="image-20210815184459354" style="zoom: 67%;" />

<p>不用担心这块存储区域会占用系统资源，因为虽然链接产生的elf文件中会多一个USB段，但是最后烧进板子里的是elf经过objcopy处理生成的bin文件，这个文件只会包含图中的ROM和RAM段</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815184427238.png" alt="image-20210815184427238" style="zoom:67%;" />

<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815195956496.png" alt="image-20210815195956496"></p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815200536137.png" alt="image-20210815200536137"></p>
<p>虽然图片文件根据lds文件链接到elf中，但是并不会被烧写到板子中，程序运行时并没有操作系统，不会像电脑那样将elf文件自动解析并将各个段放到ram和rom的指定位置。而是根据上图，elf会经过objcopy文件将RAM，ROM等可存储区域提取到rtthread.bin这个二进制文件中去，由烧写算法烧写到板子的制定位置。而USB区域并不会被烧写到板子中，这一步结束后需要用objcopy将 ExtFlashSection 段提取到一个二进制文件中，在rtthread里面是rtthread.bin,再把这个二进制文件放到SD卡或者flash里面，供程序读取。</p>
<p>编译时的命令，从上图可以看到使用了objcopy</p>
<p>上面的操作完成后，用记事本等文本编辑器打开link.lds</p>
<p>根据touchgfx官网的文档，将以下代码添加到link.lds的__bss_start = .; 和 _end = .;之间,最终效果如第三张图</p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815184751840.png" alt="image-20210815184751840"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExtFlashSection :</span><br><span class="line">&#123;</span><br><span class="line">	KEEP(*(ExtFlashSection.*))</span><br><span class="line">	. = ALIGN(4);</span><br><span class="line">&#125; &gt; USB</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815185528288.png" alt="image-20210815185528288" style="zoom: 50%;" />

<p>重新编译链接工程，打开rtthread.map看看ExtFlashSection被链接到哪个地址了</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815190141050.png" alt="image-20210815190141050" style="zoom: 67%;" />

<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815190204654.png" alt="image-20210815190204654" style="zoom: 67%;" />

<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815190502382.png" alt="image-20210815190502382"></p>
<p>在rtthread.map文件中搜索ExtFlashSection可以发现几个图片文件被连接到0x9a000000的位置，总大小为0x68230=426544字节</p>
<p><strong>在rtthread studio中配置如下命令将ExtFlashSection从elf文件中拷贝出来</strong></p>
<p>相当于将生成的图片二进制文件从elf里整出来，好放到sdcard等位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-none-eabi-objcopy -O binary -j ExtFlashSection &quot;$&#123;BuildArtifactFileBaseName&#125;.elf&quot; &quot;images.bin&quot;</span><br></pre></td></tr></table></figure>

<p>通过查阅objcopy指令可以得知上述指令是将ExtFlashSection这个段以二进制文件的方式复制出来</p>
<p>objcopy参考博客：</p>
<p><a target="_blank" rel="noopener" href="http://www.manongjc.com/detail/22-pohrelllskvguhd.html">http://www.manongjc.com/detail/22-pohrelllskvguhd.html</a></p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815194454891.png" alt="image-20210815194454891"></p>
<p>把这个命令添加到构建后步骤</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815200728843.png" alt="image-20210815200728843" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815200831266.png" alt="image-20210815200831266" style="zoom:67%;" />

<p>重新编译可以看到新添加的命令被执行</p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815203432962.png" alt="image-20210815203432962"></p>
<p>DEBUG目录下生成了images.bin二进制文件</p>
<p>在TouchGFXHAL.cpp中添加如下代码，改掉blockcopy函数</p>
<p><strong>新的blockCopy函数我参考了上面的两篇博客，这两篇博客中提到他们改过的blockCopy方法可以在检查完sd卡有没有相应文件后再去flash中检查，但是在实际用的时候，并不能读到flash里面的文件，看下了发现是代码逻辑问题，于是我改正了一下，下面的代码可以实现若sd卡未挂载或未存在相应文件时去flash查找</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dfs_posix.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TouchGFXHAL::blockCopy</span><span class="params">(<span class="keyword">void</span>* RESTRICT dest, <span class="keyword">const</span> <span class="keyword">void</span>* RESTRICT src, <span class="keyword">uint32_t</span> numBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> dataOffset = (<span class="keyword">uint32_t</span>) src;</span><br><span class="line">    <span class="keyword">if</span> (dataOffset &gt;= <span class="number">0x9A000000</span> &amp;&amp; dataOffset &lt; <span class="number">0xA0000000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">statfs</span> <span class="title">buffer</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (rt_device_find(<span class="string">&quot;sd0&quot;</span>) != RT_NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((dfs_statfs(<span class="string">&quot;/sdcard&quot;</span>, &amp;buffer) == RT_EOK) | (dfs_mount(<span class="string">&quot;sd0&quot;</span>, <span class="string">&quot;/sdcard&quot;</span>, <span class="string">&quot;elm&quot;</span>, <span class="number">0</span>, <span class="number">0</span>) == RT_EOK))</span><br><span class="line">            &#123;</span><br><span class="line">                fd = open(<span class="string">&quot;/sdcard/images.bin&quot;</span>, O_RDONLY, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//rt_kprintf(&quot;open file from sdcard failed,find from /flash\n&quot;);</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dataOffset = dataOffset - <span class="number">0x9A000000</span>;</span><br><span class="line">                    lseek(fd, dataOffset, SEEK_SET);</span><br><span class="line">                    <span class="comment">// for copying data from there.</span></span><br><span class="line">                    read(fd, (<span class="keyword">uint8_t</span> *) dest, numBytes);</span><br><span class="line">                    close(fd);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dfs_statfs(<span class="string">&quot;/flash&quot;</span>, &amp;buffer) == RT_EOK)</span><br><span class="line">        &#123;</span><br><span class="line">            fd = open(<span class="string">&quot;/flash/images.bin&quot;</span>, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                rt_kprintf(<span class="string">&quot;open file for read failed\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dataOffset = dataOffset - <span class="number">0x9A000000</span>;</span><br><span class="line">            lseek(fd, dataOffset, SEEK_SET);</span><br><span class="line">            <span class="comment">// for copying data from there.</span></span><br><span class="line">            read(fd, (<span class="keyword">uint8_t</span> *) dest, numBytes);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// For all other addresses, just use the default implementation.</span></span><br><span class="line">        <span class="comment">// This is important, as blockCopy is also used for other things in the core framework.</span></span><br><span class="line">        <span class="keyword">return</span> TouchGFXGeneratedHAL::blockCopy(dest, src, numBytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过我列出的第二个touchgfx官方文档，将TouchGFXHAL.cpp中的TouchGFXHAL::initialize()改为下面的，启用和配置位图缓存，并且分配一块新的缓存区域设置位图缓存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TouchGFXHAL::initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Calling parent implementation of initialize().</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// To overwrite the generated implementation, omit call to parent function</span></span><br><span class="line">    <span class="comment">// and implemented needed functionality here.</span></span><br><span class="line">    <span class="comment">// Please note, HAL::initialize() must be called to initialize the framework.</span></span><br><span class="line"> </span><br><span class="line">    TouchGFXGeneratedHAL::initialize();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">uint16_t</span>* cacheStartAddr =(<span class="keyword">uint16_t</span> *)rt_malloc(<span class="number">0x1400000</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> cacheSize = <span class="number">0x1400000</span>;</span><br><span class="line"> </span><br><span class="line">    Bitmap::removeCache();</span><br><span class="line">    Bitmap::setCache(cacheStartAddr,cacheSize,<span class="number">1024</span>);</span><br><span class="line">    Bitmap::cacheAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过读卡器将images.bin复制到SD卡中，也可以通过ftp复制到SD卡或flash中</p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815204415575.png" alt="image-20210815204415575"></p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815210431030.png" alt="image-20210815210431030"></p>
<p>编译烧写后,发现程序报错，touchgfx初始化有问题，查看代码后发现touchgfx采用INIT_APP_INIT自动初始化机制，这种机制不能准确定义个模块初始化的顺序，这个模块可能是初始化的太早了，于是注释掉INIT_APP_INIT，并且在mian函数中调用TouchGFXTask();</p>
<p><strong>在TouchGFXTask();前我还加了一段延时，为了解决wifi和touchgfx同时使用导致开机时屏幕短暂花屏的现象</strong></p>
<p><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815220243651.png" alt="image-20210815220243651"><img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815220652663.png"></p>
<p>记得在main函数开始处添加extern</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">TouchGFXTask</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>最后编译烧写进板子，发现一切正常<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210815220055708.png" alt="image-20210815220055708"></p>
<p>编译烧写后一切正常，屏幕运行正常</p>
<p><strong>终端显示sdcard挂载失败是正常现象，因为在TouchGFXHAL::blockCopy已经挂载过sdcard了</strong></p>
<p>但是这个bug看的我很难受，通过查rtthread官方文档发现sd卡挂载函数应该用INIT_ENV_EXPORT来初始化，但是改了之后还是会报sd卡挂载失败，可能是sd卡挂载本身需要一定时间造成的，最终还是blockcopy挂载sdcard的操作起了作用</p>
<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210816144919426.png" alt="image-20210816144919426" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/FranHawk/blogpic/main/image-20210816144957127.png" alt="image-20210816144957127" style="zoom:50%;" />
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Nächste Seite"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Inhaltsverzeichnis
        </li>
        <li class="sidebar-nav-overview">
          Übersicht
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fran Hawk</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">Artikel</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">schlagwörter</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fran Hawk</span>
</div>
  <div class="powered-by">Erstellt mit  <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
